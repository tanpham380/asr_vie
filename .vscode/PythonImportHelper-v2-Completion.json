[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "SEEK_END",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "gradio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gradio",
        "description": "gradio",
        "detail": "gradio",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "torchaudio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchaudio",
        "description": "torchaudio",
        "detail": "torchaudio",
        "documentation": {}
    },
    {
        "label": "InProcAssetMetadataProvider",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "InProcAssetMetadataProvider",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "AssetCard",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "InProcAssetMetadataProvider",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "AssetDownloadManager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "AssetStore",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "AssetStore",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "AssetCard",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "AssetDownloadManager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "AssetStore",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "InProcAssetMetadataProvider",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "asset_store",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "download_manager",
        "importPath": "fairseq2.assets",
        "description": "fairseq2.assets",
        "isExtraImport": true,
        "detail": "fairseq2.assets",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "DataPipeline",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "FileMapper",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "SequenceData",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "SequenceData",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "VocabularyInfo",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "DataPipeline",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "FileMapper",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "VocabularyInfo",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "DataPipeline",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "FileMapper",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "SequenceData",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "StringLike",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "SequenceData",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "StringLike",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "CString",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "VocabularyInfo",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "VocabularyInfo",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "VocabularyInfo",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "VocabularyInfo",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "VocabularyInfo",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "VocabularyInfo",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "SequenceData",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "DataPipelineBuilder",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "StringLike",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "SequenceData",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data",
        "description": "fairseq2.data",
        "isExtraImport": true,
        "detail": "fairseq2.data",
        "documentation": {}
    },
    {
        "label": "AudioDecoder",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankOutput",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoder",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankOutput",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoder",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoder",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoder",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoder",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoder",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankInput",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankInput",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoder",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoderOutput",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoderOutput",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankConverter",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "WaveformToFbankInput",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoder",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "AudioDecoderOutput",
        "importPath": "fairseq2.data.audio",
        "description": "fairseq2.data.audio",
        "isExtraImport": true,
        "detail": "fairseq2.data.audio",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOptions",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOptions",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "BatchedSpeechOutput",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "BatchedSpeechOutput",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "BatchedSpeechOutput",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Modality",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOptions",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOptions",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOptions",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference",
        "description": "seamless_communication.inference",
        "isExtraImport": true,
        "detail": "seamless_communication.inference",
        "documentation": {}
    },
    {
        "label": "NGramRepeatBlockProcessor",
        "importPath": "fairseq2.generation",
        "description": "fairseq2.generation",
        "isExtraImport": true,
        "detail": "fairseq2.generation",
        "documentation": {}
    },
    {
        "label": "NGramRepeatBlockProcessor",
        "importPath": "fairseq2.generation",
        "description": "fairseq2.generation",
        "isExtraImport": true,
        "detail": "fairseq2.generation",
        "documentation": {}
    },
    {
        "label": "BeamSearchSeq2SeqGenerator",
        "importPath": "fairseq2.generation",
        "description": "fairseq2.generation",
        "isExtraImport": true,
        "detail": "fairseq2.generation",
        "documentation": {}
    },
    {
        "label": "Seq2SeqGenerator",
        "importPath": "fairseq2.generation",
        "description": "fairseq2.generation",
        "isExtraImport": true,
        "detail": "fairseq2.generation",
        "documentation": {}
    },
    {
        "label": "SequenceToTextConverter",
        "importPath": "fairseq2.generation",
        "description": "fairseq2.generation",
        "isExtraImport": true,
        "detail": "fairseq2.generation",
        "documentation": {}
    },
    {
        "label": "StepProcessor",
        "importPath": "fairseq2.generation",
        "description": "fairseq2.generation",
        "isExtraImport": true,
        "detail": "fairseq2.generation",
        "documentation": {}
    },
    {
        "label": "BeamSearchSeq2SeqGenerator",
        "importPath": "fairseq2.generation",
        "description": "fairseq2.generation",
        "isExtraImport": true,
        "detail": "fairseq2.generation",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOutput",
        "importPath": "fairseq2.generation",
        "description": "fairseq2.generation",
        "isExtraImport": true,
        "detail": "fairseq2.generation",
        "documentation": {}
    },
    {
        "label": "BannedSequenceProcessor",
        "importPath": "fairseq2.generation",
        "description": "fairseq2.generation",
        "isExtraImport": true,
        "detail": "fairseq2.generation",
        "documentation": {}
    },
    {
        "label": "MemoryBlock",
        "importPath": "fairseq2.memory",
        "description": "fairseq2.memory",
        "isExtraImport": true,
        "detail": "fairseq2.memory",
        "documentation": {}
    },
    {
        "label": "MemoryBlock",
        "importPath": "fairseq2.memory",
        "description": "fairseq2.memory",
        "isExtraImport": true,
        "detail": "fairseq2.memory",
        "documentation": {}
    },
    {
        "label": "MemoryBlock",
        "importPath": "fairseq2.memory",
        "description": "fairseq2.memory",
        "isExtraImport": true,
        "detail": "fairseq2.memory",
        "documentation": {}
    },
    {
        "label": "MemoryBlock",
        "importPath": "fairseq2.memory",
        "description": "fairseq2.memory",
        "isExtraImport": true,
        "detail": "fairseq2.memory",
        "documentation": {}
    },
    {
        "label": "MemoryBlock",
        "importPath": "fairseq2.memory",
        "description": "fairseq2.memory",
        "isExtraImport": true,
        "detail": "fairseq2.memory",
        "documentation": {}
    },
    {
        "label": "snapshot_download",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "hf_hub_download",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "snapshot_download",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "load_gcmvn_stats",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_unit_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_gcmvn_stats",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_unit_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_gcmvn_stats",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_unit_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_text_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_model",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_text_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_unit_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitYT2UModel",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitYX2TModel",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_model",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_text_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitYNART2UModel",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitYT2UModel",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_model",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_text_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_unit_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "unity_archs",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "VariancePredictor",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_gcmvn_stats",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_config",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_model",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_text_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "load_unity_unit_tokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "importPath": "seamless_communication.models.unity",
        "description": "seamless_communication.models.unity",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity",
        "documentation": {}
    },
    {
        "label": "PretsselGenerator",
        "importPath": "seamless_communication.cli.expressivity.predict.pretssel_generator",
        "description": "seamless_communication.cli.expressivity.predict.pretssel_generator",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.expressivity.predict.pretssel_generator",
        "documentation": {}
    },
    {
        "label": "PretsselGenerator",
        "importPath": "seamless_communication.cli.expressivity.predict.pretssel_generator",
        "description": "seamless_communication.cli.expressivity.predict.pretssel_generator",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.expressivity.predict.pretssel_generator",
        "documentation": {}
    },
    {
        "label": "PretsselGenerator",
        "importPath": "seamless_communication.cli.expressivity.predict.pretssel_generator",
        "description": "seamless_communication.cli.expressivity.predict.pretssel_generator",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.expressivity.predict.pretssel_generator",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_CODE_TO_NAME",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.models.inference.translator",
        "description": "seamless_communication.models.inference.translator",
        "isExtraImport": true,
        "detail": "seamless_communication.models.inference.translator",
        "documentation": {}
    },
    {
        "label": "getpass",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "getpass",
        "description": "getpass",
        "detail": "getpass",
        "documentation": {}
    },
    {
        "label": "ASR_TARGET_LANGUAGE_NAMES",
        "importPath": "lang_list",
        "description": "lang_list",
        "isExtraImport": true,
        "detail": "lang_list",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_NAME_TO_CODE",
        "importPath": "lang_list",
        "description": "lang_list",
        "isExtraImport": true,
        "detail": "lang_list",
        "documentation": {}
    },
    {
        "label": "S2ST_TARGET_LANGUAGE_NAMES",
        "importPath": "lang_list",
        "description": "lang_list",
        "isExtraImport": true,
        "detail": "lang_list",
        "documentation": {}
    },
    {
        "label": "S2TT_TARGET_LANGUAGE_NAMES",
        "importPath": "lang_list",
        "description": "lang_list",
        "isExtraImport": true,
        "detail": "lang_list",
        "documentation": {}
    },
    {
        "label": "T2ST_TARGET_LANGUAGE_NAMES",
        "importPath": "lang_list",
        "description": "lang_list",
        "isExtraImport": true,
        "detail": "lang_list",
        "documentation": {}
    },
    {
        "label": "T2TT_TARGET_LANGUAGE_NAMES",
        "importPath": "lang_list",
        "description": "lang_list",
        "isExtraImport": true,
        "detail": "lang_list",
        "documentation": {}
    },
    {
        "label": "TEXT_SOURCE_LANGUAGE_NAMES",
        "importPath": "lang_list",
        "description": "lang_list",
        "isExtraImport": true,
        "detail": "lang_list",
        "documentation": {}
    },
    {
        "label": "_cffi_backend",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_cffi_backend",
        "description": "_cffi_backend",
        "detail": "_cffi_backend",
        "documentation": {}
    },
    {
        "label": "ggml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ggml",
        "description": "ggml",
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "ffi",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "lib",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "lib",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "ffi",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "ffi",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "lib",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "lib",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "ffi",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "NativeObj",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "NativeObj",
        "importPath": "ggml",
        "description": "ggml",
        "isExtraImport": true,
        "detail": "ggml",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "ggml.utils",
        "description": "ggml.utils",
        "isExtraImport": true,
        "detail": "ggml.utils",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "ggml.utils",
        "description": "ggml.utils",
        "isExtraImport": true,
        "detail": "ggml.utils",
        "documentation": {}
    },
    {
        "label": "numpy",
        "importPath": "ggml.utils",
        "description": "ggml.utils",
        "isExtraImport": true,
        "detail": "ggml.utils",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "ggml.utils",
        "description": "ggml.utils",
        "isExtraImport": true,
        "detail": "ggml.utils",
        "documentation": {}
    },
    {
        "label": "numpy",
        "importPath": "ggml.utils",
        "description": "ggml.utils",
        "isExtraImport": true,
        "detail": "ggml.utils",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "ggml.utils",
        "description": "ggml.utils",
        "isExtraImport": true,
        "detail": "ggml.utils",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "ggml.utils",
        "description": "ggml.utils",
        "isExtraImport": true,
        "detail": "ggml.utils",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "ggml.utils",
        "description": "ggml.utils",
        "isExtraImport": true,
        "detail": "ggml.utils",
        "documentation": {}
    },
    {
        "label": "numpy",
        "importPath": "ggml.utils",
        "description": "ggml.utils",
        "isExtraImport": true,
        "detail": "ggml.utils",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "pi",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "cos",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sin",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "cffi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cffi",
        "description": "cffi",
        "detail": "cffi",
        "documentation": {}
    },
    {
        "label": "generate_stubs",
        "importPath": "stubs",
        "description": "stubs",
        "isExtraImport": true,
        "detail": "stubs",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "c_ast",
        "importPath": "pycparser",
        "description": "pycparser",
        "isExtraImport": true,
        "detail": "pycparser",
        "documentation": {}
    },
    {
        "label": "parse_file",
        "importPath": "pycparser",
        "description": "pycparser",
        "isExtraImport": true,
        "detail": "pycparser",
        "documentation": {}
    },
    {
        "label": "CParser",
        "importPath": "pycparser",
        "description": "pycparser",
        "isExtraImport": true,
        "detail": "pycparser",
        "documentation": {}
    },
    {
        "label": "pycparser.plyparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pycparser.plyparser",
        "description": "pycparser.plyparser",
        "detail": "pycparser.plyparser",
        "documentation": {}
    },
    {
        "label": "PtrDecl",
        "importPath": "pycparser.c_ast",
        "description": "pycparser.c_ast",
        "isExtraImport": true,
        "detail": "pycparser.c_ast",
        "documentation": {}
    },
    {
        "label": "TypeDecl",
        "importPath": "pycparser.c_ast",
        "description": "pycparser.c_ast",
        "isExtraImport": true,
        "detail": "pycparser.c_ast",
        "documentation": {}
    },
    {
        "label": "FuncDecl",
        "importPath": "pycparser.c_ast",
        "description": "pycparser.c_ast",
        "isExtraImport": true,
        "detail": "pycparser.c_ast",
        "documentation": {}
    },
    {
        "label": "EllipsisParam",
        "importPath": "pycparser.c_ast",
        "description": "pycparser.c_ast",
        "isExtraImport": true,
        "detail": "pycparser.c_ast",
        "documentation": {}
    },
    {
        "label": "IdentifierType",
        "importPath": "pycparser.c_ast",
        "description": "pycparser.c_ast",
        "isExtraImport": true,
        "detail": "pycparser.c_ast",
        "documentation": {}
    },
    {
        "label": "Struct",
        "importPath": "pycparser.c_ast",
        "description": "pycparser.c_ast",
        "isExtraImport": true,
        "detail": "pycparser.c_ast",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "pycparser.c_ast",
        "description": "pycparser.c_ast",
        "isExtraImport": true,
        "detail": "pycparser.c_ast",
        "documentation": {}
    },
    {
        "label": "Typedef",
        "importPath": "pycparser.c_ast",
        "description": "pycparser.c_ast",
        "isExtraImport": true,
        "detail": "pycparser.c_ast",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "raises",
        "importPath": "pytest",
        "description": "pytest",
        "isExtraImport": true,
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "numpy.testing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.testing",
        "description": "numpy.testing",
        "detail": "numpy.testing",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_void_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_void_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "dataclasses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dataclasses",
        "description": "dataclasses",
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "NULLPTR",
        "importPath": "ctypes_utils",
        "description": "ctypes_utils",
        "isExtraImport": true,
        "detail": "ctypes_utils",
        "documentation": {}
    },
    {
        "label": "Ptr",
        "importPath": "ctypes_utils",
        "description": "ctypes_utils",
        "isExtraImport": true,
        "detail": "ctypes_utils",
        "documentation": {}
    },
    {
        "label": "c_fn",
        "importPath": "ctypes_utils",
        "description": "ctypes_utils",
        "isExtraImport": true,
        "detail": "ctypes_utils",
        "documentation": {}
    },
    {
        "label": "c_struct",
        "importPath": "ctypes_utils",
        "description": "ctypes_utils",
        "isExtraImport": true,
        "detail": "ctypes_utils",
        "documentation": {}
    },
    {
        "label": "Ptr",
        "importPath": "ctypes_utils",
        "description": "ctypes_utils",
        "isExtraImport": true,
        "detail": "ctypes_utils",
        "documentation": {}
    },
    {
        "label": "NULLPTR",
        "importPath": "ctypes_utils",
        "description": "ctypes_utils",
        "isExtraImport": true,
        "detail": "ctypes_utils",
        "documentation": {}
    },
    {
        "label": "Ptr",
        "importPath": "ctypes_utils",
        "description": "ctypes_utils",
        "isExtraImport": true,
        "detail": "ctypes_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "third_party_ggml",
        "description": "third_party_ggml",
        "isExtraImport": true,
        "detail": "third_party_ggml",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "BufferedWriter",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "TransformerEmbeddingFrontend",
        "importPath": "fairseq2.models.transformer.frontend",
        "description": "fairseq2.models.transformer.frontend",
        "isExtraImport": true,
        "detail": "fairseq2.models.transformer.frontend",
        "documentation": {}
    },
    {
        "label": "TransformerFrontend",
        "importPath": "fairseq2.models.transformer.frontend",
        "description": "fairseq2.models.transformer.frontend",
        "isExtraImport": true,
        "detail": "fairseq2.models.transformer.frontend",
        "documentation": {}
    },
    {
        "label": "TransformerFrontend",
        "importPath": "fairseq2.models.transformer.frontend",
        "description": "fairseq2.models.transformer.frontend",
        "isExtraImport": true,
        "detail": "fairseq2.models.transformer.frontend",
        "documentation": {}
    },
    {
        "label": "fairseq2.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fairseq2.nn",
        "description": "fairseq2.nn",
        "detail": "fairseq2.nn",
        "documentation": {}
    },
    {
        "label": "SinusoidalPositionEncoder",
        "importPath": "fairseq2.nn",
        "description": "fairseq2.nn",
        "isExtraImport": true,
        "detail": "fairseq2.nn",
        "documentation": {}
    },
    {
        "label": "fairseq2.nn.transformer",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "RelativePositionalEncoding",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "SDPA",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "ShawRelativePositionSDPA",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_default_sdpa",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "MultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardMultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerNormOrder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_default_sdpa",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "FeedForwardNetwork",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "MultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardFeedForwardNetwork",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardMultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerNormOrder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_default_sdpa",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "AttentionMaskFactory",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "CausalAttentionMaskFactory",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_standard_layer_norm",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "AttentionMask",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "FeedForwardNetwork",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "MultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_standard_layer_norm",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerEncoder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerNormOrder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "AttentionMask",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "FeedForwardNetwork",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "LayerNormFactory",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "MultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerEncoder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerEncoderLayer",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_standard_layer_norm",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "FeedForwardNetwork",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "MultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardFeedForwardNetwork",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardMultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerEncoder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerEncoderLayer",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerNormOrder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_default_sdpa",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerNormOrder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_standard_layer_norm",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "MultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_standard_layer_norm",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_standard_layer_norm",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerDecoder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerEncoder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_standard_layer_norm",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "FeedForwardNetwork",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "MultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardFeedForwardNetwork",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardMultiheadAttention",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardTransformerDecoder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardTransformerDecoderLayer",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardTransformerEncoder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "StandardTransformerEncoderLayer",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerDecoder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerDecoderLayer",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerEncoder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerEncoderLayer",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerNormOrder",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "create_default_sdpa",
        "importPath": "fairseq2.nn.transformer",
        "description": "fairseq2.nn.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer",
        "documentation": {}
    },
    {
        "label": "SentencePieceEncoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "SentencePieceTokenizerBase",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "StrSplitter",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "read_text",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "StrSplitter",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenizer",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "read_text",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenEncoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "StrSplitter",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "read_text",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenizer",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenizer",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "SentencePieceDecoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "SentencePieceEncoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "SentencePieceModel",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenDecoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenEncoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenizer",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "vocab_info_from_sentencepiece",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "SentencePieceDecoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "SentencePieceEncoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "SentencePieceModel",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenDecoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenEncoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenizer",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "vocab_info_from_sentencepiece",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "TextTokenizer",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "SentencePieceEncoder",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "SentencePieceModel",
        "importPath": "fairseq2.data.text",
        "description": "fairseq2.data.text",
        "isExtraImport": true,
        "detail": "fairseq2.data.text",
        "documentation": {}
    },
    {
        "label": "PathLike",
        "importPath": "fairseq2.data.typing",
        "description": "fairseq2.data.typing",
        "isExtraImport": true,
        "detail": "fairseq2.data.typing",
        "documentation": {}
    },
    {
        "label": "StringLike",
        "importPath": "fairseq2.data.typing",
        "description": "fairseq2.data.typing",
        "isExtraImport": true,
        "detail": "fairseq2.data.typing",
        "documentation": {}
    },
    {
        "label": "StringLike",
        "importPath": "fairseq2.data.typing",
        "description": "fairseq2.data.typing",
        "isExtraImport": true,
        "detail": "fairseq2.data.typing",
        "documentation": {}
    },
    {
        "label": "PathLike",
        "importPath": "fairseq2.data.typing",
        "description": "fairseq2.data.typing",
        "isExtraImport": true,
        "detail": "fairseq2.data.typing",
        "documentation": {}
    },
    {
        "label": "PathLike",
        "importPath": "fairseq2.data.typing",
        "description": "fairseq2.data.typing",
        "isExtraImport": true,
        "detail": "fairseq2.data.typing",
        "documentation": {}
    },
    {
        "label": "StringLike",
        "importPath": "fairseq2.data.typing",
        "description": "fairseq2.data.typing",
        "isExtraImport": true,
        "detail": "fairseq2.data.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "finaloverride",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "finaloverride",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "finaloverride",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "finaloverride",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "override",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "finaloverride",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "finaloverride",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "finaloverride",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "finaloverride",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "finaloverride",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "DataType",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "fairseq2.typing",
        "description": "fairseq2.typing",
        "isExtraImport": true,
        "detail": "fairseq2.typing",
        "documentation": {}
    },
    {
        "label": "TokenizerLoaderBase",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ModelLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ModelLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ConfigLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ModelLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ModelLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ConfigLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ModelLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ConfigLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ModelLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ConfigLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ModelLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ConfigLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ModelLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ConfigLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "ModelLoader",
        "importPath": "fairseq2.models.utils",
        "description": "fairseq2.models.utils",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils",
        "documentation": {}
    },
    {
        "label": "convert_model_state_dict",
        "importPath": "fairseq2.models.utils.checkpoint",
        "description": "fairseq2.models.utils.checkpoint",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.checkpoint",
        "documentation": {}
    },
    {
        "label": "convert_fairseq_checkpoint",
        "importPath": "fairseq2.models.utils.checkpoint",
        "description": "fairseq2.models.utils.checkpoint",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.checkpoint",
        "documentation": {}
    },
    {
        "label": "convert_fairseq_checkpoint",
        "importPath": "fairseq2.models.utils.checkpoint",
        "description": "fairseq2.models.utils.checkpoint",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.checkpoint",
        "documentation": {}
    },
    {
        "label": "convert_fairseq_checkpoint",
        "importPath": "fairseq2.models.utils.checkpoint",
        "description": "fairseq2.models.utils.checkpoint",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.checkpoint",
        "documentation": {}
    },
    {
        "label": "convert_fairseq_checkpoint",
        "importPath": "fairseq2.models.utils.checkpoint",
        "description": "fairseq2.models.utils.checkpoint",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.checkpoint",
        "documentation": {}
    },
    {
        "label": "Parameter",
        "importPath": "torch.nn.parameter",
        "description": "torch.nn.parameter",
        "isExtraImport": true,
        "detail": "torch.nn.parameter",
        "documentation": {}
    },
    {
        "label": "Parameter",
        "importPath": "torch.nn.parameter",
        "description": "torch.nn.parameter",
        "isExtraImport": true,
        "detail": "torch.nn.parameter",
        "documentation": {}
    },
    {
        "label": "BeamSearchSeq2SeqGenerator",
        "importPath": "fairseq2.generation.beam_search",
        "description": "fairseq2.generation.beam_search",
        "isExtraImport": true,
        "detail": "fairseq2.generation.beam_search",
        "documentation": {}
    },
    {
        "label": "StandardEmbedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "StandardEmbedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "init_scaled_embedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "StandardEmbedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "StandardEmbedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "init_scaled_embedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "Embedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "StandardEmbedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "Embedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "StandardEmbedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "init_scaled_embedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "Embedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "Embedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "StandardEmbedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "init_scaled_embedding",
        "importPath": "fairseq2.nn.embedding",
        "description": "fairseq2.nn.embedding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.embedding",
        "documentation": {}
    },
    {
        "label": "NllbBuilder",
        "importPath": "fairseq2.models.nllb.builder",
        "description": "fairseq2.models.nllb.builder",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb.builder",
        "documentation": {}
    },
    {
        "label": "NllbConfig",
        "importPath": "fairseq2.models.nllb.builder",
        "description": "fairseq2.models.nllb.builder",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb.builder",
        "documentation": {}
    },
    {
        "label": "load_nllb_config",
        "importPath": "fairseq2.models.nllb.loader",
        "description": "fairseq2.models.nllb.loader",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb.loader",
        "documentation": {}
    },
    {
        "label": "NllbTokenizerLoader",
        "importPath": "fairseq2.models.nllb.loader",
        "description": "fairseq2.models.nllb.loader",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb.loader",
        "documentation": {}
    },
    {
        "label": "NllbTokenizerLoader",
        "importPath": "fairseq2.models.nllb.loader",
        "description": "fairseq2.models.nllb.loader",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb.loader",
        "documentation": {}
    },
    {
        "label": "TiedProjection",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Projection",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "TiedProjection",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Projection",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "TiedProjection",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Projection",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "Projection",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "TiedProjection",
        "importPath": "fairseq2.nn.projection",
        "description": "fairseq2.nn.projection",
        "isExtraImport": true,
        "detail": "fairseq2.nn.projection",
        "documentation": {}
    },
    {
        "label": "TransformerModel",
        "importPath": "fairseq2.models.transformer.model",
        "description": "fairseq2.models.transformer.model",
        "isExtraImport": true,
        "detail": "fairseq2.models.transformer.model",
        "documentation": {}
    },
    {
        "label": "sentencepiece",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sentencepiece",
        "description": "sentencepiece",
        "detail": "sentencepiece",
        "documentation": {}
    },
    {
        "label": "convert_model",
        "importPath": "ggml_convert",
        "description": "ggml_convert",
        "isExtraImport": true,
        "detail": "ggml_convert",
        "documentation": {}
    },
    {
        "label": "convert_model",
        "importPath": "ggml_convert",
        "description": "ggml_convert",
        "isExtraImport": true,
        "detail": "ggml_convert",
        "documentation": {}
    },
    {
        "label": "read_layer_config",
        "importPath": "ggml_convert",
        "description": "ggml_convert",
        "isExtraImport": true,
        "detail": "ggml_convert",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2FbankFeatureExtractor",
        "importPath": "fairseq2.models.wav2vec2.feature_extractor",
        "description": "fairseq2.models.wav2vec2.feature_extractor",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.feature_extractor",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOptions",
        "importPath": "seamless_communication.inference.generator",
        "description": "seamless_communication.inference.generator",
        "isExtraImport": true,
        "detail": "seamless_communication.inference.generator",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOptions",
        "importPath": "seamless_communication.inference.generator",
        "description": "seamless_communication.inference.generator",
        "isExtraImport": true,
        "detail": "seamless_communication.inference.generator",
        "documentation": {}
    },
    {
        "label": "UnitYGenerator",
        "importPath": "seamless_communication.inference.generator",
        "description": "seamless_communication.inference.generator",
        "isExtraImport": true,
        "detail": "seamless_communication.inference.generator",
        "documentation": {}
    },
    {
        "label": "Modality",
        "importPath": "seamless_communication.inference.translator",
        "description": "seamless_communication.inference.translator",
        "isExtraImport": true,
        "detail": "seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference.translator",
        "description": "seamless_communication.inference.translator",
        "isExtraImport": true,
        "detail": "seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "Modality",
        "importPath": "seamless_communication.inference.translator",
        "description": "seamless_communication.inference.translator",
        "isExtraImport": true,
        "detail": "seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "Modality",
        "importPath": "seamless_communication.inference.translator",
        "description": "seamless_communication.inference.translator",
        "isExtraImport": true,
        "detail": "seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference.translator",
        "description": "seamless_communication.inference.translator",
        "isExtraImport": true,
        "detail": "seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "seamless_communication.inference.translator",
        "description": "seamless_communication.inference.translator",
        "isExtraImport": true,
        "detail": "seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "importlib.resources",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.resources",
        "description": "importlib.resources",
        "detail": "importlib.resources",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "whisper",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "whisper",
        "description": "whisper",
        "detail": "whisper",
        "documentation": {}
    },
    {
        "label": "Whisper",
        "importPath": "whisper",
        "description": "whisper",
        "isExtraImport": true,
        "detail": "whisper",
        "documentation": {}
    },
    {
        "label": "cer",
        "importPath": "jiwer",
        "description": "jiwer",
        "isExtraImport": true,
        "detail": "jiwer",
        "documentation": {}
    },
    {
        "label": "wer",
        "importPath": "jiwer",
        "description": "jiwer",
        "isExtraImport": true,
        "detail": "jiwer",
        "documentation": {}
    },
    {
        "label": "Score",
        "importPath": "sacrebleu.metrics.base",
        "description": "sacrebleu.metrics.base",
        "isExtraImport": true,
        "detail": "sacrebleu.metrics.base",
        "documentation": {}
    },
    {
        "label": "Signature",
        "importPath": "sacrebleu.metrics.base",
        "description": "sacrebleu.metrics.base",
        "isExtraImport": true,
        "detail": "sacrebleu.metrics.base",
        "documentation": {}
    },
    {
        "label": "BLEU",
        "importPath": "sacrebleu.metrics.bleu",
        "description": "sacrebleu.metrics.bleu",
        "isExtraImport": true,
        "detail": "sacrebleu.metrics.bleu",
        "documentation": {}
    },
    {
        "label": "CHRF",
        "importPath": "sacrebleu.metrics.chrf",
        "description": "sacrebleu.metrics.chrf",
        "isExtraImport": true,
        "detail": "sacrebleu.metrics.chrf",
        "documentation": {}
    },
    {
        "label": "LANG3_LANG2",
        "importPath": "seamless_communication.cli.eval_utils.lang_mapping",
        "description": "seamless_communication.cli.eval_utils.lang_mapping",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.eval_utils.lang_mapping",
        "documentation": {}
    },
    {
        "label": "LANG3_LANG2",
        "importPath": "seamless_communication.cli.eval_utils.lang_mapping",
        "description": "seamless_communication.cli.eval_utils.lang_mapping",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.eval_utils.lang_mapping",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "BasicTextNormalizer",
        "importPath": "whisper.normalizers",
        "description": "whisper.normalizers",
        "isExtraImport": true,
        "detail": "whisper.normalizers",
        "documentation": {}
    },
    {
        "label": "EnglishTextNormalizer",
        "importPath": "whisper.normalizers",
        "description": "whisper.normalizers",
        "isExtraImport": true,
        "detail": "whisper.normalizers",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentTypeError",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "seamless_communication",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seamless_communication",
        "description": "seamless_communication",
        "detail": "seamless_communication",
        "documentation": {}
    },
    {
        "label": "adjust_output_for_corrupted_inputs",
        "importPath": "seamless_communication.cli.m4t.evaluate.evaluate",
        "description": "seamless_communication.cli.m4t.evaluate.evaluate",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "count_lines",
        "importPath": "seamless_communication.cli.m4t.evaluate.evaluate",
        "description": "seamless_communication.cli.m4t.evaluate.evaluate",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "add_inference_arguments",
        "importPath": "seamless_communication.cli.m4t.predict",
        "description": "seamless_communication.cli.m4t.predict",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.predict",
        "documentation": {}
    },
    {
        "label": "set_generation_opts",
        "importPath": "seamless_communication.cli.m4t.predict",
        "description": "seamless_communication.cli.m4t.predict",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.predict",
        "documentation": {}
    },
    {
        "label": "add_inference_arguments",
        "importPath": "seamless_communication.cli.m4t.predict",
        "description": "seamless_communication.cli.m4t.predict",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.predict",
        "documentation": {}
    },
    {
        "label": "set_generation_opts",
        "importPath": "seamless_communication.cli.m4t.predict",
        "description": "seamless_communication.cli.m4t.predict",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.predict",
        "documentation": {}
    },
    {
        "label": "add_inference_arguments",
        "importPath": "seamless_communication.cli.m4t.predict",
        "description": "seamless_communication.cli.m4t.predict",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.predict",
        "documentation": {}
    },
    {
        "label": "set_generation_opts",
        "importPath": "seamless_communication.cli.m4t.predict",
        "description": "seamless_communication.cli.m4t.predict",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.predict",
        "documentation": {}
    },
    {
        "label": "add_gated_assets",
        "importPath": "seamless_communication.store",
        "description": "seamless_communication.store",
        "isExtraImport": true,
        "detail": "seamless_communication.store",
        "documentation": {}
    },
    {
        "label": "add_gated_assets",
        "importPath": "seamless_communication.store",
        "description": "seamless_communication.store",
        "isExtraImport": true,
        "detail": "seamless_communication.store",
        "documentation": {}
    },
    {
        "label": "add_gated_assets",
        "importPath": "seamless_communication.store",
        "description": "seamless_communication.store",
        "isExtraImport": true,
        "detail": "seamless_communication.store",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "scipy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy",
        "description": "scipy",
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "Fire",
        "importPath": "fire",
        "description": "fire",
        "isExtraImport": true,
        "detail": "fire",
        "documentation": {}
    },
    {
        "label": "compute_quality_metrics",
        "importPath": "seamless_communication.cli.eval_utils.compute_metrics",
        "description": "seamless_communication.cli.eval_utils.compute_metrics",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "init_whisper_model",
        "importPath": "seamless_communication.cli.eval_utils.compute_metrics",
        "description": "seamless_communication.cli.eval_utils.compute_metrics",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Conv1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Conv1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ModuleList",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Sigmoid",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Tanh",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ELU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "LSTM",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Conv1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ConvTranspose1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "GroupNorm",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Identity",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ELU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "BatchNorm1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Conv1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ConvTranspose1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ModuleList",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Parameter",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Tanh",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "AvgPool1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ModuleList",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Conv1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ModuleList",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Sigmoid",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Tanh",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "GLU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Conv1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "GELU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Conv1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Parameter",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Conv1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Parameter",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "GELU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Conv1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ConvTranspose1d",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "ModuleList",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "get_seqs_and_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "apply_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "get_seqs_and_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "pad_seqs",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "get_seqs_and_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "to_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "to_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "to_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "get_seqs_and_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "apply_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "apply_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "to_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "PaddingMask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "get_seqs_and_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "get_seqs_and_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "get_seqs_and_padding_mask",
        "importPath": "fairseq2.nn.padding",
        "description": "fairseq2.nn.padding",
        "isExtraImport": true,
        "detail": "fairseq2.nn.padding",
        "documentation": {}
    },
    {
        "label": "load_pretssel_vocoder_model",
        "importPath": "seamless_communication.models.generator.loader",
        "description": "seamless_communication.models.generator.loader",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.loader",
        "documentation": {}
    },
    {
        "label": "load_pretssel_vocoder_model",
        "importPath": "seamless_communication.models.generator.loader",
        "description": "seamless_communication.models.generator.loader",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.loader",
        "documentation": {}
    },
    {
        "label": "load_pretssel_vocoder_model",
        "importPath": "seamless_communication.models.generator.loader",
        "description": "seamless_communication.models.generator.loader",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.loader",
        "documentation": {}
    },
    {
        "label": "UnitExtractor",
        "importPath": "seamless_communication.models.unit_extractor",
        "description": "seamless_communication.models.unit_extractor",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unit_extractor",
        "documentation": {}
    },
    {
        "label": "UnitExtractor",
        "importPath": "seamless_communication.models.unit_extractor",
        "description": "seamless_communication.models.unit_extractor",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unit_extractor",
        "documentation": {}
    },
    {
        "label": "UnitExtractor",
        "importPath": "seamless_communication.models.unit_extractor",
        "description": "seamless_communication.models.unit_extractor",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unit_extractor",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "compute_quality_metrics",
        "importPath": "seamless_communication.cli.eval_utils",
        "description": "seamless_communication.cli.eval_utils",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.eval_utils",
        "documentation": {}
    },
    {
        "label": "compute_quality_metrics",
        "importPath": "seamless_communication.cli.eval_utils",
        "description": "seamless_communication.cli.eval_utils",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.eval_utils",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "datasets",
        "description": "datasets",
        "isExtraImport": true,
        "detail": "datasets",
        "documentation": {}
    },
    {
        "label": "load_dataset",
        "importPath": "datasets",
        "description": "datasets",
        "isExtraImport": true,
        "detail": "datasets",
        "documentation": {}
    },
    {
        "label": "load_dataset",
        "importPath": "datasets",
        "description": "datasets",
        "isExtraImport": true,
        "detail": "datasets",
        "documentation": {}
    },
    {
        "label": "load_dataset",
        "importPath": "datasets",
        "description": "datasets",
        "isExtraImport": true,
        "detail": "datasets",
        "documentation": {}
    },
    {
        "label": "split_dataset_by_node",
        "importPath": "datasets.distributed",
        "description": "datasets.distributed",
        "isExtraImport": true,
        "detail": "datasets.distributed",
        "documentation": {}
    },
    {
        "label": "NllbTokenizer",
        "importPath": "fairseq2.models.nllb",
        "description": "fairseq2.models.nllb",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb",
        "documentation": {}
    },
    {
        "label": "NllbBuilder",
        "importPath": "fairseq2.models.nllb",
        "description": "fairseq2.models.nllb",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb",
        "documentation": {}
    },
    {
        "label": "NllbConfig",
        "importPath": "fairseq2.models.nllb",
        "description": "fairseq2.models.nllb",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb",
        "documentation": {}
    },
    {
        "label": "nllb_archs",
        "importPath": "fairseq2.models.nllb",
        "description": "fairseq2.models.nllb",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb",
        "documentation": {}
    },
    {
        "label": "NllbConfig",
        "importPath": "fairseq2.models.nllb",
        "description": "fairseq2.models.nllb",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "pad",
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "isExtraImport": true,
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "LangPairSample",
        "importPath": "seamless_communication.datasets.datatypes",
        "description": "seamless_communication.datasets.datatypes",
        "isExtraImport": true,
        "detail": "seamless_communication.datasets.datatypes",
        "documentation": {}
    },
    {
        "label": "UnitTokenEncoder",
        "importPath": "seamless_communication.models.unity.unit_tokenizer",
        "description": "seamless_communication.models.unity.unit_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "importPath": "seamless_communication.models.unity.unit_tokenizer",
        "description": "seamless_communication.models.unity.unit_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "UnitTokenDecoder",
        "importPath": "seamless_communication.models.unity.unit_tokenizer",
        "description": "seamless_communication.models.unity.unit_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "importPath": "seamless_communication.models.unity.unit_tokenizer",
        "description": "seamless_communication.models.unity.unit_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "importPath": "seamless_communication.models.unity.unit_tokenizer",
        "description": "seamless_communication.models.unity.unit_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "importPath": "seamless_communication.models.unity.unit_tokenizer",
        "description": "seamless_communication.models.unity.unit_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "importPath": "seamless_communication.models.unity.unit_tokenizer",
        "description": "seamless_communication.models.unity.unit_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "Speech2SpeechFleursDatasetBuilder",
        "importPath": "seamless_communication.datasets.huggingface",
        "description": "seamless_communication.datasets.huggingface",
        "isExtraImport": true,
        "detail": "seamless_communication.datasets.huggingface",
        "documentation": {}
    },
    {
        "label": "SpeechTokenizer",
        "importPath": "seamless_communication.datasets.huggingface",
        "description": "seamless_communication.datasets.huggingface",
        "isExtraImport": true,
        "detail": "seamless_communication.datasets.huggingface",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "torch.distributed",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.distributed",
        "description": "torch.distributed",
        "detail": "torch.distributed",
        "documentation": {}
    },
    {
        "label": "torch.multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.multiprocessing",
        "description": "torch.multiprocessing",
        "detail": "torch.multiprocessing",
        "documentation": {}
    },
    {
        "label": "NllbTokenizer",
        "importPath": "fairseq2.models.nllb.tokenizer",
        "description": "fairseq2.models.nllb.tokenizer",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb.tokenizer",
        "documentation": {}
    },
    {
        "label": "NllbTokenizer",
        "importPath": "fairseq2.models.nllb.tokenizer",
        "description": "fairseq2.models.nllb.tokenizer",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb.tokenizer",
        "documentation": {}
    },
    {
        "label": "NllbTokenizer",
        "importPath": "fairseq2.models.nllb.tokenizer",
        "description": "fairseq2.models.nllb.tokenizer",
        "isExtraImport": true,
        "detail": "fairseq2.models.nllb.tokenizer",
        "documentation": {}
    },
    {
        "label": "dataloader",
        "importPath": "seamless_communication.cli.m4t.finetune",
        "description": "seamless_communication.cli.m4t.finetune",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.finetune",
        "documentation": {}
    },
    {
        "label": "dist_utils",
        "importPath": "seamless_communication.cli.m4t.finetune",
        "description": "seamless_communication.cli.m4t.finetune",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.finetune",
        "documentation": {}
    },
    {
        "label": "trainer",
        "importPath": "seamless_communication.cli.m4t.finetune",
        "description": "seamless_communication.cli.m4t.finetune",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.finetune",
        "documentation": {}
    },
    {
        "label": "dataloader",
        "importPath": "seamless_communication.cli.m4t.finetune",
        "description": "seamless_communication.cli.m4t.finetune",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.finetune",
        "documentation": {}
    },
    {
        "label": "dist_utils",
        "importPath": "seamless_communication.cli.m4t.finetune",
        "description": "seamless_communication.cli.m4t.finetune",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.m4t.finetune",
        "documentation": {}
    },
    {
        "label": "SequenceModelOutput",
        "importPath": "fairseq2.models.sequence",
        "description": "fairseq2.models.sequence",
        "isExtraImport": true,
        "detail": "fairseq2.models.sequence",
        "documentation": {}
    },
    {
        "label": "SequenceBatch",
        "importPath": "fairseq2.models.sequence",
        "description": "fairseq2.models.sequence",
        "isExtraImport": true,
        "detail": "fairseq2.models.sequence",
        "documentation": {}
    },
    {
        "label": "SequenceBatch",
        "importPath": "fairseq2.models.sequence",
        "description": "fairseq2.models.sequence",
        "isExtraImport": true,
        "detail": "fairseq2.models.sequence",
        "documentation": {}
    },
    {
        "label": "SequenceModelOutput",
        "importPath": "fairseq2.models.sequence",
        "description": "fairseq2.models.sequence",
        "isExtraImport": true,
        "detail": "fairseq2.models.sequence",
        "documentation": {}
    },
    {
        "label": "MyleLR",
        "importPath": "fairseq2.optim.lr_scheduler",
        "description": "fairseq2.optim.lr_scheduler",
        "isExtraImport": true,
        "detail": "fairseq2.optim.lr_scheduler",
        "documentation": {}
    },
    {
        "label": "AdamW",
        "importPath": "torch.optim",
        "description": "torch.optim",
        "isExtraImport": true,
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "LogInstance",
        "importPath": "simuleval.evaluator.instance",
        "description": "simuleval.evaluator.instance",
        "isExtraImport": true,
        "detail": "simuleval.evaluator.instance",
        "documentation": {}
    },
    {
        "label": "QualityScorer",
        "importPath": "simuleval.evaluator.scorers.quality_scorer",
        "description": "simuleval.evaluator.scorers.quality_scorer",
        "isExtraImport": true,
        "detail": "simuleval.evaluator.scorers.quality_scorer",
        "documentation": {}
    },
    {
        "label": "register_quality_scorer",
        "importPath": "simuleval.evaluator.scorers.quality_scorer",
        "description": "simuleval.evaluator.scorers.quality_scorer",
        "isExtraImport": true,
        "detail": "simuleval.evaluator.scorers.quality_scorer",
        "documentation": {}
    },
    {
        "label": "SeamlessQualityScorer",
        "importPath": "seamless_communication.cli.streaming.scorers.seamless_quality_scorer",
        "description": "seamless_communication.cli.streaming.scorers.seamless_quality_scorer",
        "isExtraImport": true,
        "detail": "seamless_communication.cli.streaming.scorers.seamless_quality_scorer",
        "documentation": {}
    },
    {
        "label": "SeamlessS2STAgent",
        "importPath": "seamless_communication.streaming.agents.seamless_s2st",
        "description": "seamless_communication.streaming.agents.seamless_s2st",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.seamless_s2st",
        "documentation": {}
    },
    {
        "label": "SeamlessStreamingS2STAgent",
        "importPath": "seamless_communication.streaming.agents.seamless_streaming_s2st",
        "description": "seamless_communication.streaming.agents.seamless_streaming_s2st",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.seamless_streaming_s2st",
        "documentation": {}
    },
    {
        "label": "SeamlessStreamingS2TAgent",
        "importPath": "seamless_communication.streaming.agents.seamless_streaming_s2t",
        "description": "seamless_communication.streaming.agents.seamless_streaming_s2t",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.seamless_streaming_s2t",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "simuleval.cli",
        "description": "simuleval.cli",
        "isExtraImport": true,
        "detail": "simuleval.cli",
        "documentation": {}
    },
    {
        "label": "load_etox_bad_word_checker",
        "importPath": "seamless_communication.toxicity",
        "description": "seamless_communication.toxicity",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity",
        "documentation": {}
    },
    {
        "label": "load_etox_bad_word_checker",
        "importPath": "seamless_communication.toxicity",
        "description": "seamless_communication.toxicity",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity",
        "documentation": {}
    },
    {
        "label": "ETOXBadWordChecker",
        "importPath": "seamless_communication.toxicity",
        "description": "seamless_communication.toxicity",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity",
        "documentation": {}
    },
    {
        "label": "load_etox_bad_word_checker",
        "importPath": "seamless_communication.toxicity",
        "description": "seamless_communication.toxicity",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity",
        "documentation": {}
    },
    {
        "label": "load_etox_bad_word_checker",
        "importPath": "seamless_communication.toxicity",
        "description": "seamless_communication.toxicity",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity",
        "documentation": {}
    },
    {
        "label": "Whisper",
        "importPath": "whisper.model",
        "description": "whisper.model",
        "isExtraImport": true,
        "detail": "whisper.model",
        "documentation": {}
    },
    {
        "label": "SpeechInferenceParams",
        "importPath": "sonar.inference_pipelines.speech",
        "description": "sonar.inference_pipelines.speech",
        "isExtraImport": true,
        "detail": "sonar.inference_pipelines.speech",
        "documentation": {}
    },
    {
        "label": "SpeechToEmbeddingPipeline",
        "importPath": "sonar.inference_pipelines.speech",
        "description": "sonar.inference_pipelines.speech",
        "isExtraImport": true,
        "detail": "sonar.inference_pipelines.speech",
        "documentation": {}
    },
    {
        "label": "SpeechInferenceParams",
        "importPath": "sonar.inference_pipelines.speech",
        "description": "sonar.inference_pipelines.speech",
        "isExtraImport": true,
        "detail": "sonar.inference_pipelines.speech",
        "documentation": {}
    },
    {
        "label": "MutoxSpeechClassifierPipeline",
        "importPath": "seamless_communication.toxicity.mutox.speech_pipeline",
        "description": "seamless_communication.toxicity.mutox.speech_pipeline",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.speech_pipeline",
        "documentation": {}
    },
    {
        "label": "load_mutox_model",
        "importPath": "seamless_communication.toxicity.mutox.loader",
        "description": "seamless_communication.toxicity.mutox.loader",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.loader",
        "documentation": {}
    },
    {
        "label": "load_mutox_model",
        "importPath": "seamless_communication.toxicity.mutox.loader",
        "description": "seamless_communication.toxicity.mutox.loader",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.loader",
        "documentation": {}
    },
    {
        "label": "TextToEmbeddingModelPipeline",
        "importPath": "sonar.inference_pipelines.text",
        "description": "sonar.inference_pipelines.text",
        "isExtraImport": true,
        "detail": "sonar.inference_pipelines.text",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "infer_device",
        "importPath": "fairseq2.nn.utils.module",
        "description": "fairseq2.nn.utils.module",
        "isExtraImport": true,
        "detail": "fairseq2.nn.utils.module",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYT2UModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYX2TModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYNART2UModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYT2UModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYNART2UModel",
        "importPath": "seamless_communication.models.unity.model",
        "description": "seamless_communication.models.unity.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "AssetCard",
        "importPath": "fairseq2.assets.card",
        "description": "fairseq2.assets.card",
        "isExtraImport": true,
        "detail": "fairseq2.assets.card",
        "documentation": {}
    },
    {
        "label": "AssetCard",
        "importPath": "fairseq2.assets.card",
        "description": "fairseq2.assets.card",
        "isExtraImport": true,
        "detail": "fairseq2.assets.card",
        "documentation": {}
    },
    {
        "label": "AssetCard",
        "importPath": "fairseq2.assets.card",
        "description": "fairseq2.assets.card",
        "isExtraImport": true,
        "detail": "fairseq2.assets.card",
        "documentation": {}
    },
    {
        "label": "AssetCard",
        "importPath": "fairseq2.assets.card",
        "description": "fairseq2.assets.card",
        "isExtraImport": true,
        "detail": "fairseq2.assets.card",
        "documentation": {}
    },
    {
        "label": "AssetCard",
        "importPath": "fairseq2.assets.card",
        "description": "fairseq2.assets.card",
        "isExtraImport": true,
        "detail": "fairseq2.assets.card",
        "documentation": {}
    },
    {
        "label": "AssetCard",
        "importPath": "fairseq2.assets.card",
        "description": "fairseq2.assets.card",
        "isExtraImport": true,
        "detail": "fairseq2.assets.card",
        "documentation": {}
    },
    {
        "label": "AssetCardFieldNotFoundError",
        "importPath": "fairseq2.assets.card",
        "description": "fairseq2.assets.card",
        "isExtraImport": true,
        "detail": "fairseq2.assets.card",
        "documentation": {}
    },
    {
        "label": "AssetCard",
        "importPath": "fairseq2.assets.card",
        "description": "fairseq2.assets.card",
        "isExtraImport": true,
        "detail": "fairseq2.assets.card",
        "documentation": {}
    },
    {
        "label": "AttentionWeightHook",
        "importPath": "fairseq2.nn.transformer.multihead_attention",
        "description": "fairseq2.nn.transformer.multihead_attention",
        "isExtraImport": true,
        "detail": "fairseq2.nn.transformer.multihead_attention",
        "documentation": {}
    },
    {
        "label": "medfilt2d",
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "isExtraImport": true,
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "load_vocoder_model",
        "importPath": "seamless_communication.models.vocoder",
        "description": "seamless_communication.models.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder",
        "documentation": {}
    },
    {
        "label": "Vocoder",
        "importPath": "seamless_communication.models.vocoder",
        "description": "seamless_communication.models.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder",
        "documentation": {}
    },
    {
        "label": "load_vocoder_model",
        "importPath": "seamless_communication.models.vocoder",
        "description": "seamless_communication.models.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder",
        "documentation": {}
    },
    {
        "label": "mintox_pipeline",
        "importPath": "seamless_communication.toxicity.mintox",
        "description": "seamless_communication.toxicity.mintox",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mintox",
        "documentation": {}
    },
    {
        "label": "_extract_bad_words_with_batch_indices",
        "importPath": "seamless_communication.toxicity.mintox",
        "description": "seamless_communication.toxicity.mintox",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mintox",
        "documentation": {}
    },
    {
        "label": "load_unity2_alignment_model",
        "importPath": "seamless_communication.models.aligner.loader",
        "description": "seamless_communication.models.aligner.loader",
        "isExtraImport": true,
        "detail": "seamless_communication.models.aligner.loader",
        "documentation": {}
    },
    {
        "label": "VocabularyInfo",
        "importPath": "fairseq2.data.vocabulary_info",
        "description": "fairseq2.data.vocabulary_info",
        "isExtraImport": true,
        "detail": "fairseq2.data.vocabulary_info",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "ArchitectureRegistry",
        "importPath": "fairseq2.models.utils.arch_registry",
        "description": "fairseq2.models.utils.arch_registry",
        "isExtraImport": true,
        "detail": "fairseq2.models.utils.arch_registry",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentEncoder",
        "importPath": "seamless_communication.models.aligner.model",
        "description": "seamless_communication.models.aligner.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.aligner.model",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentFrontend",
        "importPath": "seamless_communication.models.aligner.model",
        "description": "seamless_communication.models.aligner.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.aligner.model",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentModel",
        "importPath": "seamless_communication.models.aligner.model",
        "description": "seamless_communication.models.aligner.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.aligner.model",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentModel",
        "importPath": "seamless_communication.models.aligner.model",
        "description": "seamless_communication.models.aligner.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.aligner.model",
        "documentation": {}
    },
    {
        "label": "load_unity_char_tokenizer",
        "importPath": "seamless_communication.models.unity.char_tokenizer",
        "description": "seamless_communication.models.unity.char_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.char_tokenizer",
        "documentation": {}
    },
    {
        "label": "load_unity_char_tokenizer",
        "importPath": "seamless_communication.models.unity.char_tokenizer",
        "description": "seamless_communication.models.unity.char_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.char_tokenizer",
        "documentation": {}
    },
    {
        "label": "CharTokenizer",
        "importPath": "seamless_communication.models.unity.char_tokenizer",
        "description": "seamless_communication.models.unity.char_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.char_tokenizer",
        "documentation": {}
    },
    {
        "label": "load_unity_char_tokenizer",
        "importPath": "seamless_communication.models.unity.char_tokenizer",
        "description": "seamless_communication.models.unity.char_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.char_tokenizer",
        "documentation": {}
    },
    {
        "label": "CharTokenizer",
        "importPath": "seamless_communication.models.unity.char_tokenizer",
        "description": "seamless_communication.models.unity.char_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.char_tokenizer",
        "documentation": {}
    },
    {
        "label": "load_unity_char_tokenizer",
        "importPath": "seamless_communication.models.unity.char_tokenizer",
        "description": "seamless_communication.models.unity.char_tokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.char_tokenizer",
        "documentation": {}
    },
    {
        "label": "load_unity_unit_tokenizer",
        "importPath": "seamless_communication.models.unity.loader",
        "description": "seamless_communication.models.unity.loader",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.loader",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentConfig",
        "importPath": "seamless_communication.models.aligner.builder",
        "description": "seamless_communication.models.aligner.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "aligner_archs",
        "importPath": "seamless_communication.models.aligner.builder",
        "description": "seamless_communication.models.aligner.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "create_unity2_alignment_model",
        "importPath": "seamless_communication.models.aligner.builder",
        "description": "seamless_communication.models.aligner.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "numpy.typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "ConformerConvolution",
        "importPath": "fairseq2.models.conformer",
        "description": "fairseq2.models.conformer",
        "isExtraImport": true,
        "detail": "fairseq2.models.conformer",
        "documentation": {}
    },
    {
        "label": "ConformerBlock",
        "importPath": "fairseq2.models.conformer",
        "description": "fairseq2.models.conformer",
        "isExtraImport": true,
        "detail": "fairseq2.models.conformer",
        "documentation": {}
    },
    {
        "label": "ConformerBlock",
        "importPath": "fairseq2.models.conformer",
        "description": "fairseq2.models.conformer",
        "isExtraImport": true,
        "detail": "fairseq2.models.conformer",
        "documentation": {}
    },
    {
        "label": "ConformerConvolution",
        "importPath": "fairseq2.models.conformer",
        "description": "fairseq2.models.conformer",
        "isExtraImport": true,
        "detail": "fairseq2.models.conformer",
        "documentation": {}
    },
    {
        "label": "w2vbert_archs",
        "importPath": "fairseq2.models.w2vbert",
        "description": "fairseq2.models.w2vbert",
        "isExtraImport": true,
        "detail": "fairseq2.models.w2vbert",
        "documentation": {}
    },
    {
        "label": "w2vbert_archs",
        "importPath": "fairseq2.models.w2vbert",
        "description": "fairseq2.models.w2vbert",
        "isExtraImport": true,
        "detail": "fairseq2.models.w2vbert",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2Builder",
        "importPath": "fairseq2.models.wav2vec2.builder",
        "description": "fairseq2.models.wav2vec2.builder",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.builder",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2Config",
        "importPath": "fairseq2.models.wav2vec2.builder",
        "description": "fairseq2.models.wav2vec2.builder",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.builder",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2EncoderBuilder",
        "importPath": "fairseq2.models.wav2vec2.builder",
        "description": "fairseq2.models.wav2vec2.builder",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.builder",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2EncoderConfig",
        "importPath": "fairseq2.models.wav2vec2.builder",
        "description": "fairseq2.models.wav2vec2.builder",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.builder",
        "documentation": {}
    },
    {
        "label": "wav2vec2_arch",
        "importPath": "fairseq2.models.wav2vec2.builder",
        "description": "fairseq2.models.wav2vec2.builder",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.builder",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2Config",
        "importPath": "fairseq2.models.wav2vec2.builder",
        "description": "fairseq2.models.wav2vec2.builder",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.builder",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2Model",
        "importPath": "fairseq2.models.wav2vec2.model",
        "description": "fairseq2.models.wav2vec2.model",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.model",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2Model",
        "importPath": "fairseq2.models.wav2vec2.model",
        "description": "fairseq2.models.wav2vec2.model",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.model",
        "documentation": {}
    },
    {
        "label": "load_wav2vec2_config",
        "importPath": "fairseq2.models.wav2vec2.loader",
        "description": "fairseq2.models.wav2vec2.loader",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2.loader",
        "documentation": {}
    },
    {
        "label": "create_conformer_shaw_model",
        "importPath": "seamless_communication.models.conformer_shaw.builder",
        "description": "seamless_communication.models.conformer_shaw.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.conformer_shaw.builder",
        "documentation": {}
    },
    {
        "label": "SinusoidalPositionEncoder",
        "importPath": "fairseq2.nn.position_encoder",
        "description": "fairseq2.nn.position_encoder",
        "isExtraImport": true,
        "detail": "fairseq2.nn.position_encoder",
        "documentation": {}
    },
    {
        "label": "PositionEncoder",
        "importPath": "fairseq2.nn.position_encoder",
        "description": "fairseq2.nn.position_encoder",
        "isExtraImport": true,
        "detail": "fairseq2.nn.position_encoder",
        "documentation": {}
    },
    {
        "label": "SinusoidalPositionEncoder",
        "importPath": "fairseq2.nn.position_encoder",
        "description": "fairseq2.nn.position_encoder",
        "isExtraImport": true,
        "detail": "fairseq2.nn.position_encoder",
        "documentation": {}
    },
    {
        "label": "PositionEncoder",
        "importPath": "fairseq2.nn.position_encoder",
        "description": "fairseq2.nn.position_encoder",
        "isExtraImport": true,
        "detail": "fairseq2.nn.position_encoder",
        "documentation": {}
    },
    {
        "label": "SinusoidalPositionEncoder",
        "importPath": "fairseq2.nn.position_encoder",
        "description": "fairseq2.nn.position_encoder",
        "isExtraImport": true,
        "detail": "fairseq2.nn.position_encoder",
        "documentation": {}
    },
    {
        "label": "EcapaTDNNBuilder",
        "importPath": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "EcapaTDNNConfig",
        "importPath": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "ecapa_tdnn_archs",
        "importPath": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "EcapaTDNNBuilder",
        "importPath": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "EcapaTDNNConfig",
        "importPath": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "ecapa_tdnn_archs",
        "importPath": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "PretsselDecoderFrontend",
        "importPath": "seamless_communication.models.generator.vocoder",
        "description": "seamless_communication.models.generator.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.vocoder",
        "documentation": {}
    },
    {
        "label": "PretsselEncoderFrontend",
        "importPath": "seamless_communication.models.generator.vocoder",
        "description": "seamless_communication.models.generator.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.vocoder",
        "documentation": {}
    },
    {
        "label": "PretsselVocoder",
        "importPath": "seamless_communication.models.generator.vocoder",
        "description": "seamless_communication.models.generator.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.vocoder",
        "documentation": {}
    },
    {
        "label": "PretsselVocoder",
        "importPath": "seamless_communication.models.generator.vocoder",
        "description": "seamless_communication.models.generator.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.vocoder",
        "documentation": {}
    },
    {
        "label": "PretsselVocoder",
        "importPath": "seamless_communication.models.generator.vocoder",
        "description": "seamless_communication.models.generator.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.vocoder",
        "documentation": {}
    },
    {
        "label": "FeedForwardTransformer",
        "importPath": "seamless_communication.models.unity.fft_decoder",
        "description": "seamless_communication.models.unity.fft_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.fft_decoder",
        "documentation": {}
    },
    {
        "label": "FeedForwardTransformer",
        "importPath": "seamless_communication.models.unity.fft_decoder",
        "description": "seamless_communication.models.unity.fft_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.fft_decoder",
        "documentation": {}
    },
    {
        "label": "FeedForwardTransformer",
        "importPath": "seamless_communication.models.unity.fft_decoder",
        "description": "seamless_communication.models.unity.fft_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.fft_decoder",
        "documentation": {}
    },
    {
        "label": "FeedForwardTransformer",
        "importPath": "seamless_communication.models.unity.fft_decoder",
        "description": "seamless_communication.models.unity.fft_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.fft_decoder",
        "documentation": {}
    },
    {
        "label": "Conv1dBlock",
        "importPath": "seamless_communication.models.unity.fft_decoder_layer",
        "description": "seamless_communication.models.unity.fft_decoder_layer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.fft_decoder_layer",
        "documentation": {}
    },
    {
        "label": "FeedForwardTransformerLayer",
        "importPath": "seamless_communication.models.unity.fft_decoder_layer",
        "description": "seamless_communication.models.unity.fft_decoder_layer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.fft_decoder_layer",
        "documentation": {}
    },
    {
        "label": "FeedForwardTransformerLayer",
        "importPath": "seamless_communication.models.unity.fft_decoder_layer",
        "description": "seamless_communication.models.unity.fft_decoder_layer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.fft_decoder_layer",
        "documentation": {}
    },
    {
        "label": "Conv1dBlock",
        "importPath": "seamless_communication.models.unity.fft_decoder_layer",
        "description": "seamless_communication.models.unity.fft_decoder_layer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.fft_decoder_layer",
        "documentation": {}
    },
    {
        "label": "FeedForwardTransformerLayer",
        "importPath": "seamless_communication.models.unity.fft_decoder_layer",
        "description": "seamless_communication.models.unity.fft_decoder_layer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.fft_decoder_layer",
        "documentation": {}
    },
    {
        "label": "VarianceAdaptor",
        "importPath": "seamless_communication.models.unity.length_regulator",
        "description": "seamless_communication.models.unity.length_regulator",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "VariancePredictor",
        "importPath": "seamless_communication.models.unity.length_regulator",
        "description": "seamless_communication.models.unity.length_regulator",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "VarianceAdaptor",
        "importPath": "seamless_communication.models.unity.length_regulator",
        "description": "seamless_communication.models.unity.length_regulator",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "HardUpsampling",
        "importPath": "seamless_communication.models.unity.length_regulator",
        "description": "seamless_communication.models.unity.length_regulator",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "VarianceAdaptor",
        "importPath": "seamless_communication.models.unity.length_regulator",
        "description": "seamless_communication.models.unity.length_regulator",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "VarianceAdaptor",
        "importPath": "seamless_communication.models.unity.length_regulator",
        "description": "seamless_communication.models.unity.length_regulator",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "VariancePredictor",
        "importPath": "seamless_communication.models.unity.length_regulator",
        "description": "seamless_communication.models.unity.length_regulator",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "VariancePredictorConfig",
        "importPath": "seamless_communication.models.unity.t2u_builder",
        "description": "seamless_communication.models.unity.t2u_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "UnitYNART2UBuilder",
        "importPath": "seamless_communication.models.unity.t2u_builder",
        "description": "seamless_communication.models.unity.t2u_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "UnitYT2UBuilder",
        "importPath": "seamless_communication.models.unity.t2u_builder",
        "description": "seamless_communication.models.unity.t2u_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "UnitYT2UConfig",
        "importPath": "seamless_communication.models.unity.t2u_builder",
        "description": "seamless_communication.models.unity.t2u_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "unity_t2u_archs",
        "importPath": "seamless_communication.models.unity.t2u_builder",
        "description": "seamless_communication.models.unity.t2u_builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "ECAPA_TDNN",
        "importPath": "seamless_communication.models.generator.ecapa_tdnn",
        "description": "seamless_communication.models.generator.ecapa_tdnn",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "ECAPA_TDNN",
        "importPath": "seamless_communication.models.generator.ecapa_tdnn",
        "description": "seamless_communication.models.generator.ecapa_tdnn",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "ECAPA_TDNN",
        "importPath": "seamless_communication.models.generator.ecapa_tdnn",
        "description": "seamless_communication.models.generator.ecapa_tdnn",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "VocoderConfig",
        "importPath": "seamless_communication.models.generator.builder",
        "description": "seamless_communication.models.generator.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "create_vocoder_model",
        "importPath": "seamless_communication.models.generator.builder",
        "description": "seamless_communication.models.generator.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "vocoder_archs",
        "importPath": "seamless_communication.models.generator.builder",
        "description": "seamless_communication.models.generator.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "spectral_norm",
        "importPath": "torch.nn.utils",
        "description": "torch.nn.utils",
        "isExtraImport": true,
        "detail": "torch.nn.utils",
        "documentation": {}
    },
    {
        "label": "weight_norm",
        "importPath": "torch.nn.utils",
        "description": "torch.nn.utils",
        "isExtraImport": true,
        "detail": "torch.nn.utils",
        "documentation": {}
    },
    {
        "label": "remove_weight_norm",
        "importPath": "torch.nn.utils.weight_norm",
        "description": "torch.nn.utils.weight_norm",
        "isExtraImport": true,
        "detail": "torch.nn.utils.weight_norm",
        "documentation": {}
    },
    {
        "label": "weight_norm",
        "importPath": "torch.nn.utils.weight_norm",
        "description": "torch.nn.utils.weight_norm",
        "isExtraImport": true,
        "detail": "torch.nn.utils.weight_norm",
        "documentation": {}
    },
    {
        "label": "remove_weight_norm",
        "importPath": "torch.nn.utils.weight_norm",
        "description": "torch.nn.utils.weight_norm",
        "isExtraImport": true,
        "detail": "torch.nn.utils.weight_norm",
        "documentation": {}
    },
    {
        "label": "weight_norm",
        "importPath": "torch.nn.utils.weight_norm",
        "description": "torch.nn.utils.weight_norm",
        "isExtraImport": true,
        "detail": "torch.nn.utils.weight_norm",
        "documentation": {}
    },
    {
        "label": "LRELU_SLOPE",
        "importPath": "seamless_communication.models.vocoder.hifigan",
        "description": "seamless_communication.models.vocoder.hifigan",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "ResBlock",
        "importPath": "seamless_communication.models.vocoder.hifigan",
        "description": "seamless_communication.models.vocoder.hifigan",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "init_weights",
        "importPath": "seamless_communication.models.vocoder.hifigan",
        "description": "seamless_communication.models.vocoder.hifigan",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "seamless_communication.models.vocoder.hifigan",
        "description": "seamless_communication.models.vocoder.hifigan",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "TransformerEmbeddingFrontend",
        "importPath": "fairseq2.models.transformer",
        "description": "fairseq2.models.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.models.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerFrontend",
        "importPath": "fairseq2.models.transformer",
        "description": "fairseq2.models.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.models.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerEmbeddingFrontend",
        "importPath": "fairseq2.models.transformer",
        "description": "fairseq2.models.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.models.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerFrontend",
        "importPath": "fairseq2.models.transformer",
        "description": "fairseq2.models.transformer",
        "isExtraImport": true,
        "detail": "fairseq2.models.transformer",
        "documentation": {}
    },
    {
        "label": "MonotonicDecoderModel",
        "importPath": "seamless_communication.models.monotonic_decoder.model",
        "description": "seamless_communication.models.monotonic_decoder.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.model",
        "documentation": {}
    },
    {
        "label": "MonotonicDecoderModel",
        "importPath": "seamless_communication.models.monotonic_decoder.model",
        "description": "seamless_communication.models.monotonic_decoder.model",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.model",
        "documentation": {}
    },
    {
        "label": "MonotonicTransformerDecoder",
        "importPath": "seamless_communication.models.monotonic_decoder.monotonic_decoder",
        "description": "seamless_communication.models.monotonic_decoder.monotonic_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.monotonic_decoder",
        "documentation": {}
    },
    {
        "label": "MonotonicTransformerDecoder",
        "importPath": "seamless_communication.models.monotonic_decoder.monotonic_decoder",
        "description": "seamless_communication.models.monotonic_decoder.monotonic_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.monotonic_decoder",
        "documentation": {}
    },
    {
        "label": "MonotonicTransformerDecoderLayer",
        "importPath": "seamless_communication.models.monotonic_decoder.monotonic_decoder_layer",
        "description": "seamless_communication.models.monotonic_decoder.monotonic_decoder_layer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.monotonic_decoder_layer",
        "documentation": {}
    },
    {
        "label": "MonotonicTransformerDecoderLayer",
        "importPath": "seamless_communication.models.monotonic_decoder.monotonic_decoder_layer",
        "description": "seamless_communication.models.monotonic_decoder.monotonic_decoder_layer",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.monotonic_decoder_layer",
        "documentation": {}
    },
    {
        "label": "PChooseLayer",
        "importPath": "seamless_communication.models.monotonic_decoder.p_choose",
        "description": "seamless_communication.models.monotonic_decoder.p_choose",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.p_choose",
        "documentation": {}
    },
    {
        "label": "PChooseLayer",
        "importPath": "seamless_communication.models.monotonic_decoder.p_choose",
        "description": "seamless_communication.models.monotonic_decoder.p_choose",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.p_choose",
        "documentation": {}
    },
    {
        "label": "MonotonicDecoderConfig",
        "importPath": "seamless_communication.models.monotonic_decoder.builder",
        "description": "seamless_communication.models.monotonic_decoder.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.builder",
        "documentation": {}
    },
    {
        "label": "create_monotonic_decoder_model",
        "importPath": "seamless_communication.models.monotonic_decoder.builder",
        "description": "seamless_communication.models.monotonic_decoder.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.builder",
        "documentation": {}
    },
    {
        "label": "monotonic_decoder_archs",
        "importPath": "seamless_communication.models.monotonic_decoder.builder",
        "description": "seamless_communication.models.monotonic_decoder.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder.builder",
        "documentation": {}
    },
    {
        "label": "IncrementalStateBag",
        "importPath": "fairseq2.nn.incremental_state",
        "description": "fairseq2.nn.incremental_state",
        "isExtraImport": true,
        "detail": "fairseq2.nn.incremental_state",
        "documentation": {}
    },
    {
        "label": "IncrementalStateBag",
        "importPath": "fairseq2.nn.incremental_state",
        "description": "fairseq2.nn.incremental_state",
        "isExtraImport": true,
        "detail": "fairseq2.nn.incremental_state",
        "documentation": {}
    },
    {
        "label": "IncrementalStateBag",
        "importPath": "fairseq2.nn.incremental_state",
        "description": "fairseq2.nn.incremental_state",
        "isExtraImport": true,
        "detail": "fairseq2.nn.incremental_state",
        "documentation": {}
    },
    {
        "label": "IncrementalStateBag",
        "importPath": "fairseq2.nn.incremental_state",
        "description": "fairseq2.nn.incremental_state",
        "isExtraImport": true,
        "detail": "fairseq2.nn.incremental_state",
        "documentation": {}
    },
    {
        "label": "IncrementalStateBag",
        "importPath": "fairseq2.nn.incremental_state",
        "description": "fairseq2.nn.incremental_state",
        "isExtraImport": true,
        "detail": "fairseq2.nn.incremental_state",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "overrides",
        "description": "overrides",
        "isExtraImport": true,
        "detail": "overrides",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "overrides",
        "description": "overrides",
        "isExtraImport": true,
        "detail": "overrides",
        "documentation": {}
    },
    {
        "label": "final",
        "importPath": "overrides",
        "description": "overrides",
        "isExtraImport": true,
        "detail": "overrides",
        "documentation": {}
    },
    {
        "label": "ModuleList",
        "importPath": "fairseq2.nn.module_list",
        "description": "fairseq2.nn.module_list",
        "isExtraImport": true,
        "detail": "fairseq2.nn.module_list",
        "documentation": {}
    },
    {
        "label": "ModuleList",
        "importPath": "fairseq2.nn.module_list",
        "description": "fairseq2.nn.module_list",
        "isExtraImport": true,
        "detail": "fairseq2.nn.module_list",
        "documentation": {}
    },
    {
        "label": "ModuleList",
        "importPath": "fairseq2.nn.module_list",
        "description": "fairseq2.nn.module_list",
        "isExtraImport": true,
        "detail": "fairseq2.nn.module_list",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "fairseq2.nn.normalization",
        "description": "fairseq2.nn.normalization",
        "isExtraImport": true,
        "detail": "fairseq2.nn.normalization",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "fairseq2.nn.normalization",
        "description": "fairseq2.nn.normalization",
        "isExtraImport": true,
        "detail": "fairseq2.nn.normalization",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "fairseq2.nn.normalization",
        "description": "fairseq2.nn.normalization",
        "isExtraImport": true,
        "detail": "fairseq2.nn.normalization",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "fairseq2.nn.normalization",
        "description": "fairseq2.nn.normalization",
        "isExtraImport": true,
        "detail": "fairseq2.nn.normalization",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "fairseq2.nn.normalization",
        "description": "fairseq2.nn.normalization",
        "isExtraImport": true,
        "detail": "fairseq2.nn.normalization",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "fairseq2.nn.normalization",
        "description": "fairseq2.nn.normalization",
        "isExtraImport": true,
        "detail": "fairseq2.nn.normalization",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "fairseq2.nn.normalization",
        "description": "fairseq2.nn.normalization",
        "isExtraImport": true,
        "detail": "fairseq2.nn.normalization",
        "documentation": {}
    },
    {
        "label": "ECAPA_TDNN",
        "importPath": "seamless_communication.models.pretssel.ecapa_tdnn",
        "description": "seamless_communication.models.pretssel.ecapa_tdnn",
        "isExtraImport": true,
        "detail": "seamless_communication.models.pretssel.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2Model",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "load_wav2vec2_model",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2Config",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2EncoderConfig",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2Frontend",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2Model",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "wav2vec2_arch",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2EncoderBuilder",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2EncoderConfig",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2EncoderConfig",
        "importPath": "fairseq2.models.wav2vec2",
        "description": "fairseq2.models.wav2vec2",
        "isExtraImport": true,
        "detail": "fairseq2.models.wav2vec2",
        "documentation": {}
    },
    {
        "label": "KmeansModel",
        "importPath": "seamless_communication.models.unit_extractor.kmeans",
        "description": "seamless_communication.models.unit_extractor.kmeans",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unit_extractor.kmeans",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2LayerOutputModel",
        "importPath": "seamless_communication.models.unit_extractor.wav2vec2_layer_output",
        "description": "seamless_communication.models.unit_extractor.wav2vec2_layer_output",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unit_extractor.wav2vec2_layer_output",
        "documentation": {}
    },
    {
        "label": "UnitYConformerAdaptorLayer",
        "importPath": "seamless_communication.models.unity.adaptor_block",
        "description": "seamless_communication.models.unity.adaptor_block",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.adaptor_block",
        "documentation": {}
    },
    {
        "label": "UnitYEncoderAdaptor",
        "importPath": "seamless_communication.models.unity.adaptor_block",
        "description": "seamless_communication.models.unity.adaptor_block",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.adaptor_block",
        "documentation": {}
    },
    {
        "label": "UnitYTransformerAdaptorLayer",
        "importPath": "seamless_communication.models.unity.adaptor_block",
        "description": "seamless_communication.models.unity.adaptor_block",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.adaptor_block",
        "documentation": {}
    },
    {
        "label": "ConformerShawEncoderBuilder",
        "importPath": "seamless_communication.models.conformer_shaw",
        "description": "seamless_communication.models.conformer_shaw",
        "isExtraImport": true,
        "detail": "seamless_communication.models.conformer_shaw",
        "documentation": {}
    },
    {
        "label": "ConformerShawEncoderConfig",
        "importPath": "seamless_communication.models.conformer_shaw",
        "description": "seamless_communication.models.conformer_shaw",
        "isExtraImport": true,
        "detail": "seamless_communication.models.conformer_shaw",
        "documentation": {}
    },
    {
        "label": "conformer_shaw_archs",
        "importPath": "seamless_communication.models.conformer_shaw",
        "description": "seamless_communication.models.conformer_shaw",
        "isExtraImport": true,
        "detail": "seamless_communication.models.conformer_shaw",
        "documentation": {}
    },
    {
        "label": "load_conformer_shaw_model",
        "importPath": "seamless_communication.models.conformer_shaw",
        "description": "seamless_communication.models.conformer_shaw",
        "isExtraImport": true,
        "detail": "seamless_communication.models.conformer_shaw",
        "documentation": {}
    },
    {
        "label": "FiLM",
        "importPath": "seamless_communication.models.unity.film",
        "description": "seamless_communication.models.unity.film",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.film",
        "documentation": {}
    },
    {
        "label": "FiLM",
        "importPath": "seamless_communication.models.unity.film",
        "description": "seamless_communication.models.unity.film",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.film",
        "documentation": {}
    },
    {
        "label": "UnitYConfig",
        "importPath": "seamless_communication.models.unity.builder",
        "description": "seamless_communication.models.unity.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.builder",
        "documentation": {}
    },
    {
        "label": "create_unity_model",
        "importPath": "seamless_communication.models.unity.builder",
        "description": "seamless_communication.models.unity.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.builder",
        "documentation": {}
    },
    {
        "label": "unity_archs",
        "importPath": "seamless_communication.models.unity.builder",
        "description": "seamless_communication.models.unity.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.builder",
        "documentation": {}
    },
    {
        "label": "EncoderDecoderModel",
        "importPath": "fairseq2.models.encoder_decoder",
        "description": "fairseq2.models.encoder_decoder",
        "isExtraImport": true,
        "detail": "fairseq2.models.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "NARDecoderFrontend",
        "importPath": "seamless_communication.models.unity.nar_decoder_frontend",
        "description": "seamless_communication.models.unity.nar_decoder_frontend",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.nar_decoder_frontend",
        "documentation": {}
    },
    {
        "label": "NARDecoderFrontend",
        "importPath": "seamless_communication.models.unity.nar_decoder_frontend",
        "description": "seamless_communication.models.unity.nar_decoder_frontend",
        "isExtraImport": true,
        "detail": "seamless_communication.models.unity.nar_decoder_frontend",
        "documentation": {}
    },
    {
        "label": "CodeGenerator",
        "importPath": "seamless_communication.models.vocoder.codehifigan",
        "description": "seamless_communication.models.vocoder.codehifigan",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.codehifigan",
        "documentation": {}
    },
    {
        "label": "CodeGenerator",
        "importPath": "seamless_communication.models.vocoder.codehifigan",
        "description": "seamless_communication.models.vocoder.codehifigan",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.codehifigan",
        "documentation": {}
    },
    {
        "label": "Vocoder",
        "importPath": "seamless_communication.models.vocoder.vocoder",
        "description": "seamless_communication.models.vocoder.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.vocoder",
        "documentation": {}
    },
    {
        "label": "Vocoder",
        "importPath": "seamless_communication.models.vocoder.vocoder",
        "description": "seamless_communication.models.vocoder.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.vocoder",
        "documentation": {}
    },
    {
        "label": "Vocoder",
        "importPath": "seamless_communication.models.vocoder.vocoder",
        "description": "seamless_communication.models.vocoder.vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.vocoder",
        "documentation": {}
    },
    {
        "label": "VocoderConfig",
        "importPath": "seamless_communication.models.vocoder.builder",
        "description": "seamless_communication.models.vocoder.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.builder",
        "documentation": {}
    },
    {
        "label": "create_vocoder_model",
        "importPath": "seamless_communication.models.vocoder.builder",
        "description": "seamless_communication.models.vocoder.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.builder",
        "documentation": {}
    },
    {
        "label": "vocoder_archs",
        "importPath": "seamless_communication.models.vocoder.builder",
        "description": "seamless_communication.models.vocoder.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.builder",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "EmptySegment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "SpeechSegment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "SpeechSegment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "TextSegment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "TextSegment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "SpeechSegment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "SpeechSegment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "EmptySegment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "SpeechSegment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "simuleval.data.segments",
        "description": "simuleval.data.segments",
        "isExtraImport": true,
        "detail": "simuleval.data.segments",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "simuleval.agents.states",
        "description": "simuleval.agents.states",
        "isExtraImport": true,
        "detail": "simuleval.agents.states",
        "documentation": {}
    },
    {
        "label": "TextToTextAgent",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "TextToSpeechAgent",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "SpeechToSpeechAgent",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "SpeechToSpeechAgent",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "GenericAgent",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "GenericAgent",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "TextToSpeechAgent",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "TextToSpeechAgent",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "SpeechToSpeechAgent",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "AgentPipeline",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "TreeAgentPipeline",
        "importPath": "simuleval.agents",
        "description": "simuleval.agents",
        "isExtraImport": true,
        "detail": "simuleval.agents",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "ReadAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "WriteAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "ReadAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "WriteAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "ReadAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "WriteAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "ReadAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "WriteAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "ReadAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "WriteAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "ReadAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "WriteAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "ReadAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "WriteAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "ReadAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "WriteAction",
        "importPath": "simuleval.agents.actions",
        "description": "simuleval.agents.actions",
        "isExtraImport": true,
        "detail": "simuleval.agents.actions",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "NoUpdateTargetMixin",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "NoUpdateTargetMixin",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "NoUpdateTargetMixin",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "EarlyStoppingMixin",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "EarlyStoppingMixin",
        "importPath": "seamless_communication.streaming.agents.common",
        "description": "seamless_communication.streaming.agents.common",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "UnitYTextDecoderOutput",
        "importPath": "seamless_communication.streaming.agents.online_text_decoder",
        "description": "seamless_communication.streaming.agents.online_text_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "UnitYTextDecoderOutput",
        "importPath": "seamless_communication.streaming.agents.online_text_decoder",
        "description": "seamless_communication.streaming.agents.online_text_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "UnitYMMATextDecoderAgent",
        "importPath": "seamless_communication.streaming.agents.online_text_decoder",
        "description": "seamless_communication.streaming.agents.online_text_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "UnitYMMATextDecoderAgent",
        "importPath": "seamless_communication.streaming.agents.online_text_decoder",
        "description": "seamless_communication.streaming.agents.online_text_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "MMASpeechToTextDecoderAgent",
        "importPath": "seamless_communication.streaming.agents.online_text_decoder",
        "description": "seamless_communication.streaming.agents.online_text_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "PretsselVocoderAgent",
        "importPath": "seamless_communication.streaming.agents.pretssel_vocoder",
        "description": "seamless_communication.streaming.agents.pretssel_vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.pretssel_vocoder",
        "documentation": {}
    },
    {
        "label": "PretsselVocoderAgent",
        "importPath": "seamless_communication.streaming.agents.pretssel_vocoder",
        "description": "seamless_communication.streaming.agents.pretssel_vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.pretssel_vocoder",
        "documentation": {}
    },
    {
        "label": "VocoderAgent",
        "importPath": "seamless_communication.streaming.agents.online_vocoder",
        "description": "seamless_communication.streaming.agents.online_vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_vocoder",
        "documentation": {}
    },
    {
        "label": "VocoderAgent",
        "importPath": "seamless_communication.streaming.agents.online_vocoder",
        "description": "seamless_communication.streaming.agents.online_vocoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_vocoder",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data.data_pipeline",
        "description": "fairseq2.data.data_pipeline",
        "isExtraImport": true,
        "detail": "fairseq2.data.data_pipeline",
        "documentation": {}
    },
    {
        "label": "Collater",
        "importPath": "fairseq2.data.data_pipeline",
        "description": "fairseq2.data.data_pipeline",
        "isExtraImport": true,
        "detail": "fairseq2.data.data_pipeline",
        "documentation": {}
    },
    {
        "label": "DataPipeline",
        "importPath": "fairseq2.data.data_pipeline",
        "description": "fairseq2.data.data_pipeline",
        "isExtraImport": true,
        "detail": "fairseq2.data.data_pipeline",
        "documentation": {}
    },
    {
        "label": "FileMapper",
        "importPath": "fairseq2.data.data_pipeline",
        "description": "fairseq2.data.data_pipeline",
        "isExtraImport": true,
        "detail": "fairseq2.data.data_pipeline",
        "documentation": {}
    },
    {
        "label": "MonotonicDecoderConfig",
        "importPath": "seamless_communication.models.monotonic_decoder",
        "description": "seamless_communication.models.monotonic_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder",
        "documentation": {}
    },
    {
        "label": "MonotonicDecoderModel",
        "importPath": "seamless_communication.models.monotonic_decoder",
        "description": "seamless_communication.models.monotonic_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder",
        "documentation": {}
    },
    {
        "label": "load_monotonic_decoder_config",
        "importPath": "seamless_communication.models.monotonic_decoder",
        "description": "seamless_communication.models.monotonic_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder",
        "documentation": {}
    },
    {
        "label": "load_monotonic_decoder_model",
        "importPath": "seamless_communication.models.monotonic_decoder",
        "description": "seamless_communication.models.monotonic_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.models.monotonic_decoder",
        "documentation": {}
    },
    {
        "label": "load_vocoder_model",
        "importPath": "seamless_communication.models.vocoder.loader",
        "description": "seamless_communication.models.vocoder.loader",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.loader",
        "documentation": {}
    },
    {
        "label": "load_vocoder_model",
        "importPath": "seamless_communication.models.vocoder.loader",
        "description": "seamless_communication.models.vocoder.loader",
        "isExtraImport": true,
        "detail": "seamless_communication.models.vocoder.loader",
        "documentation": {}
    },
    {
        "label": "UnitYDetokenizerAgent",
        "importPath": "seamless_communication.streaming.agents.detokenizer",
        "description": "seamless_communication.streaming.agents.detokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.detokenizer",
        "documentation": {}
    },
    {
        "label": "UnitYDetokenizerAgent",
        "importPath": "seamless_communication.streaming.agents.detokenizer",
        "description": "seamless_communication.streaming.agents.detokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.detokenizer",
        "documentation": {}
    },
    {
        "label": "DetokenizerAgent",
        "importPath": "seamless_communication.streaming.agents.detokenizer",
        "description": "seamless_communication.streaming.agents.detokenizer",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.detokenizer",
        "documentation": {}
    },
    {
        "label": "OfflineWav2VecBertEncoderAgent",
        "importPath": "seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "description": "seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "documentation": {}
    },
    {
        "label": "OfflineWav2VecBertEncoderAgent",
        "importPath": "seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "description": "seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "documentation": {}
    },
    {
        "label": "OfflineWav2VecBertEncoderAgent",
        "importPath": "seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "description": "seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "documentation": {}
    },
    {
        "label": "OnlineFeatureExtractorAgent",
        "importPath": "seamless_communication.streaming.agents.online_feature_extractor",
        "description": "seamless_communication.streaming.agents.online_feature_extractor",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_feature_extractor",
        "documentation": {}
    },
    {
        "label": "OnlineFeatureExtractorAgent",
        "importPath": "seamless_communication.streaming.agents.online_feature_extractor",
        "description": "seamless_communication.streaming.agents.online_feature_extractor",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_feature_extractor",
        "documentation": {}
    },
    {
        "label": "OnlineFeatureExtractorAgent",
        "importPath": "seamless_communication.streaming.agents.online_feature_extractor",
        "description": "seamless_communication.streaming.agents.online_feature_extractor",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_feature_extractor",
        "documentation": {}
    },
    {
        "label": "NARUnitYUnitDecoderAgent",
        "importPath": "seamless_communication.streaming.agents.online_unit_decoder",
        "description": "seamless_communication.streaming.agents.online_unit_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_unit_decoder",
        "documentation": {}
    },
    {
        "label": "NARUnitYUnitDecoderAgent",
        "importPath": "seamless_communication.streaming.agents.online_unit_decoder",
        "description": "seamless_communication.streaming.agents.online_unit_decoder",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.online_unit_decoder",
        "documentation": {}
    },
    {
        "label": "DualVocoderAgent",
        "importPath": "seamless_communication.streaming.agents.dual_vocoder_agent",
        "description": "seamless_communication.streaming.agents.dual_vocoder_agent",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.dual_vocoder_agent",
        "documentation": {}
    },
    {
        "label": "SileroVADAgent",
        "importPath": "seamless_communication.streaming.agents.silero_vad",
        "description": "seamless_communication.streaming.agents.silero_vad",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.silero_vad",
        "documentation": {}
    },
    {
        "label": "SileroVADAgent",
        "importPath": "seamless_communication.streaming.agents.silero_vad",
        "description": "seamless_communication.streaming.agents.silero_vad",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.silero_vad",
        "documentation": {}
    },
    {
        "label": "SileroVADAgent",
        "importPath": "seamless_communication.streaming.agents.silero_vad",
        "description": "seamless_communication.streaming.agents.silero_vad",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.silero_vad",
        "documentation": {}
    },
    {
        "label": "UnitYAgentPipeline",
        "importPath": "seamless_communication.streaming.agents.unity_pipeline",
        "description": "seamless_communication.streaming.agents.unity_pipeline",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "UnitYAgentTreePipeline",
        "importPath": "seamless_communication.streaming.agents.unity_pipeline",
        "description": "seamless_communication.streaming.agents.unity_pipeline",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "UnitYAgentPipeline",
        "importPath": "seamless_communication.streaming.agents.unity_pipeline",
        "description": "seamless_communication.streaming.agents.unity_pipeline",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "UnitYAgentTreePipeline",
        "importPath": "seamless_communication.streaming.agents.unity_pipeline",
        "description": "seamless_communication.streaming.agents.unity_pipeline",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "UnitYAgentPipeline",
        "importPath": "seamless_communication.streaming.agents.unity_pipeline",
        "description": "seamless_communication.streaming.agents.unity_pipeline",
        "isExtraImport": true,
        "detail": "seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "soundfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "soundfile",
        "description": "soundfile",
        "detail": "soundfile",
        "documentation": {}
    },
    {
        "label": "GenericAgent",
        "importPath": "simuleval.agents.agent",
        "description": "simuleval.agents.agent",
        "isExtraImport": true,
        "detail": "simuleval.agents.agent",
        "documentation": {}
    },
    {
        "label": "StrSplitter",
        "importPath": "fairseq2.data.text.converters",
        "description": "fairseq2.data.text.converters",
        "isExtraImport": true,
        "detail": "fairseq2.data.text.converters",
        "documentation": {}
    },
    {
        "label": "read_text",
        "importPath": "fairseq2.data.text.text_reader",
        "description": "fairseq2.data.text.text_reader",
        "isExtraImport": true,
        "detail": "fairseq2.data.text.text_reader",
        "documentation": {}
    },
    {
        "label": "register_dataloader",
        "importPath": "simuleval.data.dataloader",
        "description": "simuleval.data.dataloader",
        "isExtraImport": true,
        "detail": "simuleval.data.dataloader",
        "documentation": {}
    },
    {
        "label": "IterableDataloader",
        "importPath": "simuleval.data.dataloader.dataloader",
        "description": "simuleval.data.dataloader.dataloader",
        "isExtraImport": true,
        "detail": "simuleval.data.dataloader.dataloader",
        "documentation": {}
    },
    {
        "label": "SpeechToTextDataloader",
        "importPath": "simuleval.data.dataloader.s2t_dataloader",
        "description": "simuleval.data.dataloader.s2t_dataloader",
        "isExtraImport": true,
        "detail": "simuleval.data.dataloader.s2t_dataloader",
        "documentation": {}
    },
    {
        "label": "MutoxClassifier",
        "importPath": "seamless_communication.toxicity.mutox.classifier",
        "description": "seamless_communication.toxicity.mutox.classifier",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "MutoxConfig",
        "importPath": "seamless_communication.toxicity.mutox.classifier",
        "description": "seamless_communication.toxicity.mutox.classifier",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "MutoxClassifier",
        "importPath": "seamless_communication.toxicity.mutox.classifier",
        "description": "seamless_communication.toxicity.mutox.classifier",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "MutoxConfig",
        "importPath": "seamless_communication.toxicity.mutox.classifier",
        "description": "seamless_communication.toxicity.mutox.classifier",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "mutox_archs",
        "importPath": "seamless_communication.toxicity.mutox.classifier",
        "description": "seamless_communication.toxicity.mutox.classifier",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "MutoxClassifier",
        "importPath": "seamless_communication.toxicity.mutox.classifier",
        "description": "seamless_communication.toxicity.mutox.classifier",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "MutoxClassifier",
        "importPath": "seamless_communication.toxicity.mutox.classifier",
        "description": "seamless_communication.toxicity.mutox.classifier",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "create_mutox_model",
        "importPath": "seamless_communication.toxicity.mutox.builder",
        "description": "seamless_communication.toxicity.mutox.builder",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.mutox.builder",
        "documentation": {}
    },
    {
        "label": "load_sonar_speech_model",
        "importPath": "sonar.models.sonar_speech.loader",
        "description": "sonar.models.sonar_speech.loader",
        "isExtraImport": true,
        "detail": "sonar.models.sonar_speech.loader",
        "documentation": {}
    },
    {
        "label": "SonarEncoderModel",
        "importPath": "sonar.models.encoder_model",
        "description": "sonar.models.encoder_model",
        "isExtraImport": true,
        "detail": "sonar.models.encoder_model",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "ETOXBadWordChecker",
        "importPath": "seamless_communication.toxicity.etox_bad_word_checker",
        "description": "seamless_communication.toxicity.etox_bad_word_checker",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.etox_bad_word_checker",
        "documentation": {}
    },
    {
        "label": "ETOXBadWordChecker",
        "importPath": "seamless_communication.toxicity.etox_bad_word_checker",
        "description": "seamless_communication.toxicity.etox_bad_word_checker",
        "isExtraImport": true,
        "detail": "seamless_communication.toxicity.etox_bad_word_checker",
        "documentation": {}
    },
    {
        "label": "TextTokenizer",
        "importPath": "fairseq2.data.text.text_tokenizer",
        "description": "fairseq2.data.text.text_tokenizer",
        "isExtraImport": true,
        "detail": "fairseq2.data.text.text_tokenizer",
        "documentation": {}
    },
    {
        "label": "tests.common",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tests.common",
        "description": "tests.common",
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "device",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "get_default_dtype",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "device",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "get_default_dtype",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "convert_to_collated_fbank",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "get_default_dtype",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "device",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "assert_equal",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "device",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "get_default_dtype",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "assert_equal",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "device",
        "importPath": "tests.common",
        "description": "tests.common",
        "isExtraImport": true,
        "detail": "tests.common",
        "documentation": {}
    },
    {
        "label": "AlignmentExtractor",
        "importPath": "seamless_communication.models.aligner.alignment_extractor",
        "description": "seamless_communication.models.aligner.alignment_extractor",
        "isExtraImport": true,
        "detail": "seamless_communication.models.aligner.alignment_extractor",
        "documentation": {}
    },
    {
        "label": "urlretrieve",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_from_directory",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "AudioOfficial",
        "importPath": "main",
        "description": "main",
        "isExtraImport": true,
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "AudioOfficial",
        "importPath": "main",
        "description": "main",
        "isExtraImport": true,
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "clearFolderContent",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "clearFolderContent",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "ASR_TARGET_LANGUAGE_NAMES",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_NAME_TO_CODE",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "crop_audio",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "preprocess_audio",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "cross_origin",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "cross_origin",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "Swagger",
        "importPath": "flasgger",
        "description": "flasgger",
        "isExtraImport": true,
        "detail": "flasgger",
        "documentation": {}
    },
    {
        "label": "Swagger",
        "importPath": "flasgger",
        "description": "flasgger",
        "isExtraImport": true,
        "detail": "flasgger",
        "documentation": {}
    },
    {
        "label": "serve",
        "importPath": "waitress",
        "description": "waitress",
        "isExtraImport": true,
        "detail": "waitress",
        "documentation": {}
    },
    {
        "label": "serve",
        "importPath": "waitress",
        "description": "waitress",
        "isExtraImport": true,
        "detail": "waitress",
        "documentation": {}
    },
    {
        "label": "pipeline",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "WhisperForConditionalGeneration",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "WhisperFeatureExtractor",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "WhisperTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModelForSpeechSeq2Seq",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoProcessor",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "pipeline",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "pipeline",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "PeftModel",
        "importPath": "peft",
        "description": "peft",
        "isExtraImport": true,
        "detail": "peft",
        "documentation": {}
    },
    {
        "label": "PeftConfig",
        "importPath": "peft",
        "description": "peft",
        "isExtraImport": true,
        "detail": "peft",
        "documentation": {}
    },
    {
        "label": "WhisperModel",
        "importPath": "faster_whisper",
        "description": "faster_whisper",
        "isExtraImport": true,
        "detail": "faster_whisper",
        "documentation": {}
    },
    {
        "label": "WhisperModel",
        "importPath": "faster_whisper",
        "description": "faster_whisper",
        "isExtraImport": true,
        "detail": "faster_whisper",
        "documentation": {}
    },
    {
        "label": "AudioSegment",
        "importPath": "pydub",
        "description": "pydub",
        "isExtraImport": true,
        "detail": "pydub",
        "documentation": {}
    },
    {
        "label": "AudioSegment",
        "importPath": "pydub",
        "description": "pydub",
        "isExtraImport": true,
        "detail": "pydub",
        "documentation": {}
    },
    {
        "label": "normalize_fbank",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "def normalize_fbank(data: WaveformToFbankOutput) -> WaveformToFbankOutput:\n    fbank = data[\"fbank\"]\n    std, mean = torch.std_mean(fbank, dim=0)\n    data[\"fbank\"] = fbank.subtract(mean).divide(std)\n    data[\"gcmvn_fbank\"] = fbank.subtract(gcmvn_mean).divide(gcmvn_std)\n    return data\ncollate = Collater(pad_value=0, pad_to_multiple=1)\nAUDIO_SAMPLE_RATE = 16000\nMAX_INPUT_AUDIO_LENGTH = 10  # in seconds\ndef remove_prosody_tokens_from_text(text):",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "remove_prosody_tokens_from_text",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "def remove_prosody_tokens_from_text(text):\n    # filter out prosody tokens, there is only emphasis '*', and pause '='\n    text = text.replace(\"*\", \"\").replace(\"=\", \"\")\n    text = \" \".join(text.split())\n    return text\ndef preprocess_audio(input_audio_path: str) -> None:\n    arr, org_sr = torchaudio.load(input_audio_path)\n    new_arr = torchaudio.functional.resample(arr, orig_freq=org_sr, new_freq=AUDIO_SAMPLE_RATE)\n    max_length = int(MAX_INPUT_AUDIO_LENGTH * AUDIO_SAMPLE_RATE)\n    if new_arr.shape[1] > max_length:",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "preprocess_audio",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "def preprocess_audio(input_audio_path: str) -> None:\n    arr, org_sr = torchaudio.load(input_audio_path)\n    new_arr = torchaudio.functional.resample(arr, orig_freq=org_sr, new_freq=AUDIO_SAMPLE_RATE)\n    max_length = int(MAX_INPUT_AUDIO_LENGTH * AUDIO_SAMPLE_RATE)\n    if new_arr.shape[1] > max_length:\n        new_arr = new_arr[:, :max_length]\n        gr.Warning(f\"Input audio is too long. Only the first {MAX_INPUT_AUDIO_LENGTH} seconds is used.\")\n    torchaudio.save(input_audio_path, new_arr, sample_rate=AUDIO_SAMPLE_RATE)\ndef run(\n    input_audio_path: str,",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "def run(\n    input_audio_path: str,\n    source_language: str,\n    target_language: str,\n) -> Tuple[str, str]:\n    target_language_code = LANGUAGE_NAME_TO_CODE[target_language]\n    source_language_code = LANGUAGE_NAME_TO_CODE[source_language]\n    preprocess_audio(input_audio_path)\n    with pathlib.Path(input_audio_path).open(\"rb\") as fb:\n        block = MemoryBlock(fb.read())",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "DESCRIPTION",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "DESCRIPTION = \"\"\"\\\n# Seamless Expressive\n[SeamlessExpressive](https://github.com/facebookresearch/seamless_communication) is a speech-to-speech translation model that captures certain underexplored aspects of prosody such as speech rate and pauses, while preserving the style of one's voice and high content translation quality.\n\"\"\"\nCACHE_EXAMPLES = os.getenv(\"CACHE_EXAMPLES\") == \"1\" and torch.cuda.is_available()\nCHECKPOINTS_PATH = pathlib.Path(os.getenv(\"CHECKPOINTS_PATH\", \"/home/user/app/models\"))\nif not CHECKPOINTS_PATH.exists():\n    snapshot_download(repo_id=\"facebook/seamless-expressive\", repo_type=\"model\", local_dir=CHECKPOINTS_PATH)\n    snapshot_download(repo_id=\"facebook/seamless-m4t-v2-large\", repo_type=\"model\", local_dir=CHECKPOINTS_PATH)\n# Ensure that we do not have any other environment resolvers and always return",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "CACHE_EXAMPLES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "CACHE_EXAMPLES = os.getenv(\"CACHE_EXAMPLES\") == \"1\" and torch.cuda.is_available()\nCHECKPOINTS_PATH = pathlib.Path(os.getenv(\"CHECKPOINTS_PATH\", \"/home/user/app/models\"))\nif not CHECKPOINTS_PATH.exists():\n    snapshot_download(repo_id=\"facebook/seamless-expressive\", repo_type=\"model\", local_dir=CHECKPOINTS_PATH)\n    snapshot_download(repo_id=\"facebook/seamless-m4t-v2-large\", repo_type=\"model\", local_dir=CHECKPOINTS_PATH)\n# Ensure that we do not have any other environment resolvers and always return\n# \"demo\" for demo purposes.\nasset_store.env_resolvers.clear()\nasset_store.env_resolvers.append(lambda: \"demo\")\n# Construct an `InProcAssetMetadataProvider` with environment-specific metadata",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "CHECKPOINTS_PATH",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "CHECKPOINTS_PATH = pathlib.Path(os.getenv(\"CHECKPOINTS_PATH\", \"/home/user/app/models\"))\nif not CHECKPOINTS_PATH.exists():\n    snapshot_download(repo_id=\"facebook/seamless-expressive\", repo_type=\"model\", local_dir=CHECKPOINTS_PATH)\n    snapshot_download(repo_id=\"facebook/seamless-m4t-v2-large\", repo_type=\"model\", local_dir=CHECKPOINTS_PATH)\n# Ensure that we do not have any other environment resolvers and always return\n# \"demo\" for demo purposes.\nasset_store.env_resolvers.clear()\nasset_store.env_resolvers.append(lambda: \"demo\")\n# Construct an `InProcAssetMetadataProvider` with environment-specific metadata\n# that just overrides the regular metadata for \"demo\" environment. Note the \"@demo\" suffix.",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "demo_metadata",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "demo_metadata = [\n    {\n        \"name\": \"seamless_expressivity@demo\",\n        \"checkpoint\": f\"file://{CHECKPOINTS_PATH}/m2m_expressive_unity.pt\",\n        \"char_tokenizer\": f\"file://{CHECKPOINTS_PATH}/spm_char_lang38_tc.model\",\n    },\n    {\n        \"name\": \"vocoder_pretssel@demo\",\n        \"checkpoint\": f\"file://{CHECKPOINTS_PATH}/pretssel_melhifigan_wm-final.pt\",\n    },",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_NAME_TO_CODE",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "LANGUAGE_NAME_TO_CODE = {v: k for k, v in LANGUAGE_CODE_TO_NAME.items()}\nif torch.cuda.is_available():\n    device = torch.device(\"cuda:0\")\n    dtype = torch.float16\nelse:\n    device = torch.device(\"cpu\")\n    dtype = torch.float32\nMODEL_NAME = \"seamless_expressivity\"\nVOCODER_NAME = \"vocoder_pretssel\"\n# used for ASR for toxicity",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "MODEL_NAME",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "MODEL_NAME = \"seamless_expressivity\"\nVOCODER_NAME = \"vocoder_pretssel\"\n# used for ASR for toxicity\nm4t_translator = Translator(\n    model_name_or_card=\"seamlessM4T_v2_large\",\n    vocoder_name_or_card=None,\n    device=device,\n    dtype=dtype,\n)\nunit_tokenizer = load_unity_unit_tokenizer(MODEL_NAME)",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "VOCODER_NAME",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "VOCODER_NAME = \"vocoder_pretssel\"\n# used for ASR for toxicity\nm4t_translator = Translator(\n    model_name_or_card=\"seamlessM4T_v2_large\",\n    vocoder_name_or_card=None,\n    device=device,\n    dtype=dtype,\n)\nunit_tokenizer = load_unity_unit_tokenizer(MODEL_NAME)\n_gcmvn_mean, _gcmvn_std = load_gcmvn_stats(VOCODER_NAME)",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "m4t_translator",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "m4t_translator = Translator(\n    model_name_or_card=\"seamlessM4T_v2_large\",\n    vocoder_name_or_card=None,\n    device=device,\n    dtype=dtype,\n)\nunit_tokenizer = load_unity_unit_tokenizer(MODEL_NAME)\n_gcmvn_mean, _gcmvn_std = load_gcmvn_stats(VOCODER_NAME)\ngcmvn_mean = torch.tensor(_gcmvn_mean, device=device, dtype=dtype)\ngcmvn_std = torch.tensor(_gcmvn_std, device=device, dtype=dtype)",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "unit_tokenizer",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "unit_tokenizer = load_unity_unit_tokenizer(MODEL_NAME)\n_gcmvn_mean, _gcmvn_std = load_gcmvn_stats(VOCODER_NAME)\ngcmvn_mean = torch.tensor(_gcmvn_mean, device=device, dtype=dtype)\ngcmvn_std = torch.tensor(_gcmvn_std, device=device, dtype=dtype)\ntranslator = Translator(\n    MODEL_NAME,\n    vocoder_name_or_card=None,\n    device=device,\n    dtype=dtype,\n    apply_mintox=False,",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "gcmvn_mean",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "gcmvn_mean = torch.tensor(_gcmvn_mean, device=device, dtype=dtype)\ngcmvn_std = torch.tensor(_gcmvn_std, device=device, dtype=dtype)\ntranslator = Translator(\n    MODEL_NAME,\n    vocoder_name_or_card=None,\n    device=device,\n    dtype=dtype,\n    apply_mintox=False,\n)\ntext_generation_opts = SequenceGeneratorOptions(",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "gcmvn_std",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "gcmvn_std = torch.tensor(_gcmvn_std, device=device, dtype=dtype)\ntranslator = Translator(\n    MODEL_NAME,\n    vocoder_name_or_card=None,\n    device=device,\n    dtype=dtype,\n    apply_mintox=False,\n)\ntext_generation_opts = SequenceGeneratorOptions(\n    beam_size=5,",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "translator",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "translator = Translator(\n    MODEL_NAME,\n    vocoder_name_or_card=None,\n    device=device,\n    dtype=dtype,\n    apply_mintox=False,\n)\ntext_generation_opts = SequenceGeneratorOptions(\n    beam_size=5,\n    unk_penalty=torch.inf,",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "text_generation_opts",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "text_generation_opts = SequenceGeneratorOptions(\n    beam_size=5,\n    unk_penalty=torch.inf,\n    soft_max_seq_len=(0, 200),\n    step_processor=NGramRepeatBlockProcessor(\n        ngram_size=10,\n    ),\n)\nm4t_text_generation_opts = SequenceGeneratorOptions(\n    beam_size=5,",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "m4t_text_generation_opts",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "m4t_text_generation_opts = SequenceGeneratorOptions(\n    beam_size=5,\n    unk_penalty=torch.inf,\n    soft_max_seq_len=(1, 200),\n    step_processor=NGramRepeatBlockProcessor(\n        ngram_size=10,\n    ),\n)\npretssel_generator = PretsselGenerator(\n    VOCODER_NAME,",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "pretssel_generator",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "pretssel_generator = PretsselGenerator(\n    VOCODER_NAME,\n    vocab_info=unit_tokenizer.vocab_info,\n    device=device,\n    dtype=dtype,\n)\ndecode_audio = AudioDecoder(dtype=torch.float32, device=device)\nconvert_to_fbank = WaveformToFbankConverter(\n    num_mel_bins=80,\n    waveform_scale=2**15,",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "decode_audio",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "decode_audio = AudioDecoder(dtype=torch.float32, device=device)\nconvert_to_fbank = WaveformToFbankConverter(\n    num_mel_bins=80,\n    waveform_scale=2**15,\n    channel_last=True,\n    standardize=False,\n    device=device,\n    dtype=dtype,\n)\ndef normalize_fbank(data: WaveformToFbankOutput) -> WaveformToFbankOutput:",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "convert_to_fbank",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "convert_to_fbank = WaveformToFbankConverter(\n    num_mel_bins=80,\n    waveform_scale=2**15,\n    channel_last=True,\n    standardize=False,\n    device=device,\n    dtype=dtype,\n)\ndef normalize_fbank(data: WaveformToFbankOutput) -> WaveformToFbankOutput:\n    fbank = data[\"fbank\"]",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "collate",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "collate = Collater(pad_value=0, pad_to_multiple=1)\nAUDIO_SAMPLE_RATE = 16000\nMAX_INPUT_AUDIO_LENGTH = 10  # in seconds\ndef remove_prosody_tokens_from_text(text):\n    # filter out prosody tokens, there is only emphasis '*', and pause '='\n    text = text.replace(\"*\", \"\").replace(\"=\", \"\")\n    text = \" \".join(text.split())\n    return text\ndef preprocess_audio(input_audio_path: str) -> None:\n    arr, org_sr = torchaudio.load(input_audio_path)",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "AUDIO_SAMPLE_RATE",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "AUDIO_SAMPLE_RATE = 16000\nMAX_INPUT_AUDIO_LENGTH = 10  # in seconds\ndef remove_prosody_tokens_from_text(text):\n    # filter out prosody tokens, there is only emphasis '*', and pause '='\n    text = text.replace(\"*\", \"\").replace(\"=\", \"\")\n    text = \" \".join(text.split())\n    return text\ndef preprocess_audio(input_audio_path: str) -> None:\n    arr, org_sr = torchaudio.load(input_audio_path)\n    new_arr = torchaudio.functional.resample(arr, orig_freq=org_sr, new_freq=AUDIO_SAMPLE_RATE)",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "MAX_INPUT_AUDIO_LENGTH",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "MAX_INPUT_AUDIO_LENGTH = 10  # in seconds\ndef remove_prosody_tokens_from_text(text):\n    # filter out prosody tokens, there is only emphasis '*', and pause '='\n    text = text.replace(\"*\", \"\").replace(\"=\", \"\")\n    text = \" \".join(text.split())\n    return text\ndef preprocess_audio(input_audio_path: str) -> None:\n    arr, org_sr = torchaudio.load(input_audio_path)\n    new_arr = torchaudio.functional.resample(arr, orig_freq=org_sr, new_freq=AUDIO_SAMPLE_RATE)\n    max_length = int(MAX_INPUT_AUDIO_LENGTH * AUDIO_SAMPLE_RATE)",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.app",
        "description": "lib.seamless_communication.demo.expressive.app",
        "peekOfCode": "TARGET_LANGUAGE_NAMES = [\n    \"English\",\n    \"French\",\n    \"German\",\n    \"Spanish\",\n]\nwith gr.Blocks(css=\"style.css\") as demo:\n    gr.Markdown(DESCRIPTION)\n    gr.DuplicateButton(\n        value=\"Duplicate Space for private use\",",
        "detail": "lib.seamless_communication.demo.expressive.app",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_CODE_TO_NAME",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.expressive.utils",
        "description": "lib.seamless_communication.demo.expressive.utils",
        "peekOfCode": "LANGUAGE_CODE_TO_NAME = {\n    \"afr\": \"Afrikaans\",\n    \"amh\": \"Amharic\",\n    \"arb\": \"Modern Standard Arabic\",\n    \"ary\": \"Moroccan Arabic\",\n    \"arz\": \"Egyptian Arabic\",\n    \"asm\": \"Assamese\",\n    \"ast\": \"Asturian\",\n    \"azj\": \"North Azerbaijani\",\n    \"bel\": \"Belarusian\",",
        "detail": "lib.seamless_communication.demo.expressive.utils",
        "documentation": {}
    },
    {
        "label": "predict",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def predict(\n    task_name: str,\n    audio_source: str,\n    input_audio_mic: str | None,\n    input_audio_file: str | None,\n    input_text: str | None,\n    source_language: str | None,\n    target_language: str,\n) -> tuple[tuple[int, np.ndarray] | None, str]:\n    task_name = task_name.split()[0]",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "process_s2st_example",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def process_s2st_example(\n    input_audio_file: str, target_language: str\n) -> tuple[tuple[int, np.ndarray] | None, str]:\n    return predict(\n        task_name=\"S2ST\",\n        audio_source=\"file\",\n        input_audio_mic=None,\n        input_audio_file=input_audio_file,\n        input_text=None,\n        source_language=None,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "process_s2tt_example",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def process_s2tt_example(\n    input_audio_file: str, target_language: str\n) -> tuple[tuple[int, np.ndarray] | None, str]:\n    return predict(\n        task_name=\"S2TT\",\n        audio_source=\"file\",\n        input_audio_mic=None,\n        input_audio_file=input_audio_file,\n        input_text=None,\n        source_language=None,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "process_t2st_example",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def process_t2st_example(\n    input_text: str, source_language: str, target_language: str\n) -> tuple[tuple[int, np.ndarray] | None, str]:\n    return predict(\n        task_name=\"T2ST\",\n        audio_source=\"\",\n        input_audio_mic=None,\n        input_audio_file=None,\n        input_text=input_text,\n        source_language=source_language,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "process_t2tt_example",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def process_t2tt_example(\n    input_text: str, source_language: str, target_language: str\n) -> tuple[tuple[int, np.ndarray] | None, str]:\n    return predict(\n        task_name=\"T2TT\",\n        audio_source=\"\",\n        input_audio_mic=None,\n        input_audio_file=None,\n        input_text=input_text,\n        source_language=source_language,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "process_asr_example",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def process_asr_example(\n    input_audio_file: str, target_language: str\n) -> tuple[tuple[int, np.ndarray] | None, str]:\n    return predict(\n        task_name=\"ASR\",\n        audio_source=\"file\",\n        input_audio_mic=None,\n        input_audio_file=input_audio_file,\n        input_text=None,\n        source_language=None,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "update_audio_ui",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def update_audio_ui(audio_source: str) -> tuple[dict, dict]:\n    mic = audio_source == \"microphone\"\n    return (\n        gr.update(visible=mic, value=None),  # input_audio_mic\n        gr.update(visible=not mic, value=None),  # input_audio_file\n    )\ndef update_input_ui(task_name: str) -> tuple[dict, dict, dict, dict]:\n    task_name = task_name.split()[0]\n    if task_name == \"S2ST\":\n        return (",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "update_input_ui",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def update_input_ui(task_name: str) -> tuple[dict, dict, dict, dict]:\n    task_name = task_name.split()[0]\n    if task_name == \"S2ST\":\n        return (\n            gr.update(visible=True),  # audio_box\n            gr.update(visible=False),  # input_text\n            gr.update(visible=False),  # source_language\n            gr.update(\n                visible=True,\n                choices=S2ST_TARGET_LANGUAGE_NAMES,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "update_output_ui",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def update_output_ui(task_name: str) -> tuple[dict, dict]:\n    task_name = task_name.split()[0]\n    if task_name in [\"S2ST\", \"T2ST\"]:\n        return (\n            gr.update(visible=True, value=None),  # output_audio\n            gr.update(value=None),  # output_text\n        )\n    elif task_name in [\"S2TT\", \"T2TT\", \"ASR\"]:\n        return (\n            gr.update(visible=False, value=None),  # output_audio",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "update_example_ui",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "def update_example_ui(task_name: str) -> tuple[dict, dict, dict, dict, dict]:\n    task_name = task_name.split()[0]\n    return (\n        gr.update(visible=task_name == \"S2ST\"),  # s2st_example_row\n        gr.update(visible=task_name == \"S2TT\"),  # s2tt_example_row\n        gr.update(visible=task_name == \"T2ST\"),  # t2st_example_row\n        gr.update(visible=task_name == \"T2TT\"),  # t2tt_example_row\n        gr.update(visible=task_name == \"ASR\"),  # asr_example_row\n    )\ncss = \"\"\"",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "DESCRIPTION",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "DESCRIPTION = \"\"\"# SeamlessM4T\n[SeamlessM4T](https://github.com/facebookresearch/seamless_communication) is designed to provide high-quality\ntranslation, allowing people from different linguistic communities to communicate effortlessly through speech and text.\nThis unified model enables multiple tasks like Speech-to-Speech (S2ST), Speech-to-Text (S2TT), Text-to-Speech (T2ST)\ntranslation and more, without relying on multiple separate models.\n\"\"\"\nTASK_NAMES = [\n    \"S2ST (Speech to Speech translation)\",\n    \"S2TT (Speech to Text translation)\",\n    \"T2ST (Text to Speech translation)\",",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "TASK_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "TASK_NAMES = [\n    \"S2ST (Speech to Speech translation)\",\n    \"S2TT (Speech to Text translation)\",\n    \"T2ST (Text to Speech translation)\",\n    \"T2TT (Text to Text translation)\",\n    \"ASR (Automatic Speech Recognition)\",\n]\n# Language dict\nlanguage_code_to_name = {\n    \"afr\": \"Afrikaans\",",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "language_code_to_name",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "language_code_to_name = {\n    \"afr\": \"Afrikaans\",\n    \"amh\": \"Amharic\",\n    \"arb\": \"Modern Standard Arabic\",\n    \"ary\": \"Moroccan Arabic\",\n    \"arz\": \"Egyptian Arabic\",\n    \"asm\": \"Assamese\",\n    \"ast\": \"Asturian\",\n    \"azj\": \"North Azerbaijani\",\n    \"bel\": \"Belarusian\",",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_NAME_TO_CODE",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "LANGUAGE_NAME_TO_CODE = {v: k for k, v in language_code_to_name.items()}\n# Source langs: S2ST / S2TT / ASR don't need source lang\n# T2TT / T2ST use this\ntext_source_language_codes = [\n    \"afr\",\n    \"amh\",\n    \"arb\",\n    \"ary\",\n    \"arz\",\n    \"asm\",",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "text_source_language_codes",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "text_source_language_codes = [\n    \"afr\",\n    \"amh\",\n    \"arb\",\n    \"ary\",\n    \"arz\",\n    \"asm\",\n    \"azj\",\n    \"bel\",\n    \"ben\",",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "TEXT_SOURCE_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "TEXT_SOURCE_LANGUAGE_NAMES = sorted(\n    [language_code_to_name[code] for code in text_source_language_codes]\n)\n# Target langs:\n# S2ST / T2ST\ns2st_target_language_codes = [\n    \"eng\",\n    \"arb\",\n    \"ben\",\n    \"cat\",",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "s2st_target_language_codes",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "s2st_target_language_codes = [\n    \"eng\",\n    \"arb\",\n    \"ben\",\n    \"cat\",\n    \"ces\",\n    \"cmn\",\n    \"cym\",\n    \"dan\",\n    \"deu\",",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "S2ST_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "S2ST_TARGET_LANGUAGE_NAMES = sorted(\n    [language_code_to_name[code] for code in s2st_target_language_codes]\n)\n# S2TT / ASR\nS2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\n# T2TT\nT2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\n# Download sample input audio files\nfilenames = [\"assets/sample_input.mp3\", \"assets/sample_input_2.mp3\"]\nfor filename in filenames:",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "S2TT_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "S2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\n# T2TT\nT2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\n# Download sample input audio files\nfilenames = [\"assets/sample_input.mp3\", \"assets/sample_input_2.mp3\"]\nfor filename in filenames:\n    hf_hub_download(\n        repo_id=\"facebook/seamless_m4t\",\n        repo_type=\"space\",\n        filename=filename,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "T2TT_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "T2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\n# Download sample input audio files\nfilenames = [\"assets/sample_input.mp3\", \"assets/sample_input_2.mp3\"]\nfor filename in filenames:\n    hf_hub_download(\n        repo_id=\"facebook/seamless_m4t\",\n        repo_type=\"space\",\n        filename=filename,\n        local_dir=\".\",\n    )",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "filenames",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "filenames = [\"assets/sample_input.mp3\", \"assets/sample_input_2.mp3\"]\nfor filename in filenames:\n    hf_hub_download(\n        repo_id=\"facebook/seamless_m4t\",\n        repo_type=\"space\",\n        filename=filename,\n        local_dir=\".\",\n    )\nAUDIO_SAMPLE_RATE = 16000.0\nMAX_INPUT_AUDIO_LENGTH = 60  # in seconds",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "AUDIO_SAMPLE_RATE",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "AUDIO_SAMPLE_RATE = 16000.0\nMAX_INPUT_AUDIO_LENGTH = 60  # in seconds\nDEFAULT_TARGET_LANGUAGE = \"French\"\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\ntranslator = Translator(\n    model_name_or_card=\"seamlessM4T_large\",\n    vocoder_name_or_card=\"vocoder_36langs\",\n    device=device,\n    dtype=torch.float16 if \"cuda\" in device.type else torch.float32,\n)",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "MAX_INPUT_AUDIO_LENGTH",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "MAX_INPUT_AUDIO_LENGTH = 60  # in seconds\nDEFAULT_TARGET_LANGUAGE = \"French\"\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\ntranslator = Translator(\n    model_name_or_card=\"seamlessM4T_large\",\n    vocoder_name_or_card=\"vocoder_36langs\",\n    device=device,\n    dtype=torch.float16 if \"cuda\" in device.type else torch.float32,\n)\ndef predict(",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TARGET_LANGUAGE",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "DEFAULT_TARGET_LANGUAGE = \"French\"\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\ntranslator = Translator(\n    model_name_or_card=\"seamlessM4T_large\",\n    vocoder_name_or_card=\"vocoder_36langs\",\n    device=device,\n    dtype=torch.float16 if \"cuda\" in device.type else torch.float32,\n)\ndef predict(\n    task_name: str,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\ntranslator = Translator(\n    model_name_or_card=\"seamlessM4T_large\",\n    vocoder_name_or_card=\"vocoder_36langs\",\n    device=device,\n    dtype=torch.float16 if \"cuda\" in device.type else torch.float32,\n)\ndef predict(\n    task_name: str,\n    audio_source: str,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "translator",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "translator = Translator(\n    model_name_or_card=\"seamlessM4T_large\",\n    vocoder_name_or_card=\"vocoder_36langs\",\n    device=device,\n    dtype=torch.float16 if \"cuda\" in device.type else torch.float32,\n)\ndef predict(\n    task_name: str,\n    audio_source: str,\n    input_audio_mic: str | None,",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "css",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv1.app",
        "description": "lib.seamless_communication.demo.m4tv1.app",
        "peekOfCode": "css = \"\"\"\nh1 {\n  text-align: center;\n}\n.contain {\n  max-width: 730px;\n  margin: auto;\n  padding-top: 1.5rem;\n}\n\"\"\"",
        "detail": "lib.seamless_communication.demo.m4tv1.app",
        "documentation": {}
    },
    {
        "label": "preprocess_audio",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "def preprocess_audio(input_audio: str) -> None:\n    arr, org_sr = torchaudio.load(input_audio)\n    new_arr = torchaudio.functional.resample(arr, orig_freq=org_sr, new_freq=AUDIO_SAMPLE_RATE)\n    max_length = int(MAX_INPUT_AUDIO_LENGTH * AUDIO_SAMPLE_RATE)\n    if new_arr.shape[1] > max_length:\n        new_arr = new_arr[:, :max_length]\n        gr.Warning(f\"Input audio is too long. Only the first {MAX_INPUT_AUDIO_LENGTH} seconds is used.\")\n    torchaudio.save(input_audio, new_arr, sample_rate=int(AUDIO_SAMPLE_RATE))\ndef run_s2st(\n    input_audio: str, source_language: str, target_language: str",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "run_s2st",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "def run_s2st(\n    input_audio: str, source_language: str, target_language: str\n) -> tuple[tuple[int, np.ndarray] | None, str]:\n    preprocess_audio(input_audio)\n    source_language_code = LANGUAGE_NAME_TO_CODE[source_language]\n    target_language_code = LANGUAGE_NAME_TO_CODE[target_language]\n    out_texts, out_audios = translator.predict(\n        input=input_audio,\n        task_str=\"S2ST\",\n        src_lang=source_language_code,",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "run_s2tt",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "def run_s2tt(input_audio: str, source_language: str, target_language: str) -> str:\n    preprocess_audio(input_audio)\n    source_language_code = LANGUAGE_NAME_TO_CODE[source_language]\n    target_language_code = LANGUAGE_NAME_TO_CODE[target_language]\n    out_texts, _ = translator.predict(\n        input=input_audio,\n        task_str=\"S2TT\",\n        src_lang=source_language_code,\n        tgt_lang=target_language_code,\n    )",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "run_t2st",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "def run_t2st(input_text: str, source_language: str, target_language: str) -> tuple[tuple[int, np.ndarray] | None, str]:\n    source_language_code = LANGUAGE_NAME_TO_CODE[source_language]\n    target_language_code = LANGUAGE_NAME_TO_CODE[target_language]\n    out_texts, out_audios = translator.predict(\n        input=input_text,\n        task_str=\"T2ST\",\n        src_lang=source_language_code,\n        tgt_lang=target_language_code,\n    )\n    out_text = str(out_texts[0])",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "run_t2tt",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "def run_t2tt(input_text: str, source_language: str, target_language: str) -> str:\n    source_language_code = LANGUAGE_NAME_TO_CODE[source_language]\n    target_language_code = LANGUAGE_NAME_TO_CODE[target_language]\n    out_texts, _ = translator.predict(\n        input=input_text,\n        task_str=\"T2TT\",\n        src_lang=source_language_code,\n        tgt_lang=target_language_code,\n    )\n    return str(out_texts[0])",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "run_asr",
        "kind": 2,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "def run_asr(input_audio: str, target_language: str) -> str:\n    preprocess_audio(input_audio)\n    target_language_code = LANGUAGE_NAME_TO_CODE[target_language]\n    out_texts, _ = translator.predict(\n        input=input_audio,\n        task_str=\"ASR\",\n        src_lang=target_language_code,\n        tgt_lang=target_language_code,\n    )\n    return str(out_texts[0])",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "user",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "user = getpass.getuser() # this is not portable on windows\nCHECKPOINTS_PATH = pathlib.Path(os.getenv(\"CHECKPOINTS_PATH\", f\"/home/{user}/app/models\"))\nif not CHECKPOINTS_PATH.exists():\n    snapshot_download(repo_id=\"facebook/seamless-m4t-v2-large\", repo_type=\"model\", local_dir=CHECKPOINTS_PATH)\nasset_store.env_resolvers.clear()\nasset_store.env_resolvers.append(lambda: \"demo\")\ndemo_metadata = [\n    {\n        \"name\": \"seamlessM4T_v2_large@demo\",\n        \"checkpoint\": f\"file://{CHECKPOINTS_PATH}/seamlessM4T_v2_large.pt\",",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "CHECKPOINTS_PATH",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "CHECKPOINTS_PATH = pathlib.Path(os.getenv(\"CHECKPOINTS_PATH\", f\"/home/{user}/app/models\"))\nif not CHECKPOINTS_PATH.exists():\n    snapshot_download(repo_id=\"facebook/seamless-m4t-v2-large\", repo_type=\"model\", local_dir=CHECKPOINTS_PATH)\nasset_store.env_resolvers.clear()\nasset_store.env_resolvers.append(lambda: \"demo\")\ndemo_metadata = [\n    {\n        \"name\": \"seamlessM4T_v2_large@demo\",\n        \"checkpoint\": f\"file://{CHECKPOINTS_PATH}/seamlessM4T_v2_large.pt\",\n        \"char_tokenizer\": f\"file://{CHECKPOINTS_PATH}/spm_char_lang38_tc.model\",",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "demo_metadata",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "demo_metadata = [\n    {\n        \"name\": \"seamlessM4T_v2_large@demo\",\n        \"checkpoint\": f\"file://{CHECKPOINTS_PATH}/seamlessM4T_v2_large.pt\",\n        \"char_tokenizer\": f\"file://{CHECKPOINTS_PATH}/spm_char_lang38_tc.model\",\n    },\n    {\n        \"name\": \"vocoder_v2@demo\",\n        \"checkpoint\": f\"file://{CHECKPOINTS_PATH}/vocoder_v2.pt\",\n    },",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "DESCRIPTION",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "DESCRIPTION = \"\"\"\\\n# SeamlessM4T\n[SeamlessM4T](https://github.com/facebookresearch/seamless_communication) is designed to provide high-quality\ntranslation, allowing people from different linguistic communities to communicate effortlessly through speech and text.\nThis unified model enables multiple tasks like Speech-to-Speech (S2ST), Speech-to-Text (S2TT), Text-to-Speech (T2ST)\ntranslation and more, without relying on multiple separate models.\n\"\"\"\nCACHE_EXAMPLES = os.getenv(\"CACHE_EXAMPLES\") == \"1\" and torch.cuda.is_available()\nAUDIO_SAMPLE_RATE = 16000.0\nMAX_INPUT_AUDIO_LENGTH = 60  # in seconds",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "CACHE_EXAMPLES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "CACHE_EXAMPLES = os.getenv(\"CACHE_EXAMPLES\") == \"1\" and torch.cuda.is_available()\nAUDIO_SAMPLE_RATE = 16000.0\nMAX_INPUT_AUDIO_LENGTH = 60  # in seconds\nDEFAULT_TARGET_LANGUAGE = \"French\"\nif torch.cuda.is_available():\n    device = torch.device(\"cuda:0\")\n    dtype = torch.float16\nelse:\n    device = torch.device(\"cpu\")\n    dtype = torch.float32",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "AUDIO_SAMPLE_RATE",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "AUDIO_SAMPLE_RATE = 16000.0\nMAX_INPUT_AUDIO_LENGTH = 60  # in seconds\nDEFAULT_TARGET_LANGUAGE = \"French\"\nif torch.cuda.is_available():\n    device = torch.device(\"cuda:0\")\n    dtype = torch.float16\nelse:\n    device = torch.device(\"cpu\")\n    dtype = torch.float32\ntranslator = Translator(",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "MAX_INPUT_AUDIO_LENGTH",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "MAX_INPUT_AUDIO_LENGTH = 60  # in seconds\nDEFAULT_TARGET_LANGUAGE = \"French\"\nif torch.cuda.is_available():\n    device = torch.device(\"cuda:0\")\n    dtype = torch.float16\nelse:\n    device = torch.device(\"cpu\")\n    dtype = torch.float32\ntranslator = Translator(\n    model_name_or_card=\"seamlessM4T_v2_large\",",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TARGET_LANGUAGE",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "DEFAULT_TARGET_LANGUAGE = \"French\"\nif torch.cuda.is_available():\n    device = torch.device(\"cuda:0\")\n    dtype = torch.float16\nelse:\n    device = torch.device(\"cpu\")\n    dtype = torch.float32\ntranslator = Translator(\n    model_name_or_card=\"seamlessM4T_v2_large\",\n    vocoder_name_or_card=\"vocoder_v2\",",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "translator",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.app",
        "description": "lib.seamless_communication.demo.m4tv2.app",
        "peekOfCode": "translator = Translator(\n    model_name_or_card=\"seamlessM4T_v2_large\",\n    vocoder_name_or_card=\"vocoder_v2\",\n    device=device,\n    dtype=dtype,\n    apply_mintox=True,\n)\ndef preprocess_audio(input_audio: str) -> None:\n    arr, org_sr = torchaudio.load(input_audio)\n    new_arr = torchaudio.functional.resample(arr, orig_freq=org_sr, new_freq=AUDIO_SAMPLE_RATE)",
        "detail": "lib.seamless_communication.demo.m4tv2.app",
        "documentation": {}
    },
    {
        "label": "language_code_to_name",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "language_code_to_name = {\n    \"afr\": \"Afrikaans\",\n    \"amh\": \"Amharic\",\n    \"arb\": \"Modern Standard Arabic\",\n    \"ary\": \"Moroccan Arabic\",\n    \"arz\": \"Egyptian Arabic\",\n    \"asm\": \"Assamese\",\n    \"ast\": \"Asturian\",\n    \"azj\": \"North Azerbaijani\",\n    \"bel\": \"Belarusian\",",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_NAME_TO_CODE",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "LANGUAGE_NAME_TO_CODE = {v: k for k, v in language_code_to_name.items()}\n# Source langs: S2ST / S2TT / ASR don't need source lang\n# T2TT / T2ST use this\ntext_source_language_codes = [\n    \"afr\",\n    \"amh\",\n    \"arb\",\n    \"ary\",\n    \"arz\",\n    \"asm\",",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "text_source_language_codes",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "text_source_language_codes = [\n    \"afr\",\n    \"amh\",\n    \"arb\",\n    \"ary\",\n    \"arz\",\n    \"asm\",\n    \"azj\",\n    \"bel\",\n    \"ben\",",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "TEXT_SOURCE_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "TEXT_SOURCE_LANGUAGE_NAMES = sorted([language_code_to_name[code] for code in text_source_language_codes])\n# Target langs:\n# S2ST / T2ST\ns2st_target_language_codes = [\n    \"eng\",\n    \"arb\",\n    \"ben\",\n    \"cat\",\n    \"ces\",\n    \"cmn\",",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "s2st_target_language_codes",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "s2st_target_language_codes = [\n    \"eng\",\n    \"arb\",\n    \"ben\",\n    \"cat\",\n    \"ces\",\n    \"cmn\",\n    \"cym\",\n    \"dan\",\n    \"deu\",",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "S2ST_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "S2ST_TARGET_LANGUAGE_NAMES = sorted([language_code_to_name[code] for code in s2st_target_language_codes])\nT2ST_TARGET_LANGUAGE_NAMES = S2ST_TARGET_LANGUAGE_NAMES\n# S2TT / T2TT / ASR\nS2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nT2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "T2ST_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "T2ST_TARGET_LANGUAGE_NAMES = S2ST_TARGET_LANGUAGE_NAMES\n# S2TT / T2TT / ASR\nS2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nT2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "S2TT_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "S2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nT2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "T2TT_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "T2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "ASR_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "lib.seamless_communication.demo.m4tv2.lang_list",
        "description": "lib.seamless_communication.demo.m4tv2.lang_list",
        "peekOfCode": "ASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "lib.seamless_communication.demo.m4tv2.lang_list",
        "documentation": {}
    },
    {
        "label": "ffi",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.ggml.cffi",
        "description": "lib.seamless_communication.ggml.examples.python.ggml.cffi",
        "peekOfCode": "ffi = _cffi_backend.FFI('ggml.cffi',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\xB6\\x0D\\x00\\x00\\x09\\x0B\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x04\\x2F\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x04\\x31\\x03\\x00\\x04\\x3D\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x04\\x32\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x04\\x34\\x03\\x00\\x03\\xFE\\x03\\x00\\x04\\x53\\x03\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x04\\x3D\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x04\\x3E\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x00\\x10\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\xB6\\x0D\\x00\\x00\\x00\\x0F\\x00\\x02\\xD0\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x0F\\x0D\\x00\\x00\\x04\\x0B\\x00\\x00\\x00\\x0F\\x00\\x00\\x0F\\x0D\\x00\\x00\\x01\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x0F\\x0D\\x00\\x00\\x0B\\x0B\\x00\\x00\\x00\\x0F\\x00\\x00\\x0F\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x0F\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x0F\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x16\\x0D\\x00\\x00\\x0B\\x11\\x00\\x04\\x38\\x03\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x16\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x44\\x11\\x00\\x00\\x08\\x11\\x00\\x04\\x30\\x03\\x00\\x00\\x4B\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x16\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x20\\x09\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x01\\x0D\\x00\\x00\\x01\\x0B\\x00\\x00\\x00\\x0F\\x00\\x01\\x14\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x34\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x02\\x7E\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\xF4\\x0D\\x00\\x00\\x01\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\xF4\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\xF4\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\xF4\\x0D\\x00\\x00\\x06\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x18\\x0D\\x00\\x00\\x01\\x11\\x00\\x00\\x00\\x0F\\x00\\x02\\xE9\\x0D\\x00\\x00\\x0E\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x22\\x0D\\x00\\x00\\x01\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x22\\x0D\\x00\\x00\\x4B\\x11\\x00\\x04\\x33\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x22\\x0D\\x00\\x00\\x0E\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x22\\x0D\\x00\\x04\\x35\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x22\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x22\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x22\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x22\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x22\\x0D\\x00\\x00\\x00\\x0F\\x00\\x00\\xDB\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\xDB\\x0D\\x00\\x00\\x00\\x0F\\x00\\x03\\xB0\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x03\\xB5\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x04\\x0D\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x04\\x0D\\x00\\x00\\x10\\x11\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x4B\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x4B\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x30\\x0D\\x00\\x00\\x0F\\x11\\x00\\x00\\x0B\\x03\\x00\\x00\\xB0\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x30\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x4B\\x11\\x00\\x00\\x01\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x30\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x0B\\x0D\\x00\\x00\\x1B\\x09\\x00\\x00\\x00\\x0F\\x00\\x04\\x33\\x0D\\x00\\x00\\x4B\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x0E\\x0D\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x7F\\x0D\\x00\\x00\\x00\\x0F\\x00\\x00\\x50\\x0D\\x00\\x00\\x07\\x0B\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x4B\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x01\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\xDB\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x01\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x01\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x01\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x01\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x0D\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x05\\x0B\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x01\\x01\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0A\\x0B\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0D\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0D\\x01\\x00\\x00\\x0D\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x0D\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x0D\\x01\\x00\\x00\\x0D\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0B\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x01\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x01\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x03\\x5C\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x03\\x62\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x10\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x02\\xD8\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x03\\x4F\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x08\\x11\\x00\\x03\\x54\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x10\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x02\\xD3\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x03\\x44\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x03\\x48\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x10\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x01\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x0D\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x08\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x21\\x0D\\x00\\x00\\x0F\\x11\\x00\\x00\\x24\\x09\\x00\\x00\\x00\\x0F\\x00\\x00\\x21\\x0D\\x00\\x00\\x00\\x0F\\x00\\x03\\xBA\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x03\\xBF\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x01\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x01\\x11\\x00\\x00\\xF4\\x03\\x00\\x00\\x10\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\xDB\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x02\\x35\\x11\\x00\\x00\\x10\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x02\\x39\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x04\\x11\\x00\\x00\\x4B\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x21\\x09\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x04\\x32\\x03\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x11\\x0D\\x00\\x00\\x00\\x0F\\x00\\x00\\x6C\\x0D\\x00\\x00\\x0D\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x6C\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x10\\x0D\\x00\\x02\\x4B\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x10\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x10\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x00\\x0F\\x00\\x00\\x10\\x0D\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x02\\xE1\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x01\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x03\\xF8\\x03\\x00\\x00\\xF4\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x03\\xF9\\x03\\x00\\x02\\x7E\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x03\\xFA\\x03\\x00\\x02\\x7E\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x03\\xFB\\x03\\x00\\x02\\x7E\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x03\\xFC\\x03\\x00\\x02\\x7E\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x03\\xFD\\x03\\x00\\x02\\x7E\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0F\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x0F\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x35\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x35\\x11\\x00\\x03\\xF8\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x35\\x11\\x00\\x03\\xF9\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x35\\x11\\x00\\x03\\xFA\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x35\\x11\\x00\\x03\\xFB\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x35\\x11\\x00\\x03\\xFC\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x35\\x11\\x00\\x03\\xFD\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x35\\x11\\x00\\x00\\x6C\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x35\\x11\\x00\\x00\\x10\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x07\\x01\\x00\\x03\\xFE\\x03\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x07\\x01\\x00\\x02\\x7E\\x11\\x00\\x02\\x35\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x07\\x01\\x00\\x02\\x7E\\x11\\x00\\x02\\x35\\x11\\x00\\x02\\x35\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x07\\x01\\x00\\x02\\x7E\\x11\\x00\\x04\\x53\\x03\\x00\\x02\\xE1\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x04\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x04\\x11\\x00\\x00\\x22\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x04\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x4B\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x4B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x04\\x30\\x03\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\xF8\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\xF8\\x11\\x00\\x02\\xF8\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x01\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x4B\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x44\\x11\\x00\\x00\\x50\\x11\\x00\\x00\\x0B\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0B\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\x4B\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0E\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0E\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0E\\x11\\x00\\x00\\x4B\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0E\\x11\\x00\\x00\\x4B\\x11\\x00\\x00\\x01\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0E\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x7F\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x7F\\x11\\x00\\x02\\xE9\\x11\\x00\\x02\\xE9\\x11\\x00\\x02\\xE9\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x7F\\x11\\x00\\x00\\x4B\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x04\\x37\\x03\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x10\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x10\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x08\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x10\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x0D\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x15\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x10\\x11\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x01\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x0F\\x03\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x01\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x34\\x11\\x00\\x02\\xE1\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x0D\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x05\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x03\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x04\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x08\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x00\\x06\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x0F\\x11\\x00\\x02\\xE1\\x11\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x15\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x21\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x21\\x11\\x00\\x00\\x10\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x0A\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x6C\\x03\\x00\\x02\\x7E\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x10\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x10\\x11\\x00\\x00\\x08\\x11\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x02\\xE1\\x11\\x00\\x02\\x7E\\x11\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x04\\x53\\x0D\\x00\\x00\\x00\\x0F\\x00\\x00\\x24\\x03\\x00\\x00\\x0D\\x09\\x00\\x00\\x0E\\x09\\x00\\x00\\x0F\\x09\\x00\\x00\\x10\\x09\\x00\\x00\\x11\\x09\\x00\\x00\\x12\\x09\\x00\\x00\\x13\\x09\\x00\\x00\\x14\\x09\\x00\\x00\\x04\\x09\\x00\\x00\\x05\\x09\\x00\\x00\\x06\\x09\\x00\\x00\\x07\\x09\\x00\\x00\\x08\\x09\\x00\\x00\\x09\\x09\\x00\\x00\\x0A\\x09\\x00\\x00\\x02\\x01\\x00\\x03\\xFE\\x05\\x00\\x00\\x00\\x80\\x00\\x03\\xFE\\x05\\x00\\x00\\x00\\x10\\x00\\x03\\xFE\\x05\\x00\\x00\\x00\\xC0\\x00\\x03\\xFE\\x05\\x00\\x00\\x00\\x25\\x00\\x03\\xFE\\x05\\x00\\x00\\x00\\x28\\x00\\x03\\xFE\\x05\\x00\\x00\\x00\\x04\\x00\\x03\\xFE\\x05\\x00\\x00\\x00\\x38\\x00\\x03\\xFE\\x05\\x00\\x00\\x00\\x40\\x00\\x03\\xFE\\x05\\x00\\x00\\x1F\\xF0\\x00\\x03\\xFE\\x05\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x0B\\x00\\x00\\x02\\x0B\\x00\\x00\\x03\\x0B\\x00\\x00\\x06\\x0B\\x00\\x00\\x08\\x0B\\x00\\x00\\x0B\\x09\\x00\\x00\\x22\\x05\\x00\\x00\\x10\\x00\\x00\\x00\\x22\\x05\\x00\\x00\\x00\\x08\\x00\\x00\\x0F\\x01\\x00\\x00\\xDB\\x05\\x00\\x00\\x00\\x04\\x00\\x00\\x09\\x01\\x00\\x03\\xB0\\x05\\x00\\x00\\x00\\x10\\x00\\x03\\xB5\\x05\\x00\\x00\\x00\\x10\\x00\\x03\\xB5\\x05\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x09\\x00\\x00\\x01\\x09\\x00\\x00\\x02\\x09\\x00\\x00\\x03\\x09\\x00\\x04\\x2C\\x03\\x00\\x00\\x0C\\x09\\x00\\x04\\x2E\\x03\\x00\\x00\\x15\\x09\\x00\\x00\\x16\\x09\\x00\\x00\\x17\\x09\\x00\\x00\\x18\\x09\\x00\\x00\\x19\\x09\\x00\\x00\\x1A\\x09\\x00\\x00\\x1C\\x09\\x00\\x00\\x1D\\x09\\x00\\x04\\x37\\x03\\x00\\x00\\x1E\\x09\\x00\\x00\\x1F\\x09\\x00\\x00\\x08\\x05\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x05\\x00\\x00\\x00\\x06\\x00\\x00\\x22\\x09\\x00\\x00\\x23\\x09\\x00\\x03\\xBA\\x03\\x00\\x03\\xBA\\x05\\x00\\x00\\x00\\x80\\x00\\x03\\xBA\\x05\\x00\\x00\\x00\\x0C\\x00\\x03\\xBA\\x05\\x00\\x00\\x00\\x10\\x00\\x03\\xBA\\x05\\x00\\x00\\x00\\x20\\x00\\x03\\xBA\\x05\\x00\\x00\\x00\\x40\\x00\\x00\\x0C\\x01\\x00\\x00\\x11\\x05\\x00\\x00\\x00\\x04\\x00\\x00\\x10\\x05\\x00\\x00\\x20\\x51\\x00\\x02\\xC6\\x03\\x00\\x02\\xDE\\x03\\x00\\x03\\xE0\\x03\\x00\\x03\\xE7\\x03\\x00\\x00\\x00\\x01',\n    _globals = (b'\\xFF\\xFF\\xFF\\x0BGGML_BACKEND_CPU',0,b'\\xFF\\xFF\\xFF\\x0BGGML_BACKEND_GPU',10,b'\\xFF\\xFF\\xFF\\x0BGGML_BACKEND_GPU_SPLIT',20,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_ALL_F32',0,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_F16',1,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q2_K',10,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q3_K',11,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q4_0',2,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q4_1',3,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q4_1_SOME_F16',4,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q4_K',12,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q5_0',8,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q5_1',9,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q5_K',13,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q6_K',14,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_MOSTLY_Q8_0',7,b'\\xFF\\xFF\\xFF\\x0BGGML_FTYPE_UNKNOWN',-1,b'\\xFF\\xFF\\xFF\\x1FGGML_GRAPH_SIZE',164520,b'\\xFF\\xFF\\xFF\\x0BGGML_LINESEARCH_BACKTRACKING_ARMIJO',0,b'\\xFF\\xFF\\xFF\\x0BGGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE',2,b'\\xFF\\xFF\\xFF\\x0BGGML_LINESEARCH_BACKTRACKING_WOLFE',1,b'\\xFF\\xFF\\xFF\\x0BGGML_LINESEARCH_DEFAULT',1,b'\\xFF\\xFF\\xFF\\x0BGGML_LINESEARCH_FAIL',-128,b'\\xFF\\xFF\\xFF\\x0BGGML_LINESEARCH_INVALID_PARAMETERS',-124,b'\\xFF\\xFF\\xFF\\x0BGGML_LINESEARCH_MAXIMUM_ITERATIONS',-125,b'\\xFF\\xFF\\xFF\\x0BGGML_LINESEARCH_MAXIMUM_STEP',-126,b'\\xFF\\xFF\\xFF\\x0BGGML_LINESEARCH_MINIMUM_STEP',-127,b'\\xFF\\xFF\\xFF\\x0BGGML_OBJECT_GRAPH',1,b'\\xFF\\xFF\\xFF\\x1FGGML_OBJECT_SIZE',32,b'\\xFF\\xFF\\xFF\\x0BGGML_OBJECT_TENSOR',0,b'\\xFF\\xFF\\xFF\\x0BGGML_OBJECT_WORK_BUFFER',2,b'\\xFF\\xFF\\xFF\\x0BGGML_OPT_ADAM',0,b'\\xFF\\xFF\\xFF\\x0BGGML_OPT_DID_NOT_CONVERGE',1,b'\\xFF\\xFF\\xFF\\x0BGGML_OPT_FAIL',4,b'\\xFF\\xFF\\xFF\\x0BGGML_OPT_INVALID_WOLFE',3,b'\\xFF\\xFF\\xFF\\x0BGGML_OPT_LBFGS',1,b'\\xFF\\xFF\\xFF\\x0BGGML_OPT_NO_CONTEXT',2,b'\\xFF\\xFF\\xFF\\x0BGGML_OPT_OK',0,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_ACC',4,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_ADD',2,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_ADD1',3,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_ALIBI',40,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_ARGMAX',14,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_CLAMP',41,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_CONT',26,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_CONV_1D',42,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_CONV_2D',43,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_COUNT',62,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_CPY',25,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_CROSS_ENTROPY_LOSS',60,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_CROSS_ENTROPY_LOSS_BACK',61,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_DIAG',33,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_DIAG_MASK_INF',34,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_DIAG_MASK_ZERO',35,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_DIV',7,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_DUP',1,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_FLASH_ATTN',46,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_FLASH_ATTN_BACK',48,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_FLASH_FF',47,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_GET_ROWS',31,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_GET_ROWS_BACK',32,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_LOG',10,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MAP_BINARY',53,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MAP_CUSTOM1',57,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MAP_CUSTOM1_F32',54,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MAP_CUSTOM2',58,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MAP_CUSTOM2_F32',55,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MAP_CUSTOM3',59,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MAP_CUSTOM3_F32',56,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MAP_UNARY',52,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MEAN',13,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MUL',6,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_MUL_MAT',21,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_NONE',0,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_NORM',18,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_OUT_PROD',22,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_PERMUTE',29,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_POOL_1D',44,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_POOL_2D',45,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_POOL_AVG',1,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_POOL_COUNT',2,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_POOL_MAX',0,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_REPEAT',15,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_REPEAT_BACK',16,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_RESHAPE',27,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_RMS_NORM',19,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_RMS_NORM_BACK',20,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_ROPE',38,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_ROPE_BACK',39,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SCALE',23,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SET',24,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SILU_BACK',17,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SOFT_MAX',36,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SOFT_MAX_BACK',37,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SQR',8,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SQRT',9,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SUB',5,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SUM',11,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_SUM_ROWS',12,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_TRANSPOSE',30,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_UNARY',51,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_VIEW',28,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_WIN_PART',49,b'\\xFF\\xFF\\xFF\\x0BGGML_OP_WIN_UNPART',50,b'\\xFF\\xFF\\xFF\\x0BGGML_TASK_COMPUTE',1,b'\\xFF\\xFF\\xFF\\x0BGGML_TASK_FINALIZE',2,b'\\xFF\\xFF\\xFF\\x0BGGML_TASK_INIT',0,b'\\xFF\\xFF\\xFF\\x1FGGML_TENSOR_SIZE',288,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_COUNT',19,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_F16',1,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_F32',0,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_I16',17,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_I32',18,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_I8',16,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q2_K',10,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q3_K',11,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q4_0',2,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q4_1',3,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q4_K',12,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q5_0',6,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q5_1',7,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q5_K',13,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q6_K',14,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q8_0',8,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q8_1',9,b'\\xFF\\xFF\\xFF\\x0BGGML_TYPE_Q8_K',15,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_ABS',0,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_ELU',5,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_GELU',7,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_GELU_QUICK',8,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_NEG',2,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_RELU',6,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_SGN',1,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_SILU',9,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_STEP',3,b'\\xFF\\xFF\\xFF\\x0BGGML_UNARY_OP_TANH',4,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_ARRAY',9,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_BOOL',7,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_COUNT',10,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_FLOAT32',6,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_INT16',3,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_INT32',5,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_INT8',1,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_STRING',8,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_UINT16',2,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_UINT32',4,b'\\xFF\\xFF\\xFF\\x0BGGUF_TYPE_UINT8',0,b'\\x00\\x02\\x9A\\x23__assert_rtn',0,b'\\x00\\x02\\x7C\\x23dequantize_row_q2_K',0,b'\\x00\\x02\\x81\\x23dequantize_row_q3_K',0,b'\\x00\\x02\\x86\\x23dequantize_row_q4_K',0,b'\\x00\\x02\\x8B\\x23dequantize_row_q5_K',0,b'\\x00\\x02\\x90\\x23dequantize_row_q6_K',0,b'\\x00\\x02\\x95\\x23dequantize_row_q8_K',0,b'\\x00\\x00\\xFA\\x23ggml_abs',0,b'\\x00\\x00\\xFA\\x23ggml_abs_inplace',0,b'\\x00\\x01\\xDD\\x23ggml_acc',0,b'\\x00\\x01\\xDD\\x23ggml_acc_inplace',0,b'\\x00\\x01\\x84\\x23ggml_add',0,b'\\x00\\x01\\x84\\x23ggml_add1',0,b'\\x00\\x01\\x84\\x23ggml_add1_inplace',0,b'\\x00\\x01\\x84\\x23ggml_add_inplace',0,b'\\x00\\x01\\x26\\x23ggml_alibi',0,b'\\x00\\x02\\xEC\\x23ggml_allocr_alloc',0,b'\\x00\\x02\\x42\\x23ggml_allocr_alloc_graph',0,b'\\x00\\x02\\xE4\\x23ggml_allocr_free',0,b'\\x00\\x00\\x03\\x23ggml_allocr_is_measure',0,b'\\x00\\x00\\xA2\\x23ggml_allocr_new',0,b'\\x00\\x00\\x9F\\x23ggml_allocr_new_measure',0,b'\\x00\\x02\\xE4\\x23ggml_allocr_reset',0,b'\\x00\\x02\\xE7\\x23ggml_allocr_set_parse_seq',0,b'\\x00\\x00\\x17\\x23ggml_are_same_shape',0,b'\\x00\\x00\\xFA\\x23ggml_argmax',0,b'\\x00\\x00\\x74\\x23ggml_blck_size',0,b'\\x00\\x00\\xB3\\x23ggml_build_backward',0,b'\\x00\\x00\\xB8\\x23ggml_build_forward',0,b'\\x00\\x00\\xAA\\x23ggml_build_forward_ctx',0,b'\\x00\\x02\\xF3\\x23ggml_build_forward_expand',0,b'\\x00\\x00\\x1B\\x23ggml_cl_can_mul_mat',0,b'\\x00\\x03\\x6B\\x23ggml_cl_free_data',0,b'\\x00\\x03\\xE0\\x23ggml_cl_host_free',0,b'\\x00\\x02\\x72\\x23ggml_cl_host_malloc',0,b'\\x00\\x03\\xEC\\x23ggml_cl_init',0,b'\\x00\\x03\\x78\\x23ggml_cl_mul',0,b'\\x00\\x03\\x7D\\x23ggml_cl_mul_mat',0,b'\\x00\\x02\\x54\\x23ggml_cl_mul_mat_get_wsize',0,b'\\x00\\x03\\xE3\\x23ggml_cl_transform_tensor',0,b'\\x00\\x01\\x1B\\x23ggml_clamp',0,b'\\x00\\x00\\xFA\\x23ggml_cont',0,b'\\x00\\x00\\xFA\\x23ggml_cont_inplace',0,b'\\x00\\x01\\x90\\x23ggml_conv_1d',0,b'\\x00\\x01\\x89\\x23ggml_conv_1d_ph',0,b'\\x00\\x01\\x98\\x23ggml_conv_2d',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_arm_fma',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_avx',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_avx2',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_avx512',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_avx512_vbmi',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_avx512_vnni',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_blas',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_clblast',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_cublas',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_f16c',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_fma',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_fp16_va',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_gpublas',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_neon',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_sse3',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_vsx',0,b'\\x00\\x00\\x90\\x23ggml_cpu_has_wasm_simd',0,b'\\x00\\x01\\x84\\x23ggml_cpy',0,b'\\x00\\x01\\x84\\x23ggml_cpy_inplace',0,b'\\x00\\x01\\x84\\x23ggml_cross_entropy_loss',0,b'\\x00\\x01\\xA3\\x23ggml_cross_entropy_loss_back',0,b'\\x00\\x03\\x41\\x23ggml_cuda_assign_buffers',0,b'\\x00\\x03\\x41\\x23ggml_cuda_assign_buffers_force_inplace',0,b'\\x00\\x03\\x41\\x23ggml_cuda_assign_buffers_no_scratch',0,b'\\x00\\x00\\x1B\\x23ggml_cuda_can_mul_mat',0,b'\\x00\\x00\\x06\\x23ggml_cuda_compute_forward',0,b'\\x00\\x03\\x41\\x23ggml_cuda_free_data',0,b'\\x00\\x03\\xEC\\x23ggml_cuda_free_scratch',0,b'\\x00\\x00\\x90\\x23ggml_cuda_get_device_count',0,b'\\x00\\x02\\xCE\\x23ggml_cuda_get_device_description',0,b'\\x00\\x03\\xE0\\x23ggml_cuda_host_free',0,b'\\x00\\x02\\x72\\x23ggml_cuda_host_malloc',0,b'\\x00\\x02\\xCB\\x23ggml_cuda_set_main_device',0,b'\\x00\\x02\\x79\\x23ggml_cuda_set_mul_mat_q',0,b'\\x00\\x03\\xD8\\x23ggml_cuda_set_scratch_size',0,b'\\x00\\x02\\xA0\\x23ggml_cuda_set_tensor_split',0,b'\\x00\\x03\\xE3\\x23ggml_cuda_transform_tensor',0,b'\\x00\\x00\\x95\\x23ggml_cycles',0,b'\\x00\\x00\\x95\\x23ggml_cycles_per_ms',0,b'\\x00\\x00\\xFA\\x23ggml_diag',0,b'\\x00\\x01\\x21\\x23ggml_diag_mask_inf',0,b'\\x00\\x01\\x21\\x23ggml_diag_mask_inf_inplace',0,b'\\x00\\x01\\x21\\x23ggml_diag_mask_zero',0,b'\\x00\\x01\\x21\\x23ggml_diag_mask_zero_inplace',0,b'\\x00\\x01\\x84\\x23ggml_div',0,b'\\x00\\x01\\x84\\x23ggml_div_inplace',0,b'\\x00\\x00\\xFA\\x23ggml_dup',0,b'\\x00\\x00\\xFA\\x23ggml_dup_inplace',0,b'\\x00\\x02\\x0B\\x23ggml_dup_tensor',0,b'\\x00\\x02\\x4D\\x23ggml_element_size',0,b'\\x00\\x00\\xFA\\x23ggml_elu',0,b'\\x00\\x00\\xFA\\x23ggml_elu_inplace',0,b'\\x00\\x01\\xA9\\x23ggml_flash_attn',0,b'\\x00\\x01\\xB0\\x23ggml_flash_attn_back',0,b'\\x00\\x01\\xB8\\x23ggml_flash_ff',0,b'\\x00\\x02\\x16\\x23ggml_format_name',0,b'\\x00\\x00\\x6B\\x23ggml_fp16_to_fp32',0,b'\\x00\\x03\\xDB\\x23ggml_fp16_to_fp32_row',0,b'\\x00\\x02\\x62\\x23ggml_fp32_to_fp16',0,b'\\x00\\x02\\xC1\\x23ggml_fp32_to_fp16_row',0,b'\\x00\\x03\\x03\\x23ggml_free',0,b'\\x00\\x00\\x53\\x23ggml_ftype_to_ggml_type',0,b'\\x00\\x00\\xFA\\x23ggml_gelu',0,b'\\x00\\x00\\xFA\\x23ggml_gelu_inplace',0,b'\\x00\\x00\\xFA\\x23ggml_gelu_quick',0,b'\\x00\\x00\\xFA\\x23ggml_gelu_quick_inplace',0,b'\\x00\\x02\\x6C\\x23ggml_get_data',0,b'\\x00\\x00\\x5D\\x23ggml_get_data_f32',0,b'\\x00\\x00\\x63\\x23ggml_get_f32_1d',0,b'\\x00\\x00\\x81\\x23ggml_get_i32_1d',0,b'\\x00\\x02\\x4A\\x23ggml_get_max_tensor_size',0,b'\\x00\\x02\\x69\\x23ggml_get_mem_buffer',0,b'\\x00\\x02\\x4A\\x23ggml_get_mem_size',0,b'\\x00\\x00\\x36\\x23ggml_get_name',0,b'\\x00\\x00\\x0A\\x23ggml_get_no_alloc',0,b'\\x00\\x01\\x84\\x23ggml_get_rows',0,b'\\x00\\x01\\xA3\\x23ggml_get_rows_back',0,b'\\x00\\x00\\xCE\\x23ggml_get_tensor',0,b'\\x00\\x00\\x56\\x23ggml_get_unary_op',0,b'\\x00\\x00\\x77\\x23ggml_graph_compute',0,b'\\x00\\x03\\x0A\\x23ggml_graph_compute_with_ctx',0,b'\\x00\\x02\\xFE\\x23ggml_graph_dump_dot',0,b'\\x00\\x02\\xFA\\x23ggml_graph_export',0,b'\\x00\\x00\\xCA\\x23ggml_graph_get_tensor',0,b'\\x00\\x00\\xAE\\x23ggml_graph_import',0,b'\\x00\\x02\\x60\\x23ggml_graph_overhead',0,b'\\x00\\x00\\xBE\\x23ggml_graph_plan',0,b'\\x00\\x02\\xF7\\x23ggml_graph_print',0,b'\\x00\\x02\\xF0\\x23ggml_graph_reset',0,b'\\x00\\x00\\xBB\\x23ggml_init',0,b'\\x00\\x03\\xEC\\x23ggml_init_cublas',0,b'\\x00\\x00\\x6E\\x23ggml_internal_get_type_traits',0,b'\\x00\\x00\\x14\\x23ggml_is_contiguous',0,b'\\x00\\x00\\x27\\x23ggml_is_numa',0,b'\\x00\\x00\\x14\\x23ggml_is_permuted',0,b'\\x00\\x00\\x00\\x23ggml_is_quantized',0,b'\\x00\\x00\\x14\\x23ggml_is_transposed',0,b'\\x00\\x00\\xFA\\x23ggml_log',0,b'\\x00\\x00\\xFA\\x23ggml_log_inplace',0,b'\\x00\\x01\\xE6\\x23ggml_map_binary_f32',0,b'\\x00\\x01\\xE6\\x23ggml_map_binary_inplace_f32',0,b'\\x00\\x02\\x04\\x23ggml_map_custom1',0,b'\\x00\\x01\\xFF\\x23ggml_map_custom1_f32',0,b'\\x00\\x02\\x04\\x23ggml_map_custom1_inplace',0,b'\\x00\\x01\\xFF\\x23ggml_map_custom1_inplace_f32',0,b'\\x00\\x01\\xF2\\x23ggml_map_custom2',0,b'\\x00\\x01\\xEC\\x23ggml_map_custom2_f32',0,b'\\x00\\x01\\xF2\\x23ggml_map_custom2_inplace',0,b'\\x00\\x01\\xEC\\x23ggml_map_custom2_inplace_f32',0,b'\\x00\\x01\\xC7\\x23ggml_map_custom3',0,b'\\x00\\x01\\xC0\\x23ggml_map_custom3_f32',0,b'\\x00\\x01\\xC7\\x23ggml_map_custom3_inplace',0,b'\\x00\\x01\\xC0\\x23ggml_map_custom3_inplace_f32',0,b'\\x00\\x01\\xFA\\x23ggml_map_unary_f32',0,b'\\x00\\x01\\xFA\\x23ggml_map_unary_inplace_f32',0,b'\\x00\\x00\\xFA\\x23ggml_mean',0,b'\\x00\\x00\\x0D\\x23ggml_metal_add_buffer',0,b'\\x00\\x03\\x1C\\x23ggml_metal_free',0,b'\\x00\\x00\\x71\\x23ggml_metal_get_concur_list',0,b'\\x00\\x03\\x2C\\x23ggml_metal_get_tensor',0,b'\\x00\\x03\\x23\\x23ggml_metal_graph_compute',0,b'\\x00\\x03\\x27\\x23ggml_metal_graph_find_concurrency',0,b'\\x00\\x03\\xE0\\x23ggml_metal_host_free',0,b'\\x00\\x02\\x72\\x23ggml_metal_host_malloc',0,b'\\x00\\x00\\x7B\\x23ggml_metal_if_optimized',0,b'\\x00\\x00\\xC2\\x23ggml_metal_init',0,b'\\x00\\x03\\x1F\\x23ggml_metal_set_n_cb',0,b'\\x00\\x03\\x2C\\x23ggml_metal_set_tensor',0,b'\\x00\\x03\\xEC\\x23ggml_mpi_backend_free',0,b'\\x00\\x03\\xEC\\x23ggml_mpi_backend_init',0,b'\\x00\\x03\\x33\\x23ggml_mpi_eval_init',0,b'\\x00\\x03\\x30\\x23ggml_mpi_free',0,b'\\x00\\x03\\x39\\x23ggml_mpi_graph_compute_post',0,b'\\x00\\x03\\x39\\x23ggml_mpi_graph_compute_pre',0,b'\\x00\\x00\\xC5\\x23ggml_mpi_init',0,b'\\x00\\x00\\x7E\\x23ggml_mpi_rank',0,b'\\x00\\x01\\x84\\x23ggml_mul',0,b'\\x00\\x01\\x84\\x23ggml_mul_inplace',0,b'\\x00\\x01\\x84\\x23ggml_mul_mat',0,b'\\x00\\x02\\x4D\\x23ggml_nbytes',0,b'\\x00\\x02\\x4D\\x23ggml_nbytes_pad',0,b'\\x00\\x02\\x50\\x23ggml_nbytes_split',0,b'\\x00\\x00\\xFA\\x23ggml_neg',0,b'\\x00\\x00\\xFA\\x23ggml_neg_inplace',0,b'\\x00\\x00\\x92\\x23ggml_nelements',0,b'\\x00\\x00\\xF2\\x23ggml_new_f32',0,b'\\x00\\x00\\xA7\\x23ggml_new_graph',0,b'\\x00\\x00\\xF6\\x23ggml_new_i32',0,b'\\x00\\x00\\xD2\\x23ggml_new_tensor',0,b'\\x00\\x00\\xD8\\x23ggml_new_tensor_1d',0,b'\\x00\\x00\\xDD\\x23ggml_new_tensor_2d',0,b'\\x00\\x00\\xE3\\x23ggml_new_tensor_3d',0,b'\\x00\\x00\\xEA\\x23ggml_new_tensor_4d',0,b'\\x00\\x00\\xFA\\x23ggml_norm',0,b'\\x00\\x00\\xFA\\x23ggml_norm_inplace',0,b'\\x00\\x00\\x92\\x23ggml_nrows',0,b'\\x00\\x03\\xEC\\x23ggml_numa_init',0,b'\\x00\\x00\\x2D\\x23ggml_op_name',0,b'\\x00\\x00\\x2D\\x23ggml_op_symbol',0,b'\\x00\\x00\\x4E\\x23ggml_opt',0,b'\\x00\\x00\\xC7\\x23ggml_opt_default_params',0,b'\\x00\\x03\\x0F\\x23ggml_opt_init',0,b'\\x00\\x00\\x42\\x23ggml_opt_resume',0,b'\\x00\\x00\\x47\\x23ggml_opt_resume_g',0,b'\\x00\\x01\\x84\\x23ggml_out_prod',0,b'\\x00\\x01\\x34\\x23ggml_permute',0,b'\\x00\\x00\\xFE\\x23ggml_pool_1d',0,b'\\x00\\x01\\x06\\x23ggml_pool_2d',0,b'\\x00\\x03\\x3E\\x23ggml_print_object',0,b'\\x00\\x03\\x19\\x23ggml_print_objects',0,b'\\x00\\x02\\x33\\x23ggml_quantize_chunk',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q2_K',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q3_K',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q4_0',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q4_1',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q4_K',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q5_0',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q5_1',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q5_K',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q6_K',0,b'\\x00\\x02\\x3B\\x23ggml_quantize_q8_0',0,b'\\x00\\x00\\xFA\\x23ggml_relu',0,b'\\x00\\x00\\xFA\\x23ggml_relu_inplace',0,b'\\x00\\x01\\x84\\x23ggml_repeat',0,b'\\x00\\x01\\x84\\x23ggml_repeat_back',0,b'\\x00\\x01\\x84\\x23ggml_reshape',0,b'\\x00\\x01\\x46\\x23ggml_reshape_1d',0,b'\\x00\\x01\\x4B\\x23ggml_reshape_2d',0,b'\\x00\\x01\\x51\\x23ggml_reshape_3d',0,b'\\x00\\x01\\x58\\x23ggml_reshape_4d',0,b'\\x00\\x01\\x16\\x23ggml_rms_norm',0,b'\\x00\\x01\\x84\\x23ggml_rms_norm_back',0,b'\\x00\\x01\\x16\\x23ggml_rms_norm_inplace',0,b'\\x00\\x01\\x34\\x23ggml_rope',0,b'\\x00\\x01\\x34\\x23ggml_rope_back',0,b'\\x00\\x01\\x3C\\x23ggml_rope_custom',0,b'\\x00\\x01\\x3C\\x23ggml_rope_custom_inplace',0,b'\\x00\\x01\\x34\\x23ggml_rope_inplace',0,b'\\x00\\x01\\x84\\x23ggml_scale',0,b'\\x00\\x01\\x84\\x23ggml_scale_inplace',0,b'\\x00\\x01\\xDD\\x23ggml_set',0,b'\\x00\\x01\\xD0\\x23ggml_set_1d',0,b'\\x00\\x01\\xD0\\x23ggml_set_1d_inplace',0,b'\\x00\\x01\\xD6\\x23ggml_set_2d',0,b'\\x00\\x01\\xD6\\x23ggml_set_2d_inplace',0,b'\\x00\\x02\\x1A\\x23ggml_set_f32',0,b'\\x00\\x03\\x6E\\x23ggml_set_f32_1d',0,b'\\x00\\x02\\x1E\\x23ggml_set_i32',0,b'\\x00\\x03\\x73\\x23ggml_set_i32_1d',0,b'\\x00\\x01\\xDD\\x23ggml_set_inplace',0,b'\\x00\\x02\\x12\\x23ggml_set_name',0,b'\\x00\\x03\\x06\\x23ggml_set_no_alloc',0,b'\\x00\\x03\\x15\\x23ggml_set_param',0,b'\\x00\\x02\\x46\\x23ggml_set_scratch',0,b'\\x00\\x02\\x0F\\x23ggml_set_zero',0,b'\\x00\\x00\\xFA\\x23ggml_sgn',0,b'\\x00\\x00\\xFA\\x23ggml_sgn_inplace',0,b'\\x00\\x00\\xFA\\x23ggml_silu',0,b'\\x00\\x01\\x84\\x23ggml_silu_back',0,b'\\x00\\x00\\xFA\\x23ggml_silu_inplace',0,b'\\x00\\x00\\xFA\\x23ggml_soft_max',0,b'\\x00\\x01\\x84\\x23ggml_soft_max_back',0,b'\\x00\\x01\\x84\\x23ggml_soft_max_back_inplace',0,b'\\x00\\x00\\xFA\\x23ggml_soft_max_inplace',0,b'\\x00\\x00\\xFA\\x23ggml_sqr',0,b'\\x00\\x00\\xFA\\x23ggml_sqr_inplace',0,b'\\x00\\x00\\xFA\\x23ggml_sqrt',0,b'\\x00\\x00\\xFA\\x23ggml_sqrt_inplace',0,b'\\x00\\x00\\xFA\\x23ggml_step',0,b'\\x00\\x00\\xFA\\x23ggml_step_inplace',0,b'\\x00\\x01\\x84\\x23ggml_sub',0,b'\\x00\\x01\\x84\\x23ggml_sub_inplace',0,b'\\x00\\x00\\xFA\\x23ggml_sum',0,b'\\x00\\x00\\xFA\\x23ggml_sum_rows',0,b'\\x00\\x00\\xFA\\x23ggml_tanh',0,b'\\x00\\x00\\xFA\\x23ggml_tanh_inplace',0,b'\\x00\\x02\\x60\\x23ggml_tensor_overhead',0,b'\\x00\\x03\\xEC\\x23ggml_time_init',0,b'\\x00\\x00\\x95\\x23ggml_time_ms',0,b'\\x00\\x00\\x95\\x23ggml_time_us',0,b'\\x00\\x00\\xFA\\x23ggml_transpose',0,b'\\x00\\x00\\x30\\x23ggml_type_name',0,b'\\x00\\x02\\x30\\x23ggml_type_size',0,b'\\x00\\x00\\x60\\x23ggml_type_sizef',0,b'\\x00\\x01\\x11\\x23ggml_unary',0,b'\\x00\\x01\\x11\\x23ggml_unary_inplace',0,b'\\x00\\x02\\x4A\\x23ggml_used_mem',0,b'\\x00\\x02\\xDE\\x23ggml_vec_dot_q2_K_q8_K',0,b'\\x00\\x02\\xDE\\x23ggml_vec_dot_q3_K_q8_K',0,b'\\x00\\x02\\xDE\\x23ggml_vec_dot_q4_K_q8_K',0,b'\\x00\\x02\\xDE\\x23ggml_vec_dot_q5_K_q8_K',0,b'\\x00\\x02\\xDE\\x23ggml_vec_dot_q6_K_q8_K',0,b'\\x00\\x01\\x7E\\x23ggml_view_1d',0,b'\\x00\\x01\\x76\\x23ggml_view_2d',0,b'\\x00\\x01\\x6C\\x23ggml_view_3d',0,b'\\x00\\x01\\x60\\x23ggml_view_4d',0,b'\\x00\\x02\\x0B\\x23ggml_view_tensor',0,b'\\x00\\x01\\x21\\x23ggml_win_part',0,b'\\x00\\x01\\x2D\\x23ggml_win_unpart',0,b'\\x00\\x03\\xCC\\x23gguf_add_tensor',0,b'\\x00\\x00\\x88\\x23gguf_find_key',0,b'\\x00\\x00\\x88\\x23gguf_find_tensor',0,b'\\x00\\x03\\x84\\x23gguf_free',0,b'\\x00\\x02\\x59\\x23gguf_get_alignment',0,b'\\x00\\x02\\x75\\x23gguf_get_arr_data',0,b'\\x00\\x00\\x8C\\x23gguf_get_arr_n',0,b'\\x00\\x00\\x3D\\x23gguf_get_arr_str',0,b'\\x00\\x00\\x59\\x23gguf_get_arr_type',0,b'\\x00\\x02\\x6F\\x23gguf_get_data',0,b'\\x00\\x02\\x59\\x23gguf_get_data_offset',0,b'\\x00\\x00\\x39\\x23gguf_get_key',0,b'\\x00\\x00\\x59\\x23gguf_get_kv_type',0,b'\\x00\\x03\\xD4\\x23gguf_get_meta_data',0,b'\\x00\\x02\\x59\\x23gguf_get_meta_size',0,b'\\x00\\x00\\x85\\x23gguf_get_n_kv',0,b'\\x00\\x00\\x85\\x23gguf_get_n_tensors',0,b'\\x00\\x00\\x29\\x23gguf_get_tensor_name',0,b'\\x00\\x02\\x5C\\x23gguf_get_tensor_offset',0,b'\\x00\\x00\\x20\\x23gguf_get_val_bool',0,b'\\x00\\x00\\x67\\x23gguf_get_val_f32',0,b'\\x00\\x00\\x97\\x23gguf_get_val_i16',0,b'\\x00\\x00\\x8C\\x23gguf_get_val_i32',0,b'\\x00\\x00\\x9B\\x23gguf_get_val_i8',0,b'\\x00\\x00\\x39\\x23gguf_get_val_str',0,b'\\x00\\x02\\x65\\x23gguf_get_val_u16',0,b'\\x00\\x02\\x2C\\x23gguf_get_val_u32',0,b'\\x00\\x02\\x28\\x23gguf_get_val_u8',0,b'\\x00\\x00\\x85\\x23gguf_get_version',0,b'\\x00\\x02\\x26\\x23gguf_init_empty',0,b'\\x00\\x02\\x22\\x23gguf_init_from_file',0,b'\\x00\\x03\\x9C\\x23gguf_set_arr_data',0,b'\\x00\\x03\\x8C\\x23gguf_set_arr_str',0,b'\\x00\\x03\\xD0\\x23gguf_set_kv',0,b'\\x00\\x03\\xC6\\x23gguf_set_tensor_data',0,b'\\x00\\x03\\x97\\x23gguf_set_tensor_type',0,b'\\x00\\x03\\x87\\x23gguf_set_val_bool',0,b'\\x00\\x03\\xA3\\x23gguf_set_val_f32',0,b'\\x00\\x03\\xAD\\x23gguf_set_val_i16',0,b'\\x00\\x03\\xA8\\x23gguf_set_val_i32',0,b'\\x00\\x03\\xB2\\x23gguf_set_val_i8',0,b'\\x00\\x03\\x92\\x23gguf_set_val_str',0,b'\\x00\\x03\\xC1\\x23gguf_set_val_u16',0,b'\\x00\\x03\\xBC\\x23gguf_set_val_u32',0,b'\\x00\\x03\\xB7\\x23gguf_set_val_u8',0,b'\\x00\\x00\\x33\\x23gguf_type_name',0,b'\\x00\\x03\\x87\\x23gguf_write_to_file',0,b'\\x00\\x02\\xC6\\x23quantize_row_q2_K',0,b'\\x00\\x02\\xA3\\x23quantize_row_q2_K_reference',0,b'\\x00\\x02\\xC6\\x23quantize_row_q3_K',0,b'\\x00\\x02\\xA8\\x23quantize_row_q3_K_reference',0,b'\\x00\\x02\\xC6\\x23quantize_row_q4_K',0,b'\\x00\\x02\\xAD\\x23quantize_row_q4_K_reference',0,b'\\x00\\x02\\xC6\\x23quantize_row_q5_K',0,b'\\x00\\x02\\xB2\\x23quantize_row_q5_K_reference',0,b'\\x00\\x02\\xC6\\x23quantize_row_q6_K',0,b'\\x00\\x02\\xB7\\x23quantize_row_q6_K_reference',0,b'\\x00\\x02\\xC6\\x23quantize_row_q8_K',0,b'\\x00\\x02\\xBC\\x23quantize_row_q8_K_reference',0),\n    _struct_unions = ((b'\\x00\\x00\\x04\\x27\\x00\\x00\\x00\\x02$1',b'\\x00\\x00\\x22\\x11n_iter',b'\\x00\\x00\\xF4\\x11sched',b'\\x00\\x00\\xF4\\x11decay',b'\\x00\\x00\\xF4\\x11alpha',b'\\x00\\x00\\xF4\\x11beta1',b'\\x00\\x00\\xF4\\x11beta2',b'\\x00\\x00\\xF4\\x11eps',b'\\x00\\x00\\xF4\\x11eps_f',b'\\x00\\x00\\xF4\\x11eps_g'),(b'\\x00\\x00\\x04\\x28\\x00\\x00\\x00\\x02$2',b'\\x00\\x00\\x22\\x11m',b'\\x00\\x00\\x22\\x11n_iter',b'\\x00\\x00\\x22\\x11max_linesearch',b'\\x00\\x00\\xF4\\x11eps',b'\\x00\\x00\\xF4\\x11ftol',b'\\x00\\x00\\xF4\\x11wolfe',b'\\x00\\x00\\xF4\\x11min_step',b'\\x00\\x00\\xF4\\x11max_step',b'\\x00\\x04\\x14\\x11linesearch'),(b'\\x00\\x00\\x04\\x29\\x00\\x00\\x00\\x02$3',b'\\x00\\x00\\x08\\x11x',b'\\x00\\x00\\x08\\x11g1',b'\\x00\\x00\\x08\\x11g2',b'\\x00\\x00\\x08\\x11m',b'\\x00\\x00\\x08\\x11v',b'\\x00\\x00\\x08\\x11mh',b'\\x00\\x00\\x08\\x11vh',b'\\x00\\x00\\x08\\x11pf',b'\\x00\\x00\\xF4\\x11fx_best',b'\\x00\\x00\\xF4\\x11fx_prev',b'\\x00\\x00\\x22\\x11n_no_improvement'),(b'\\x00\\x00\\x04\\x2A\\x00\\x00\\x00\\x02$4',b'\\x00\\x00\\x08\\x11x',b'\\x00\\x00\\x08\\x11xp',b'\\x00\\x00\\x08\\x11g',b'\\x00\\x00\\x08\\x11gp',b'\\x00\\x00\\x08\\x11d',b'\\x00\\x00\\x08\\x11pf',b'\\x00\\x00\\x08\\x11lmal',b'\\x00\\x00\\x08\\x11lmys',b'\\x00\\x00\\x08\\x11lms',b'\\x00\\x00\\x08\\x11lmy',b'\\x00\\x00\\xF4\\x11fx_best',b'\\x00\\x00\\xF4\\x11step',b'\\x00\\x00\\x22\\x11j',b'\\x00\\x00\\x22\\x11k',b'\\x00\\x00\\x22\\x11end',b'\\x00\\x00\\x22\\x11n_no_improvement'),(b'\\x00\\x00\\x03\\xF7\\x00\\x00\\x00\\x03$__mbstate_t',b'\\x00\\x03\\xFF\\x11__mbstate8',b'\\x00\\x00\\xDB\\x11_mbstateL'),(b'\\x00\\x00\\x03\\xF8\\x00\\x00\\x00\\x02$block_q2_K',b'\\x00\\x04\\x44\\x11scales',b'\\x00\\x04\\x48\\x11qs',b'\\x00\\x00\\x6C\\x11d',b'\\x00\\x00\\x6C\\x11dmin'),(b'\\x00\\x00\\x03\\xF9\\x00\\x00\\x00\\x02$block_q3_K',b'\\x00\\x04\\x46\\x11hmask',b'\\x00\\x04\\x48\\x11qs',b'\\x00\\x04\\x42\\x11scales',b'\\x00\\x00\\x6C\\x11d'),(b'\\x00\\x00\\x03\\xFA\\x00\\x00\\x00\\x02$block_q4_K',b'\\x00\\x00\\x6C\\x11d',b'\\x00\\x00\\x6C\\x11dmin',b'\\x00\\x04\\x42\\x11scales',b'\\x00\\x04\\x40\\x11qs'),(b'\\x00\\x00\\x03\\xFB\\x00\\x00\\x00\\x02$block_q5_K',b'\\x00\\x00\\x6C\\x11d',b'\\x00\\x00\\x6C\\x11dmin',b'\\x00\\x04\\x42\\x11scales',b'\\x00\\x04\\x46\\x11qh',b'\\x00\\x04\\x40\\x11qs'),(b'\\x00\\x00\\x03\\xFC\\x00\\x00\\x00\\x02$block_q6_K',b'\\x00\\x04\\x40\\x11ql',b'\\x00\\x04\\x48\\x11qh',b'\\x00\\x04\\x23\\x11scales',b'\\x00\\x00\\x6C\\x11d'),(b'\\x00\\x00\\x03\\xFD\\x00\\x00\\x00\\x02$block_q8_K',b'\\x00\\x00\\xF4\\x11d',b'\\x00\\x04\\x25\\x11qs',b'\\x00\\x04\\x21\\x11bsums'),(b'\\x00\\x00\\x04\\x18\\x00\\x00\\x00\\x02$ggml_type_traits_t',b'\\x00\\x00\\x0F\\x11type_name',b'\\x00\\x00\\x22\\x11blck_size',b'\\x00\\x00\\x11\\x11type_size',b'\\x00\\x00\\xB6\\x11is_quantized',b'\\x00\\x04\\x52\\x11to_float',b'\\x00\\x04\\x4F\\x11from_float',b'\\x00\\x04\\x4F\\x11from_float_reference',b'\\x00\\x04\\x50\\x11vec_dot',b'\\x00\\x00\\x01\\x11vec_dot_type'),(b'\\x00\\x00\\x04\\x2C\\x00\\x00\\x00\\x02__darwin_pthread_handler_rec',b'\\x00\\x04\\x51\\x11__routine',b'\\x00\\x00\\x10\\x11__arg',b'\\x00\\x04\\x2B\\x11__next'),(b'\\x00\\x00\\x03\\xEF\\x00\\x00\\x00\\x02_opaque_pthread_attr_t',b'\\x00\\x04\\x20\\x11__sig',b'\\x00\\x04\\x0B\\x11__opaque'),(b'\\x00\\x00\\x03\\xF0\\x00\\x00\\x00\\x02_opaque_pthread_cond_t',b'\\x00\\x04\\x20\\x11__sig',b'\\x00\\x04\\x07\\x11__opaque'),(b'\\x00\\x00\\x03\\xF1\\x00\\x00\\x00\\x02_opaque_pthread_condattr_t',b'\\x00\\x04\\x20\\x11__sig',b'\\x00\\x04\\x11\\x11__opaque'),(b'\\x00\\x00\\x03\\xF2\\x00\\x00\\x00\\x02_opaque_pthread_mutex_t',b'\\x00\\x04\\x20\\x11__sig',b'\\x00\\x04\\x0B\\x11__opaque'),(b'\\x00\\x00\\x03\\xF3\\x00\\x00\\x00\\x02_opaque_pthread_mutexattr_t',b'\\x00\\x04\\x20\\x11__sig',b'\\x00\\x04\\x11\\x11__opaque'),(b'\\x00\\x00\\x03\\xF4\\x00\\x00\\x00\\x02_opaque_pthread_once_t',b'\\x00\\x04\\x20\\x11__sig',b'\\x00\\x04\\x11\\x11__opaque'),(b'\\x00\\x00\\x03\\xF5\\x00\\x00\\x00\\x02_opaque_pthread_rwlock_t',b'\\x00\\x04\\x20\\x11__sig',b'\\x00\\x04\\x03\\x11__opaque'),(b'\\x00\\x00\\x03\\xF6\\x00\\x00\\x00\\x02_opaque_pthread_rwlockattr_t',b'\\x00\\x04\\x20\\x11__sig',b'\\x00\\x04\\x01\\x11__opaque'),(b'\\x00\\x00\\x04\\x2E\\x00\\x00\\x00\\x02_opaque_pthread_t',b'\\x00\\x04\\x20\\x11__sig',b'\\x00\\x04\\x2B\\x11__cleanup_stack',b'\\x00\\x04\\x0F\\x11__opaque'),(b'\\x00\\x00\\x04\\x2F\\x00\\x00\\x00\\x10ggml_allocr',),(b'\\x00\\x00\\x04\\x30\\x00\\x00\\x00\\x02ggml_cgraph',b'\\x00\\x00\\x22\\x11n_nodes',b'\\x00\\x00\\x22\\x11n_leafs',b'\\x00\\x04\\x39\\x11nodes',b'\\x00\\x04\\x39\\x11grads',b'\\x00\\x04\\x39\\x11leafs',b'\\x00\\x04\\x4D\\x11visited_hash_table',b'\\x00\\x00\\x22\\x11perf_runs',b'\\x00\\x00\\xDB\\x11perf_cycles',b'\\x00\\x00\\xDB\\x11perf_time_us'),(b'\\x00\\x00\\x04\\x31\\x00\\x00\\x00\\x02ggml_compute_params',b'\\x00\\x04\\x17\\x11type',b'\\x00\\x00\\x22\\x11ith',b'\\x00\\x00\\x22\\x11nth',b'\\x00\\x00\\x11\\x11wsize',b'\\x00\\x00\\x10\\x11wdata'),(b'\\x00\\x00\\x04\\x32\\x00\\x00\\x00\\x10ggml_context',),(b'\\x00\\x00\\x04\\x33\\x00\\x00\\x00\\x02ggml_cplan',b'\\x00\\x00\\x11\\x11work_size',b'\\x00\\x04\\x3F\\x11work_data',b'\\x00\\x00\\x22\\x11n_threads',b'\\x00\\x04\\x19\\x11n_tasks',b'\\x00\\x03\\xEE\\x11abort_callback',b'\\x00\\x00\\x10\\x11abort_callback_data'),(b'\\x00\\x00\\x00\\xBC\\x00\\x00\\x00\\x02ggml_init_params',b'\\x00\\x00\\x11\\x11mem_size',b'\\x00\\x00\\x10\\x11mem_buffer',b'\\x00\\x00\\xB6\\x11no_alloc'),(b'\\x00\\x00\\x04\\x34\\x00\\x00\\x00\\x10ggml_metal_context',),(b'\\x00\\x00\\x04\\x35\\x00\\x00\\x00\\x10ggml_mpi_context',),(b'\\x00\\x00\\x04\\x37\\x00\\x00\\x00\\x02ggml_object',b'\\x00\\x00\\x11\\x11offs',b'\\x00\\x00\\x11\\x11size',b'\\x00\\x04\\x36\\x11next',b'\\x00\\x04\\x15\\x11type',b'\\x00\\x04\\x09\\x11padding'),(b'\\x00\\x00\\x04\\x38\\x00\\x00\\x00\\x02ggml_opt_context',b'\\x00\\x00\\x0B\\x11ctx',b'\\x00\\x00\\x50\\x11params',b'\\x00\\x00\\x22\\x11iter',b'\\x00\\x00\\xDB\\x11nx',b'\\x00\\x00\\xB6\\x11just_initialized',b'\\x00\\x04\\x29\\x11adam',b'\\x00\\x04\\x2A\\x11lbfgs'),(b'\\x00\\x00\\x00\\x50\\x00\\x00\\x00\\x02ggml_opt_params',b'\\x00\\x00\\xC8\\x11type',b'\\x00\\x00\\x22\\x11n_threads',b'\\x00\\x00\\x22\\x11past',b'\\x00\\x00\\xF4\\x11delta',b'\\x00\\x00\\x22\\x11max_no_improvement',b'\\x00\\x00\\xB6\\x11print_forward_graph',b'\\x00\\x00\\xB6\\x11print_backward_graph',b'\\x00\\x04\\x27\\x11adam',b'\\x00\\x04\\x28\\x11lbfgs'),(b'\\x00\\x00\\x02\\x48\\x00\\x00\\x00\\x02ggml_scratch',b'\\x00\\x00\\x11\\x11offs',b'\\x00\\x00\\x11\\x11size',b'\\x00\\x00\\x10\\x11data'),(b'\\x00\\x00\\x04\\x3D\\x00\\x00\\x00\\x02ggml_tensor',b'\\x00\\x00\\x01\\x11type',b'\\x00\\x04\\x13\\x11backend',b'\\x00\\x00\\x22\\x11n_dims',b'\\x00\\x04\\x1E\\x11ne',b'\\x00\\x04\\x4B\\x11nb',b'\\x00\\x00\\x2E\\x11op',b'\\x00\\x04\\x1B\\x11op_params',b'\\x00\\x00\\xB6\\x11is_param',b'\\x00\\x00\\x08\\x11grad',b'\\x00\\x04\\x3B\\x11src',b'\\x00\\x00\\x22\\x11perf_runs',b'\\x00\\x00\\xDB\\x11perf_cycles',b'\\x00\\x00\\xDB\\x11perf_time_us',b'\\x00\\x00\\x10\\x11data',b'\\x00\\x04\\x0D\\x11name',b'\\x00\\x00\\x10\\x11extra',b'\\x00\\x04\\x09\\x11padding'),(b'\\x00\\x00\\x04\\x3E\\x00\\x00\\x00\\x10gguf_context',),(b'\\x00\\x00\\x02\\x24\\x00\\x00\\x00\\x02gguf_init_params',b'\\x00\\x00\\xB6\\x11no_alloc',b'\\x00\\x00\\xB0\\x11ctx')),\n    _enums = (b'\\x00\\x00\\x04\\x13\\x00\\x00\\x00\\x16ggml_backend\\x00GGML_BACKEND_CPU,GGML_BACKEND_GPU,GGML_BACKEND_GPU_SPLIT',b'\\x00\\x00\\x00\\x54\\x00\\x00\\x00\\x15ggml_ftype\\x00GGML_FTYPE_UNKNOWN,GGML_FTYPE_ALL_F32,GGML_FTYPE_MOSTLY_F16,GGML_FTYPE_MOSTLY_Q4_0,GGML_FTYPE_MOSTLY_Q4_1,GGML_FTYPE_MOSTLY_Q4_1_SOME_F16,GGML_FTYPE_MOSTLY_Q8_0,GGML_FTYPE_MOSTLY_Q5_0,GGML_FTYPE_MOSTLY_Q5_1,GGML_FTYPE_MOSTLY_Q2_K,GGML_FTYPE_MOSTLY_Q3_K,GGML_FTYPE_MOSTLY_Q4_K,GGML_FTYPE_MOSTLY_Q5_K,GGML_FTYPE_MOSTLY_Q6_K',b'\\x00\\x00\\x04\\x14\\x00\\x00\\x00\\x16ggml_linesearch\\x00GGML_LINESEARCH_DEFAULT,GGML_LINESEARCH_BACKTRACKING_ARMIJO,GGML_LINESEARCH_BACKTRACKING_WOLFE,GGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE',b'\\x00\\x00\\x04\\x15\\x00\\x00\\x00\\x16ggml_object_type\\x00GGML_OBJECT_TENSOR,GGML_OBJECT_GRAPH,GGML_OBJECT_WORK_BUFFER',b'\\x00\\x00\\x00\\x2E\\x00\\x00\\x00\\x16ggml_op\\x00GGML_OP_NONE,GGML_OP_DUP,GGML_OP_ADD,GGML_OP_ADD1,GGML_OP_ACC,GGML_OP_SUB,GGML_OP_MUL,GGML_OP_DIV,GGML_OP_SQR,GGML_OP_SQRT,GGML_OP_LOG,GGML_OP_SUM,GGML_OP_SUM_ROWS,GGML_OP_MEAN,GGML_OP_ARGMAX,GGML_OP_REPEAT,GGML_OP_REPEAT_BACK,GGML_OP_SILU_BACK,GGML_OP_NORM,GGML_OP_RMS_NORM,GGML_OP_RMS_NORM_BACK,GGML_OP_MUL_MAT,GGML_OP_OUT_PROD,GGML_OP_SCALE,GGML_OP_SET,GGML_OP_CPY,GGML_OP_CONT,GGML_OP_RESHAPE,GGML_OP_VIEW,GGML_OP_PERMUTE,GGML_OP_TRANSPOSE,GGML_OP_GET_ROWS,GGML_OP_GET_ROWS_BACK,GGML_OP_DIAG,GGML_OP_DIAG_MASK_INF,GGML_OP_DIAG_MASK_ZERO,GGML_OP_SOFT_MAX,GGML_OP_SOFT_MAX_BACK,GGML_OP_ROPE,GGML_OP_ROPE_BACK,GGML_OP_ALIBI,GGML_OP_CLAMP,GGML_OP_CONV_1D,GGML_OP_CONV_2D,GGML_OP_POOL_1D,GGML_OP_POOL_2D,GGML_OP_FLASH_ATTN,GGML_OP_FLASH_FF,GGML_OP_FLASH_ATTN_BACK,GGML_OP_WIN_PART,GGML_OP_WIN_UNPART,GGML_OP_UNARY,GGML_OP_MAP_UNARY,GGML_OP_MAP_BINARY,GGML_OP_MAP_CUSTOM1_F32,GGML_OP_MAP_CUSTOM2_F32,GGML_OP_MAP_CUSTOM3_F32,GGML_OP_MAP_CUSTOM1,GGML_OP_MAP_CUSTOM2,GGML_OP_MAP_CUSTOM3,GGML_OP_CROSS_ENTROPY_LOSS,GGML_OP_CROSS_ENTROPY_LOSS_BACK,GGML_OP_COUNT',b'\\x00\\x00\\x01\\x01\\x00\\x00\\x00\\x16ggml_op_pool\\x00GGML_OP_POOL_MAX,GGML_OP_POOL_AVG,GGML_OP_POOL_COUNT',b'\\x00\\x00\\x04\\x16\\x00\\x00\\x00\\x15ggml_opt_result\\x00GGML_OPT_OK,GGML_OPT_DID_NOT_CONVERGE,GGML_OPT_NO_CONTEXT,GGML_OPT_INVALID_WOLFE,GGML_OPT_FAIL,GGML_LINESEARCH_FAIL,GGML_LINESEARCH_MINIMUM_STEP,GGML_LINESEARCH_MAXIMUM_STEP,GGML_LINESEARCH_MAXIMUM_ITERATIONS,GGML_LINESEARCH_INVALID_PARAMETERS',b'\\x00\\x00\\x00\\xC8\\x00\\x00\\x00\\x16ggml_opt_type\\x00GGML_OPT_ADAM,GGML_OPT_LBFGS',b'\\x00\\x00\\x04\\x17\\x00\\x00\\x00\\x16ggml_task_type\\x00GGML_TASK_INIT,GGML_TASK_COMPUTE,GGML_TASK_FINALIZE',b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x16ggml_type\\x00GGML_TYPE_F32,GGML_TYPE_F16,GGML_TYPE_Q4_0,GGML_TYPE_Q4_1,GGML_TYPE_Q5_0,GGML_TYPE_Q5_1,GGML_TYPE_Q8_0,GGML_TYPE_Q8_1,GGML_TYPE_Q2_K,GGML_TYPE_Q3_K,GGML_TYPE_Q4_K,GGML_TYPE_Q5_K,GGML_TYPE_Q6_K,GGML_TYPE_Q8_K,GGML_TYPE_I8,GGML_TYPE_I16,GGML_TYPE_I32,GGML_TYPE_COUNT',b'\\x00\\x00\\x01\\x14\\x00\\x00\\x00\\x16ggml_unary_op\\x00GGML_UNARY_OP_ABS,GGML_UNARY_OP_SGN,GGML_UNARY_OP_NEG,GGML_UNARY_OP_STEP,GGML_UNARY_OP_TANH,GGML_UNARY_OP_ELU,GGML_UNARY_OP_RELU,GGML_UNARY_OP_GELU,GGML_UNARY_OP_GELU_QUICK,GGML_UNARY_OP_SILU',b'\\x00\\x00\\x00\\x34\\x00\\x00\\x00\\x16gguf_type\\x00GGUF_TYPE_UINT8,GGUF_TYPE_INT8,GGUF_TYPE_UINT16,GGUF_TYPE_INT16,GGUF_TYPE_UINT32,GGUF_TYPE_INT32,GGUF_TYPE_FLOAT32,GGUF_TYPE_BOOL,GGUF_TYPE_STRING,GGUF_TYPE_ARRAY,GGUF_TYPE_COUNT'),\n    _typenames = (b'\\x00\\x00\\x00\\xDB__darwin_blkcnt_t',b'\\x00\\x00\\x00\\x22__darwin_blksize_t',b'\\x00\\x00\\x00\\x11__darwin_clock_t',b'\\x00\\x00\\x00\\x22__darwin_ct_rune_t',b'\\x00\\x00\\x00\\x22__darwin_dev_t',b'\\x00\\x00\\x03\\xBF__darwin_fsblkcnt_t',b'\\x00\\x00\\x03\\xBF__darwin_fsfilcnt_t',b'\\x00\\x00\\x03\\xBF__darwin_gid_t',b'\\x00\\x00\\x03\\xBF__darwin_id_t',b'\\x00\\x00\\x04\\x4A__darwin_ino64_t',b'\\x00\\x00\\x04\\x4A__darwin_ino_t',b'\\x00\\x00\\x04\\x20__darwin_intptr_t',b'\\x00\\x00\\x03\\xBF__darwin_mach_port_name_t',b'\\x00\\x00\\x03\\xBF__darwin_mach_port_t',b'\\x00\\x00\\x03\\xF7__darwin_mbstate_t',b'\\x00\\x00\\x00\\x6C__darwin_mode_t',b'\\x00\\x00\\x03\\xBF__darwin_natural_t',b'\\x00\\x00\\x00\\xDB__darwin_off_t',b'\\x00\\x00\\x00\\x22__darwin_pid_t',b'\\x00\\x00\\x03\\xEF__darwin_pthread_attr_t',b'\\x00\\x00\\x03\\xF0__darwin_pthread_cond_t',b'\\x00\\x00\\x03\\xF1__darwin_pthread_condattr_t',b'\\x00\\x00\\x00\\x11__darwin_pthread_key_t',b'\\x00\\x00\\x03\\xF2__darwin_pthread_mutex_t',b'\\x00\\x00\\x03\\xF3__darwin_pthread_mutexattr_t',b'\\x00\\x00\\x03\\xF4__darwin_pthread_once_t',b'\\x00\\x00\\x03\\xF5__darwin_pthread_rwlock_t',b'\\x00\\x00\\x03\\xF6__darwin_pthread_rwlockattr_t',b'\\x00\\x00\\x04\\x2D__darwin_pthread_t',b'\\x00\\x00\\x04\\x20__darwin_ptrdiff_t',b'\\x00\\x00\\x00\\x22__darwin_rune_t',b'\\x00\\x00\\x03\\xBF__darwin_sigset_t',b'\\x00\\x00\\x00\\x11__darwin_size_t',b'\\x00\\x00\\x03\\xBF__darwin_socklen_t',b'\\x00\\x00\\x04\\x20__darwin_ssize_t',b'\\x00\\x00\\x00\\x22__darwin_suseconds_t',b'\\x00\\x00\\x04\\x20__darwin_time_t',b'\\x00\\x00\\x03\\xBF__darwin_uid_t',b'\\x00\\x00\\x03\\xBF__darwin_useconds_t',b'\\x00\\x00\\x04\\x05__darwin_uuid_string_t',b'\\x00\\x00\\x04\\x44__darwin_uuid_t',b'\\x00\\x00\\x00\\x22__darwin_wchar_t',b'\\x00\\x00\\x00\\x22__darwin_wint_t',b'\\x00\\x00\\x03\\xB0__int16_t',b'\\x00\\x00\\x00\\x22__int32_t',b'\\x00\\x00\\x00\\xDB__int64_t',b'\\x00\\x00\\x03\\xB5__int8_t',b'\\x00\\x00\\x03\\xF7__mbstate_t',b'\\x00\\x00\\x00\\x6C__uint16_t',b'\\x00\\x00\\x03\\xBF__uint32_t',b'\\x00\\x00\\x04\\x4A__uint64_t',b'\\x00\\x00\\x03\\xBA__uint8_t',b'\\x00\\x00\\x03\\xF8block_q2_K',b'\\x00\\x00\\x03\\xF9block_q3_K',b'\\x00\\x00\\x03\\xFAblock_q4_K',b'\\x00\\x00\\x03\\xFBblock_q5_K',b'\\x00\\x00\\x03\\xFCblock_q6_K',b'\\x00\\x00\\x03\\xFDblock_q8_K',b'\\x00\\x00\\x01\\xEAggml_binary_op_f32_t',b'\\x00\\x00\\x02\\x02ggml_custom1_op_f32_t',b'\\x00\\x00\\x02\\x07ggml_custom1_op_t',b'\\x00\\x00\\x01\\xF0ggml_custom2_op_f32_t',b'\\x00\\x00\\x01\\xF6ggml_custom2_op_t',b'\\x00\\x00\\x01\\xC5ggml_custom3_op_f32_t',b'\\x00\\x00\\x01\\xCCggml_custom3_op_t',b'\\x00\\x00\\x00\\x6Cggml_fp16_t',b'\\x00\\x00\\x04\\x4Fggml_from_float_t',b'\\x00\\x00\\x04\\x52ggml_to_float_t',b'\\x00\\x00\\x04\\x18ggml_type_traits_t',b'\\x00\\x00\\x01\\xFDggml_unary_op_f32_t',b'\\x00\\x00\\x04\\x50ggml_vec_dot_t',b'\\x00\\x00\\x03\\xB0int16_t',b'\\x00\\x00\\x00\\x22int32_t',b'\\x00\\x00\\x00\\xDBint64_t',b'\\x00\\x00\\x03\\xB5int8_t',b'\\x00\\x00\\x03\\xB0int_fast16_t',b'\\x00\\x00\\x00\\x22int_fast32_t',b'\\x00\\x00\\x00\\xDBint_fast64_t',b'\\x00\\x00\\x03\\xB5int_fast8_t',b'\\x00\\x00\\x03\\xB0int_least16_t',b'\\x00\\x00\\x00\\x22int_least32_t',b'\\x00\\x00\\x00\\xDBint_least64_t',b'\\x00\\x00\\x03\\xB5int_least8_t',b'\\x00\\x00\\x04\\x20intmax_t',b'\\x00\\x00\\x04\\x20intptr_t',b'\\x00\\x00\\x04\\x1Dmax_align_t',b'\\x00\\x00\\x04\\x20ptrdiff_t',b'\\x00\\x00\\x00\\xDBregister_t',b'\\x00\\x00\\x00\\x11rsize_t',b'\\x00\\x00\\x00\\x11size_t',b'\\x00\\x00\\x04\\x4Asyscall_arg_t',b'\\x00\\x00\\x00\\x6Cu_int16_t',b'\\x00\\x00\\x03\\xBFu_int32_t',b'\\x00\\x00\\x04\\x4Au_int64_t',b'\\x00\\x00\\x03\\xBAu_int8_t',b'\\x00\\x00\\x00\\x6Cuint16_t',b'\\x00\\x00\\x03\\xBFuint32_t',b'\\x00\\x00\\x04\\x4Auint64_t',b'\\x00\\x00\\x03\\xBAuint8_t',b'\\x00\\x00\\x00\\x6Cuint_fast16_t',b'\\x00\\x00\\x03\\xBFuint_fast32_t',b'\\x00\\x00\\x04\\x4Auint_fast64_t',b'\\x00\\x00\\x03\\xBAuint_fast8_t',b'\\x00\\x00\\x00\\x6Cuint_least16_t',b'\\x00\\x00\\x03\\xBFuint_least32_t',b'\\x00\\x00\\x04\\x4Auint_least64_t',b'\\x00\\x00\\x03\\xBAuint_least8_t',b'\\x00\\x00\\x00\\x11uintmax_t',b'\\x00\\x00\\x00\\x11uintptr_t',b'\\x00\\x00\\x04\\x4Auser_addr_t',b'\\x00\\x00\\x00\\xDBuser_long_t',b'\\x00\\x00\\x00\\xDBuser_off_t',b'\\x00\\x00\\x04\\x4Auser_size_t',b'\\x00\\x00\\x00\\xDBuser_ssize_t',b'\\x00\\x00\\x00\\xDBuser_time_t',b'\\x00\\x00\\x04\\x4Auser_ulong_t',b'\\x00\\x00\\x00\\x22wchar_t'),\n)",
        "detail": "lib.seamless_communication.ggml.examples.python.ggml.cffi",
        "documentation": {}
    },
    {
        "label": "init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "description": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "peekOfCode": "def init(mem_size: int, mem_buffer: ffi.CData = ffi.NULL, no_alloc: bool = False) -> ffi.CData:\n    \"\"\"\n      Initialize a ggml context, which will be freed automatically when the pointer is garbage collected.\n    \"\"\"\n    params = ffi.new('struct ggml_init_params*')\n    params.mem_size = mem_size\n    params.mem_buffer = mem_buffer\n    params.no_alloc = no_alloc\n    return ffi.gc(lib.ggml_init(params[0]), lib.ggml_free)\nTensorLike = Union[ffi.CData, np.ndarray]",
        "detail": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "description": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "peekOfCode": "def copy(from_tensor: TensorLike, to_tensor: TensorLike, allow_requantize: bool = True):\n    \"\"\"\n      Copy the contents of one tensor to another, doing any necessary (de/re)quantization transparently.\n      Works across numpy & ggml tensors, but they must have the same shape (and be contiguous).\n      Parameters\n      ----------\n      from_tensor : TensorLike\n          The tensor to copy from (a numpy array or possibly-quantized ggml tensor)\n      to_tensor : TensorLike\n          The tensor to copy to (a numpy array or possibly-quantized ggml tensor)",
        "detail": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "description": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "peekOfCode": "def numpy(tensor: ffi.CData, allow_copy: Union[bool, np.ndarray] = False, allow_requantize=False) -> np.ndarray:\n    \"\"\"\n      Convert a ggml tensor to a numpy array.\n      If the tensor isn't quantized, the returned numpy array will be a view over its data.\n      If it is quantized (and allow_copy is True), the copy will involve dequantization and the returned array will\n      be a copy of the original tensor (any changes to the numpy array won't then be reflected back to the tensor).\n      Parameters\n      ----------\n      tensor : ffi.CData\n          The tensor to convert to a numpy array",
        "detail": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "documentation": {}
    },
    {
        "label": "TensorLike",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "description": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "peekOfCode": "TensorLike = Union[ffi.CData, np.ndarray]\ndef copy(from_tensor: TensorLike, to_tensor: TensorLike, allow_requantize: bool = True):\n    \"\"\"\n      Copy the contents of one tensor to another, doing any necessary (de/re)quantization transparently.\n      Works across numpy & ggml tensors, but they must have the same shape (and be contiguous).\n      Parameters\n      ----------\n      from_tensor : TensorLike\n          The tensor to copy from (a numpy array or possibly-quantized ggml tensor)\n      to_tensor : TensorLike",
        "detail": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "documentation": {}
    },
    {
        "label": "__k_quant_types",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "description": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "peekOfCode": "__k_quant_types = set([\n  lib.GGML_TYPE_Q2_K,\n  lib.GGML_TYPE_Q3_K,\n  lib.GGML_TYPE_Q4_K,\n  lib.GGML_TYPE_Q5_K,\n  lib.GGML_TYPE_Q6_K,\n  lib.GGML_TYPE_Q8_K,\n])\n__type_to_dtype_dict = {\n  lib.GGML_TYPE_I8: np.int8,",
        "detail": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "documentation": {}
    },
    {
        "label": "__type_to_dtype_dict",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "description": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "peekOfCode": "__type_to_dtype_dict = {\n  lib.GGML_TYPE_I8: np.int8,\n  lib.GGML_TYPE_I16: np.int16,\n  lib.GGML_TYPE_I32: np.int32,\n  lib.GGML_TYPE_F16: np.float16,\n  lib.GGML_TYPE_F32: np.float32,\n}\ndef __type_to_dtype(type: int) -> Optional[np.dtype]: return __type_to_dtype_dict.get(type)\ndef __dtype_to_type(dtype: np.dtype):\n    if dtype == np.float32: return lib.GGML_TYPE_F32",
        "detail": "lib.seamless_communication.ggml.examples.python.ggml.utils",
        "documentation": {}
    },
    {
        "label": "ctx",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "description": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "peekOfCode": "ctx = init(mem_size=12*1024*1024) # automatically freed when pointer is GC'd\nn = 256\nn_threads = 4\na = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_Q5_K, n)\nb = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, n) # can't both be quantized\nsum = lib.ggml_add(ctx, a, b) # all zeroes for now. Will be quantized too!\n# See cffi's doc on how to allocate native memory: it's very simple!\n# https://cffi.readthedocs.io/en/latest/ref.html#ffi-interface\ngf = ffi.new('struct ggml_cgraph*')\nlib.ggml_build_forward_expand(gf, sum)",
        "detail": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "description": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "peekOfCode": "n = 256\nn_threads = 4\na = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_Q5_K, n)\nb = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, n) # can't both be quantized\nsum = lib.ggml_add(ctx, a, b) # all zeroes for now. Will be quantized too!\n# See cffi's doc on how to allocate native memory: it's very simple!\n# https://cffi.readthedocs.io/en/latest/ref.html#ffi-interface\ngf = ffi.new('struct ggml_cgraph*')\nlib.ggml_build_forward_expand(gf, sum)\ncopy(np.array([i for i in range(n)], np.float32), a)",
        "detail": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "documentation": {}
    },
    {
        "label": "n_threads",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "description": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "peekOfCode": "n_threads = 4\na = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_Q5_K, n)\nb = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, n) # can't both be quantized\nsum = lib.ggml_add(ctx, a, b) # all zeroes for now. Will be quantized too!\n# See cffi's doc on how to allocate native memory: it's very simple!\n# https://cffi.readthedocs.io/en/latest/ref.html#ffi-interface\ngf = ffi.new('struct ggml_cgraph*')\nlib.ggml_build_forward_expand(gf, sum)\ncopy(np.array([i for i in range(n)], np.float32), a)\ncopy(np.array([i*100 for i in range(n)], np.float32), b)",
        "detail": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "description": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "peekOfCode": "a = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_Q5_K, n)\nb = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, n) # can't both be quantized\nsum = lib.ggml_add(ctx, a, b) # all zeroes for now. Will be quantized too!\n# See cffi's doc on how to allocate native memory: it's very simple!\n# https://cffi.readthedocs.io/en/latest/ref.html#ffi-interface\ngf = ffi.new('struct ggml_cgraph*')\nlib.ggml_build_forward_expand(gf, sum)\ncopy(np.array([i for i in range(n)], np.float32), a)\ncopy(np.array([i*100 for i in range(n)], np.float32), b)\nlib.ggml_graph_compute_with_ctx(ctx, gf, n_threads)",
        "detail": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "description": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "peekOfCode": "b = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, n) # can't both be quantized\nsum = lib.ggml_add(ctx, a, b) # all zeroes for now. Will be quantized too!\n# See cffi's doc on how to allocate native memory: it's very simple!\n# https://cffi.readthedocs.io/en/latest/ref.html#ffi-interface\ngf = ffi.new('struct ggml_cgraph*')\nlib.ggml_build_forward_expand(gf, sum)\ncopy(np.array([i for i in range(n)], np.float32), a)\ncopy(np.array([i*100 for i in range(n)], np.float32), b)\nlib.ggml_graph_compute_with_ctx(ctx, gf, n_threads)\nprint(numpy(a, allow_copy=True))",
        "detail": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "documentation": {}
    },
    {
        "label": "sum",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "description": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "peekOfCode": "sum = lib.ggml_add(ctx, a, b) # all zeroes for now. Will be quantized too!\n# See cffi's doc on how to allocate native memory: it's very simple!\n# https://cffi.readthedocs.io/en/latest/ref.html#ffi-interface\ngf = ffi.new('struct ggml_cgraph*')\nlib.ggml_build_forward_expand(gf, sum)\ncopy(np.array([i for i in range(n)], np.float32), a)\ncopy(np.array([i*100 for i in range(n)], np.float32), b)\nlib.ggml_graph_compute_with_ctx(ctx, gf, n_threads)\nprint(numpy(a, allow_copy=True))\nprint(numpy(b))",
        "detail": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "documentation": {}
    },
    {
        "label": "gf",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "description": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "peekOfCode": "gf = ffi.new('struct ggml_cgraph*')\nlib.ggml_build_forward_expand(gf, sum)\ncopy(np.array([i for i in range(n)], np.float32), a)\ncopy(np.array([i*100 for i in range(n)], np.float32), b)\nlib.ggml_graph_compute_with_ctx(ctx, gf, n_threads)\nprint(numpy(a, allow_copy=True))\nprint(numpy(b))\nprint(numpy(sum, allow_copy=True))",
        "detail": "lib.seamless_communication.ggml.examples.python.example_add_quant",
        "documentation": {}
    },
    {
        "label": "get_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "description": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "peekOfCode": "def get_name(type):\n    name = lib.ggml_type_name(type)\n    return ffi.string(name).decode('utf-8') if name else '?'\nquants.sort(key=get_name)\nquants.insert(0, None)\nprint(quants)\nncols=4\nnrows = ceil(len(quants) / ncols)\nplt.figure(figsize=(ncols * 5, nrows * 5), layout='tight')\nfor i, type in enumerate(quants):",
        "detail": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "documentation": {}
    },
    {
        "label": "ctx",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "description": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "peekOfCode": "ctx = init(mem_size=100*1024*1024) # Will be auto-GC'd\nn = 256\norig = np.array([\n    [\n        cos(j * 2 * pi / n) * (sin(i * 2 * pi / n))\n        for j in range(n)\n    ]\n    for i in range(n)\n], np.float32)\norig_tensor = lib.ggml_new_tensor_2d(ctx, lib.GGML_TYPE_F32, n, n)",
        "detail": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "description": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "peekOfCode": "n = 256\norig = np.array([\n    [\n        cos(j * 2 * pi / n) * (sin(i * 2 * pi / n))\n        for j in range(n)\n    ]\n    for i in range(n)\n], np.float32)\norig_tensor = lib.ggml_new_tensor_2d(ctx, lib.GGML_TYPE_F32, n, n)\ncopy(orig, orig_tensor)",
        "detail": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "documentation": {}
    },
    {
        "label": "orig",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "description": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "peekOfCode": "orig = np.array([\n    [\n        cos(j * 2 * pi / n) * (sin(i * 2 * pi / n))\n        for j in range(n)\n    ]\n    for i in range(n)\n], np.float32)\norig_tensor = lib.ggml_new_tensor_2d(ctx, lib.GGML_TYPE_F32, n, n)\ncopy(orig, orig_tensor)\nquants = [",
        "detail": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "documentation": {}
    },
    {
        "label": "orig_tensor",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "description": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "peekOfCode": "orig_tensor = lib.ggml_new_tensor_2d(ctx, lib.GGML_TYPE_F32, n, n)\ncopy(orig, orig_tensor)\nquants = [\n    type for type in range(lib.GGML_TYPE_COUNT)\n    if lib.ggml_is_quantized(type) and\n       type not in [lib.GGML_TYPE_Q8_1, lib.GGML_TYPE_Q8_K] # Apparently not supported\n]\n# quants = [lib.GGML_TYPE_Q2_K] # Test a single one\ndef get_name(type):\n    name = lib.ggml_type_name(type)",
        "detail": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "documentation": {}
    },
    {
        "label": "quants",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "description": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "peekOfCode": "quants = [\n    type for type in range(lib.GGML_TYPE_COUNT)\n    if lib.ggml_is_quantized(type) and\n       type not in [lib.GGML_TYPE_Q8_1, lib.GGML_TYPE_Q8_K] # Apparently not supported\n]\n# quants = [lib.GGML_TYPE_Q2_K] # Test a single one\ndef get_name(type):\n    name = lib.ggml_type_name(type)\n    return ffi.string(name).decode('utf-8') if name else '?'\nquants.sort(key=get_name)",
        "detail": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "documentation": {}
    },
    {
        "label": "nrows",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "description": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "peekOfCode": "nrows = ceil(len(quants) / ncols)\nplt.figure(figsize=(ncols * 5, nrows * 5), layout='tight')\nfor i, type in enumerate(quants):\n    plt.subplot(nrows, ncols, i + 1)\n    try:\n        if type == None:\n            plt.title('Original')\n            plt.imshow(orig)\n        else:\n            quantized_tensor = lib.ggml_new_tensor_2d(ctx, type, n, n)",
        "detail": "lib.seamless_communication.ggml.examples.python.example_test_all_quants",
        "documentation": {}
    },
    {
        "label": "API",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.regenerate",
        "description": "lib.seamless_communication.ggml.examples.python.regenerate",
        "peekOfCode": "API = os.environ.get('API', 'api.h')\nCC = os.environ.get('CC') or 'gcc'\nC_INCLUDE_DIR = os.environ.get('C_INCLUDE_DIR', '../../../llama.cpp')\nCPPFLAGS = [\n    \"-I\", C_INCLUDE_DIR,\n    '-D__fp16=uint16_t',  # pycparser doesn't support __fp16\n    '-D__attribute__(x)=',\n    '-D_Static_assert(x, m)=',\n] + [x for x in os.environ.get('CPPFLAGS', '').split(' ') if x != '']\ntry: header = subprocess.run([CC, \"-E\", *CPPFLAGS, API], capture_output=True, text=True, check=True).stdout",
        "detail": "lib.seamless_communication.ggml.examples.python.regenerate",
        "documentation": {}
    },
    {
        "label": "CC",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.regenerate",
        "description": "lib.seamless_communication.ggml.examples.python.regenerate",
        "peekOfCode": "CC = os.environ.get('CC') or 'gcc'\nC_INCLUDE_DIR = os.environ.get('C_INCLUDE_DIR', '../../../llama.cpp')\nCPPFLAGS = [\n    \"-I\", C_INCLUDE_DIR,\n    '-D__fp16=uint16_t',  # pycparser doesn't support __fp16\n    '-D__attribute__(x)=',\n    '-D_Static_assert(x, m)=',\n] + [x for x in os.environ.get('CPPFLAGS', '').split(' ') if x != '']\ntry: header = subprocess.run([CC, \"-E\", *CPPFLAGS, API], capture_output=True, text=True, check=True).stdout\nexcept subprocess.CalledProcessError as e: print(f'{e.stderr}\\n{e}', file=sys.stderr); raise",
        "detail": "lib.seamless_communication.ggml.examples.python.regenerate",
        "documentation": {}
    },
    {
        "label": "C_INCLUDE_DIR",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.regenerate",
        "description": "lib.seamless_communication.ggml.examples.python.regenerate",
        "peekOfCode": "C_INCLUDE_DIR = os.environ.get('C_INCLUDE_DIR', '../../../llama.cpp')\nCPPFLAGS = [\n    \"-I\", C_INCLUDE_DIR,\n    '-D__fp16=uint16_t',  # pycparser doesn't support __fp16\n    '-D__attribute__(x)=',\n    '-D_Static_assert(x, m)=',\n] + [x for x in os.environ.get('CPPFLAGS', '').split(' ') if x != '']\ntry: header = subprocess.run([CC, \"-E\", *CPPFLAGS, API], capture_output=True, text=True, check=True).stdout\nexcept subprocess.CalledProcessError as e: print(f'{e.stderr}\\n{e}', file=sys.stderr); raise\nheader = '\\n'.join([l for l in header.split('\\n') if '__darwin_va_list' not in l]) # pycparser hates this",
        "detail": "lib.seamless_communication.ggml.examples.python.regenerate",
        "documentation": {}
    },
    {
        "label": "CPPFLAGS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.regenerate",
        "description": "lib.seamless_communication.ggml.examples.python.regenerate",
        "peekOfCode": "CPPFLAGS = [\n    \"-I\", C_INCLUDE_DIR,\n    '-D__fp16=uint16_t',  # pycparser doesn't support __fp16\n    '-D__attribute__(x)=',\n    '-D_Static_assert(x, m)=',\n] + [x for x in os.environ.get('CPPFLAGS', '').split(' ') if x != '']\ntry: header = subprocess.run([CC, \"-E\", *CPPFLAGS, API], capture_output=True, text=True, check=True).stdout\nexcept subprocess.CalledProcessError as e: print(f'{e.stderr}\\n{e}', file=sys.stderr); raise\nheader = '\\n'.join([l for l in header.split('\\n') if '__darwin_va_list' not in l]) # pycparser hates this\n# Replace constant size expressions w/ their value (compile & run a mini exe for each, because why not).",
        "detail": "lib.seamless_communication.ggml.examples.python.regenerate",
        "documentation": {}
    },
    {
        "label": "header",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.regenerate",
        "description": "lib.seamless_communication.ggml.examples.python.regenerate",
        "peekOfCode": "header = '\\n'.join([l for l in header.split('\\n') if '__darwin_va_list' not in l]) # pycparser hates this\n# Replace constant size expressions w/ their value (compile & run a mini exe for each, because why not).\n# First, extract anyting *inside* square brackets and anything that looks like a sizeof call.\nfor expr in set(re.findall(f'(?<=\\\\[)[^\\\\]]+(?=])|sizeof\\\\s*\\\\([^()]+\\\\)', header)):\n    if re.match(r'^(\\d+|\\s*)$', expr): continue # skip constants and empty bracket contents\n    subprocess.run([CC, \"-o\", \"eval_size_expr\", *CPPFLAGS, \"-x\", \"c\", \"-\"], text=True, check=True,\n                   input=f'''#include <stdio.h>\n                             #include \"{API}\"\n                             int main() {{ printf(\"%lu\", (size_t)({expr})); }}''')\n    size = subprocess.run([\"./eval_size_expr\"], capture_output=True, text=True, check=True).stdout",
        "detail": "lib.seamless_communication.ggml.examples.python.regenerate",
        "documentation": {}
    },
    {
        "label": "ffibuilder",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.regenerate",
        "description": "lib.seamless_communication.ggml.examples.python.regenerate",
        "peekOfCode": "ffibuilder = cffi.FFI()\nffibuilder.cdef(header)\nffibuilder.set_source(f'ggml.cffi', None) # we're not compiling a native extension, as this quickly gets hairy\nffibuilder.compile(verbose=True)\nwith open(\"ggml/__init__.pyi\", \"wt\") as f:\n    f.write(generate_stubs(header))",
        "detail": "lib.seamless_communication.ggml.examples.python.regenerate",
        "documentation": {}
    },
    {
        "label": "PythonStubFuncDeclVisitor",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.examples.python.stubs",
        "description": "lib.seamless_communication.ggml.examples.python.stubs",
        "peekOfCode": "class PythonStubFuncDeclVisitor(c_ast.NodeVisitor):\n    def __init__(self):\n        self.sigs = {}\n        self.sources = {}\n    def get_source_snippet_lines(self, coord: pycparser.plyparser.Coord) -> Tuple[list[str], list[str]]:\n        if coord.file not in self.sources:\n            with open(coord.file, 'rt') as f:\n                self.sources[coord.file] = f.readlines()\n        source_lines = self.sources[coord.file]\n        ncomment_lines = len(list(itertools.takewhile(lambda i: re.search(r'^\\s*(//|/\\*)', source_lines[i]), range(coord.line - 2, -1, -1))))",
        "detail": "lib.seamless_communication.ggml.examples.python.stubs",
        "documentation": {}
    },
    {
        "label": "format_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.examples.python.stubs",
        "description": "lib.seamless_communication.ggml.examples.python.stubs",
        "peekOfCode": "def format_type(t: TypeDecl):\n    if isinstance(t, PtrDecl) or isinstance(t, Struct):\n        return 'ffi.CData'\n    if isinstance(t, Enum):\n        return 'int'\n    if isinstance(t, TypeDecl):\n        return format_type(t.type)\n    if isinstance(t, IdentifierType):\n        assert len(t.names) == 1, f'Expected a single name, got {t.names}'\n        return __c_type_to_python_type.get(t.names[0]) or 'ffi.CData'",
        "detail": "lib.seamless_communication.ggml.examples.python.stubs",
        "documentation": {}
    },
    {
        "label": "generate_stubs",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.examples.python.stubs",
        "description": "lib.seamless_communication.ggml.examples.python.stubs",
        "peekOfCode": "def generate_stubs(header: str):\n    \"\"\"\n      Generates a .pyi Python stub file for the GGML API using C header files.\n    \"\"\"\n    v = PythonStubFuncDeclVisitor()\n    v.visit(CParser().parse(header, \"<input>\"))\n    keys = list(v.sigs.keys())\n    keys.sort()\n    return '\\n'.join([\n        '# auto-generated file',",
        "detail": "lib.seamless_communication.ggml.examples.python.stubs",
        "documentation": {}
    },
    {
        "label": "__c_type_to_python_type",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.examples.python.stubs",
        "description": "lib.seamless_communication.ggml.examples.python.stubs",
        "peekOfCode": "__c_type_to_python_type = {\n    'void': 'None', '_Bool': 'bool',\n    'char': 'int', 'short': 'int', 'int': 'int', 'long': 'int',\n    'ptrdiff_t': 'int', 'size_t': 'int',\n    'int8_t': 'int', 'uint8_t': 'int',\n    'int16_t': 'int', 'uint16_t': 'int',\n    'int32_t': 'int', 'uint32_t': 'int',\n    'int64_t': 'int', 'uint64_t': 'int',\n    'float': 'float', 'double': 'float',\n    'ggml_fp16_t': 'np.float16',",
        "detail": "lib.seamless_communication.ggml.examples.python.stubs",
        "documentation": {}
    },
    {
        "label": "TestNumPy",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "description": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "peekOfCode": "class TestNumPy:\n    # Single element\n    def test_set_get_single_i32(self, ctx):\n        i = lib.ggml_new_i32(ctx, 42)\n        assert lib.ggml_get_i32_1d(i, 0) == 42\n        assert numpy(i) == np.array([42], dtype=np.int32)\n    def test_set_get_single_f32(self, ctx):\n        i = lib.ggml_new_f32(ctx, 4.2)\n        epsilon = 0.000001 # Not sure why so large a difference??\n        pytest.approx(lib.ggml_get_f32_1d(i, 0), 4.2, epsilon)",
        "detail": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "documentation": {}
    },
    {
        "label": "TestTensorCopy",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "description": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "peekOfCode": "class TestTensorCopy:\n    def test_copy_self(self, ctx):\n        t = lib.ggml_new_i32(ctx, 42)\n        copy(t, t)\n        assert lib.ggml_get_i32_1d(t, 0) == 42\n    def test_copy_1d(self, ctx):\n        t1 = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, 10)\n        t2 = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, 10)\n        a = np.arange(10, dtype=np.float32)\n        copy(a, t1)",
        "detail": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "documentation": {}
    },
    {
        "label": "TestGraph",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "description": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "peekOfCode": "class TestGraph:\n    def test_add(self, ctx):\n        n = 256\n        ta = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, n)\n        tb = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, n)\n        tsum = lib.ggml_add(ctx, ta, tb)\n        assert tsum.type == lib.GGML_TYPE_F32\n        gf = ffi.new('struct ggml_cgraph*')\n        lib.ggml_build_forward_expand(gf, tsum)\n        a = np.arange(0, n, dtype=np.float32)",
        "detail": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "documentation": {}
    },
    {
        "label": "TestQuantization",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "description": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "peekOfCode": "class TestQuantization:\n    def test_quantized_add(self, ctx):\n        n = 256\n        ta = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_Q5_K, n)\n        tb = lib.ggml_new_tensor_1d(ctx, lib.GGML_TYPE_F32, n)\n        tsum = lib.ggml_add(ctx, ta, tb)\n        assert tsum.type == lib.GGML_TYPE_Q5_K\n        gf = ffi.new('struct ggml_cgraph*')\n        lib.ggml_build_forward_expand(gf, tsum)\n        a = np.arange(0, n, dtype=np.float32)",
        "detail": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "documentation": {}
    },
    {
        "label": "ctx",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "description": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "peekOfCode": "def ctx():\n    print(\"setup\")\n    yield init(mem_size=10*1024*1024)\n    print(\"teardown\")\nclass TestNumPy:\n    # Single element\n    def test_set_get_single_i32(self, ctx):\n        i = lib.ggml_new_i32(ctx, 42)\n        assert lib.ggml_get_i32_1d(i, 0) == 42\n        assert numpy(i) == np.array([42], dtype=np.int32)",
        "detail": "lib.seamless_communication.ggml.examples.python.test_tensor",
        "documentation": {}
    },
    {
        "label": "Ptr",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.ctypes_utils",
        "description": "lib.seamless_communication.ggml.ctypes_utils",
        "peekOfCode": "class Ptr(Generic[T], ctypes._Pointer):  # type: ignore\n    contents: T\n    def __new__(cls, x: T) -> \"Ptr[T]\":\n        return ctypes.pointer(x)  # type: ignore\nNULLPTR: Ptr[Any] = None  # type: ignore[assignment]\ndef c_struct(cls: Type[T]) -> Type[T]:\n    struct = types.new_class(cls.__name__, bases=(ctypes.Structure,))\n    struct.__module__ = cls.__module__\n    struct._fields_ = [  # type: ignore\n        (k, _py_type_to_ctype(v)) for k, v in cls.__annotations__.items()",
        "detail": "lib.seamless_communication.ggml.ctypes_utils",
        "documentation": {}
    },
    {
        "label": "c_struct",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ctypes_utils",
        "description": "lib.seamless_communication.ggml.ctypes_utils",
        "peekOfCode": "def c_struct(cls: Type[T]) -> Type[T]:\n    struct = types.new_class(cls.__name__, bases=(ctypes.Structure,))\n    struct.__module__ = cls.__module__\n    struct._fields_ = [  # type: ignore\n        (k, _py_type_to_ctype(v)) for k, v in cls.__annotations__.items()\n    ]\n    def nice_init(self: T, *args: Any, **kwargs: Any) -> None:\n        dc = cls(*args, **kwargs)\n        for k, _ in self._fields_:  # type: ignore\n            setattr(self, k, getattr(dc, k))",
        "detail": "lib.seamless_communication.ggml.ctypes_utils",
        "documentation": {}
    },
    {
        "label": "c_fn",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ctypes_utils",
        "description": "lib.seamless_communication.ggml.ctypes_utils",
        "peekOfCode": "def c_fn(module: Any) -> Callable[[F], F]:\n    return functools.partial(_c_fn, module)",
        "detail": "lib.seamless_communication.ggml.ctypes_utils",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ctypes_utils",
        "description": "lib.seamless_communication.ggml.ctypes_utils",
        "peekOfCode": "T = TypeVar(\"T\")\nclass Ptr(Generic[T], ctypes._Pointer):  # type: ignore\n    contents: T\n    def __new__(cls, x: T) -> \"Ptr[T]\":\n        return ctypes.pointer(x)  # type: ignore\nNULLPTR: Ptr[Any] = None  # type: ignore[assignment]\ndef c_struct(cls: Type[T]) -> Type[T]:\n    struct = types.new_class(cls.__name__, bases=(ctypes.Structure,))\n    struct.__module__ = cls.__module__\n    struct._fields_ = [  # type: ignore",
        "detail": "lib.seamless_communication.ggml.ctypes_utils",
        "documentation": {}
    },
    {
        "label": "F",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ctypes_utils",
        "description": "lib.seamless_communication.ggml.ctypes_utils",
        "peekOfCode": "F = TypeVar(\"F\", bound=Callable[..., Any])\ndef _c_fn(module: Any, fn: F) -> F:\n    if callable(module):\n        c_fn = module\n    else:\n        c_fn = getattr(module, fn.__name__)\n    annotations = fn.__annotations__\n    if \"return\" not in annotations:\n        raise ValueError(\n            \"@c_fn decorator requires type annotations on the decorated function.\"",
        "detail": "lib.seamless_communication.ggml.ctypes_utils",
        "documentation": {}
    },
    {
        "label": "NativeObj",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "class NativeObj:\n    AllocFn = Callable[[], ctypes.c_void_p]\n    FreeFn = Callable[[ctypes.c_void_p], None]\n    _cache: Dict[str, Tuple[AllocFn, FreeFn]] = {}\n    @classmethod\n    def _init_c_func(cls, kind: str) -> Tuple[AllocFn, FreeFn]:\n        if kind in cls._cache:\n            return cls._cache[kind]\n        alloc_fn = getattr(lib, f\"{kind}_alloc\")\n        alloc_fn.argtypes = []",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOptions",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "class SequenceGeneratorOptions:\n    beam_size: int\n    min_seq_len: int = 5\n    soft_max_seq_len_a: float = 1.0\n    soft_max_seq_len_b: int = 200\n    hard_max_seq_len: int = 1024\n    len_penalty: float = 1.0\n    unk_penalty: float = 0.0\n    normalize_scores: bool = True\n    mem_mb: int = 256",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorJob",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "class SequenceGeneratorJob:\n    opts: SequenceGeneratorOptions\n    prefix_seq: Ptr[ggml_tensor]\n    pad_idx: int\n    unk_idx: int\n    bos_idx: int\n    eos_idx: int\n    num_threads: int = 1\n@c_struct\nclass Hypothesis:",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "Hypothesis",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "class Hypothesis:\n    seq: Ptr[ggml_tensor]\n    \"\"\"The generated sequence.\"\"\"\n    score: float\n    \"\"\"The score of the hypothesis.\"\"\"\n    step_scores: Ptr[ggml_tensor]\n    \"\"\"The score of each individual sequence step.\"\"\"\n@c_fn(lib)\ndef generate_sequence(\n    model: ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "numpy_dtype",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def numpy_dtype(ggml_type: ctypes.c_int) -> np.dtype:\n    if ggml_type == 0:\n        # GGML_TYPE_F32  = 0,\n        return np.dtype(np.float32)\n    if ggml_type == 1:\n        # GGML_TYPE_F16  = 1,\n        return np.dtype(np.float16)\n    if ggml_type == 18:\n        return np.dtype(np.int32)\n    raise NotImplementedError(f\"Can't convert GGML_TYPE({ggml_type}) to a numpy.dtype\")",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "from_numpy_dtype",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def from_numpy_dtype(dtype: np.dtype) -> ctypes.c_int:\n    def _ggml_type(name: bytes, value: int) -> ctypes.c_int:\n        t = ctypes.c_int(value)\n        type_name = ggml_type_name(t)\n        if name != type_name:\n            raise RuntimeError(\n                f\"Type {name!r} doesn't have value {value}. ggml.h was probably updated but not ggml.py\"\n            )\n        return t\n    if dtype == np.float32:",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "shape",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def shape(tensor: Union[ggml_tensor, ggml_tensor_p]) -> Tuple[int, ...]:\n    if isinstance(tensor, ctypes._Pointer):\n        tensor = tensor.contents\n    ndims = tensor.n_dims\n    return tuple([tensor.ne[i] for i in range(ndims)[::-1]])\ndef nb(tensor: Union[ggml_tensor, ggml_tensor_p]) -> Tuple[int, ...]:\n    if isinstance(tensor, ctypes._Pointer):\n        tensor = tensor.contents\n    return tuple([tensor.nb[i] for i in range(4)])\ndef ne(tensor: Union[ggml_tensor, ggml_tensor_p]) -> Tuple[int, ...]:",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "nb",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def nb(tensor: Union[ggml_tensor, ggml_tensor_p]) -> Tuple[int, ...]:\n    if isinstance(tensor, ctypes._Pointer):\n        tensor = tensor.contents\n    return tuple([tensor.nb[i] for i in range(4)])\ndef ne(tensor: Union[ggml_tensor, ggml_tensor_p]) -> Tuple[int, ...]:\n    if isinstance(tensor, ctypes._Pointer):\n        tensor = tensor.contents\n    return tuple([tensor.ne[i] for i in range(4)])\ndef strides(tensor: Union[ggml_tensor, ggml_tensor_p]) -> Tuple[int, ...]:\n    if isinstance(tensor, ctypes._Pointer):",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "ne",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def ne(tensor: Union[ggml_tensor, ggml_tensor_p]) -> Tuple[int, ...]:\n    if isinstance(tensor, ctypes._Pointer):\n        tensor = tensor.contents\n    return tuple([tensor.ne[i] for i in range(4)])\ndef strides(tensor: Union[ggml_tensor, ggml_tensor_p]) -> Tuple[int, ...]:\n    if isinstance(tensor, ctypes._Pointer):\n        tensor = tensor.contents\n    ndims = tensor.n_dims\n    num_bytes = tuple([tensor.nb[i] for i in range(ndims)])\n    strides = num_bytes[::-1]",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "strides",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def strides(tensor: Union[ggml_tensor, ggml_tensor_p]) -> Tuple[int, ...]:\n    if isinstance(tensor, ctypes._Pointer):\n        tensor = tensor.contents\n    ndims = tensor.n_dims\n    num_bytes = tuple([tensor.nb[i] for i in range(ndims)])\n    strides = num_bytes[::-1]\n    return strides\ndef to_numpy(tensor_p: ggml_tensor_p) -> np.ndarray:\n    if not ggml_is_contiguous(tensor_p):\n        if not _almost_contiguous(tensor_p):",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "to_numpy",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def to_numpy(tensor_p: ggml_tensor_p) -> np.ndarray:\n    if not ggml_is_contiguous(tensor_p):\n        if not _almost_contiguous(tensor_p):\n            return _strided_to_numpy(tensor_p)\n    tensor = tensor_p.contents\n    res = _void_p_to_np_array(tensor.data, shape(tensor), numpy_dtype(tensor.type))\n    if ggml_is_transposed(tensor_p):\n        # Patch up strides to work with transposed ggml_tensor\n        res.strides = strides(tensor)  # type: ignore[assignment]\n    return res",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "from_file",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def from_file(\n    ctx: ggml_context_p, file: Path, shape: Tuple[int, ...], dtype: type = np.float32\n) -> ggml_tensor_p:\n    data = np.fromfile(str(file), dtype=dtype).reshape(shape)  # type: ignore\n    return from_numpy(ctx, data)\ndef _shape_to_ne(shape: Tuple[int, ...]) -> Tuple[int, int, int, int]:\n    # in GGML ne[0] indicates the contiguous dimension, ie the last one in numpy and torch\n    ne = shape[::-1]\n    if len(ne) >= GGML_MAX_DIMS:\n        return ne  # type: ignore",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "from_numpy",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def from_numpy(\n    ctx: ggml_context_p, array: Union[np.ndarray, \"torch.Tensor\"], name: bytes = b\"\"\n) -> Ptr[ggml_tensor]:\n    if type(array).__name__ == \"Tensor\":\n        array = array.numpy()\n    # Create an empty tensor so we don't allocate memory for the data pointer\n    gtype = from_numpy_dtype(array.dtype)\n    tensor_p = ggml_new_tensor_1d(ctx, gtype, 0)\n    # Fill out the correct dimensions and shape.\n    tensor_p.contents.n_dims = array.ndim",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "ggml_can_mul_mat",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def ggml_can_mul_mat(t0: ggml_tensor_p, t1: ggml_tensor_p) -> bool:\n    assert GGML_MAX_DIMS == 4, \"GGML_MAX_DIMS is not 4 - update this function\"\n    return (\n        (t0.contents.ne[0] == t1.contents.ne[0])\n        and (t1.contents.ne[2] % t0.contents.ne[2] == 0)\n        and (t1.contents.ne[3] % t0.contents.ne[3] == 0)\n    )\ndef nodes(gf: ggml_cgraph) -> Dict[bytes, ggml_tensor_p]:\n    res = {}\n    for i in range(gf.n_nodes):",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "nodes",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def nodes(gf: ggml_cgraph) -> Dict[bytes, ggml_tensor_p]:\n    res = {}\n    for i in range(gf.n_nodes):\n        name = gf.nodes[i].contents.name\n        res[name] = gf.nodes[i]\n    return res\ndef leafs(gf: ggml_cgraph) -> Dict[bytes, ggml_tensor_p]:\n    res = {}\n    for i in range(gf.n_leafs):\n        name = gf.leafs[i].contents.name",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "leafs",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def leafs(gf: ggml_cgraph) -> Dict[bytes, ggml_tensor_p]:\n    res = {}\n    for i in range(gf.n_leafs):\n        name = gf.leafs[i].contents.name\n        res[name] = gf.leafs[i]\n    return res\nclass NativeObj:\n    AllocFn = Callable[[], ctypes.c_void_p]\n    FreeFn = Callable[[ctypes.c_void_p], None]\n    _cache: Dict[str, Tuple[AllocFn, FreeFn]] = {}",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "MeasureArena",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def MeasureArena() -> NativeObj:\n    return NativeObj(\"ggml_allocr\", ggml_allocr_new_measure(GGML_MEM_ALIGN))\ndef FixedSizeArena(mem_size: int) -> NativeObj:\n    memory = torch.zeros(mem_size, dtype=torch.uint8)\n    allocr = ggml_allocr_new(\n        ctypes.c_void_p(memory.data_ptr()), mem_size, GGML_MEM_ALIGN\n    )\n    arena = NativeObj(\"ggml_allocr\", allocr)\n    # Add a reference from the arena object to the underlying tensor, otherwise it will be freed to early.\n    setattr(arena, \"__memory\", memory)",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "FixedSizeArena",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def FixedSizeArena(mem_size: int) -> NativeObj:\n    memory = torch.zeros(mem_size, dtype=torch.uint8)\n    allocr = ggml_allocr_new(\n        ctypes.c_void_p(memory.data_ptr()), mem_size, GGML_MEM_ALIGN\n    )\n    arena = NativeObj(\"ggml_allocr\", allocr)\n    # Add a reference from the arena object to the underlying tensor, otherwise it will be freed to early.\n    setattr(arena, \"__memory\", memory)\n    return arena\nlib.fairseq2_model_set_inference_ctx.argtypes = [ctypes.c_void_p, ggml_context_p]",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "Fairseq2Model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def Fairseq2Model() -> NativeObj:\n    return NativeObj(\"fairseq2_model\")\nlib.std_string_alloc.argtypes = [ctypes.c_char_p]\nlib.std_string_alloc.restype = ctypes.c_void_p\nlib.std_string_free.argtypes = [ctypes.c_void_p]\nlib.std_string_free.restype = None\nNativeObj._cache[\"std_string\"] = (lib.std_string_alloc, lib.std_string_free)\ndef CppStr(content: str) -> NativeObj:\n    c_str = ctypes.create_string_buffer(content.encode(\"utf-8\"))\n    cpp_str = lib.std_string_alloc(c_str)",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "CppStr",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def CppStr(content: str) -> NativeObj:\n    c_str = ctypes.create_string_buffer(content.encode(\"utf-8\"))\n    cpp_str = lib.std_string_alloc(c_str)\n    return NativeObj(\"std_string\", cpp_str)\nlib.load_fairseq2_ggml_file.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\nlib.load_fairseq2_ggml_file.restype = ctypes.c_int\ndef load_fairseq2_ggml_file(model_file: Path) -> NativeObj:\n    model = Fairseq2Model()\n    bytes_file = ctypes.create_string_buffer(str(model_file).encode(\"utf-8\"))\n    err = lib.load_fairseq2_ggml_file(model.ptr, bytes_file)",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "load_fairseq2_ggml_file",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def load_fairseq2_ggml_file(model_file: Path) -> NativeObj:\n    model = Fairseq2Model()\n    bytes_file = ctypes.create_string_buffer(str(model_file).encode(\"utf-8\"))\n    err = lib.load_fairseq2_ggml_file(model.ptr, bytes_file)\n    if err:\n        raise Exception(\"Failed to load model\")\n    return model\n# lib.unity_audio_encoder_graph.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n# lib.unity_audio_encoder_graph.restype = ctypes.POINTER(ggml_cgraph)\n# def unity_audio_encoder_graph(model: NativeObj, tensor: ggml_tensor_p) -> ggml_cgraph_p:",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def forward(\n    layer_name: str, model: ctypes.c_void_p, prefix: str, *inputs: ggml_tensor_p\n) -> ggml_tensor_p:\n    fwd: Any = _FORWARD_CACHE.get(layer_name)\n    if fwd is None:\n        fwd = getattr(lib, layer_name + \"_forward\")\n        num_inputs = len(inputs)\n        fwd.argtypes = [ctypes.c_void_p, ctypes.c_void_p] + [\n            ctypes.POINTER(ggml_tensor)\n        ] * num_inputs",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "build_and_compute",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def build_and_compute(\n    ctx: ggml_context_p, tensor: ggml_tensor_p, num_threads: int = 1, dump: Union[bool, str] = False\n) -> ggml_cgraph:\n    gf = ggml_build_forward(tensor)\n    need_alloc = tensor.contents.data == NULLPTR\n    if need_alloc:\n        alloc = FixedSizeArena(1024 * 1024 * 1024 * 2)\n        ggml_allocr_alloc_graph(alloc.ptr, ctypes.pointer(gf))\n        setattr(tensor, \"__data\", alloc)\n    if dump:",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "causal_attention_mask",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def causal_attention_mask(\n    ctx: ggml_context_p, seqs: Ptr[ggml_tensor]\n) -> Ptr[ggml_tensor]:\n    ...\n@c_fn(lib)\ndef ggml_slice(\n    ctx: ggml_context_p,\n    a: Ptr[ggml_tensor],\n    axis: int,\n    start: ctypes.c_int64,",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "ggml_slice",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def ggml_slice(\n    ctx: ggml_context_p,\n    a: Ptr[ggml_tensor],\n    axis: int,\n    start: ctypes.c_int64,\n    end: ctypes.c_int64,\n) -> Ptr[ggml_tensor]:\n    ...\n@c_fn(lib)\ndef ggml_flatten_1d(",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "ggml_flatten_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def ggml_flatten_1d(\n    ctx: ggml_context_p, a: Ptr[ggml_tensor], dim: int\n) -> Ptr[ggml_tensor]:\n    return a\n@c_fn(lib)\ndef ggml_unflatten_1d(\n    ctx: ggml_context_p, a: Ptr[ggml_tensor], dim: int, num_el: int\n) -> Ptr[ggml_tensor]:\n    return a\n@c_struct",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "ggml_unflatten_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def ggml_unflatten_1d(\n    ctx: ggml_context_p, a: Ptr[ggml_tensor], dim: int, num_el: int\n) -> Ptr[ggml_tensor]:\n    return a\n@c_struct\n@dataclasses.dataclass\nclass SequenceGeneratorOptions:\n    beam_size: int\n    min_seq_len: int = 5\n    soft_max_seq_len_a: float = 1.0",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "generate_sequence",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def generate_sequence(\n    model: ctypes.c_void_p,\n    job: Ptr[SequenceGeneratorJob],\n    encoder_output: Ptr[ggml_tensor],\n    encoder_padding_mask: Ptr[ggml_tensor],\n    result_ctx: ggml_context_p,\n) -> Ptr[Hypothesis]:\n    ...\n@c_fn(lib)\ndef _testing_return_hypothesis_ptr(ctx: ggml_context_p) -> Ptr[Hypothesis]:",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "fairseq2_model_layer_config_int",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def fairseq2_model_layer_config_int(model: ctypes.c_void_p, name: bytes) -> int:\n    return -1\n@c_fn(lib.fairseq2_kv_cache_alloc)\ndef _fairseq2_kv_cache_alloc(\n    model: ctypes.c_void_p, ctx: ctypes.c_void_p, beam_size: int, max_seq_len: int\n) -> None:\n    pass\n@c_fn(lib.fairseq2_kv_cache_reset)\ndef _fairseq2_kv_cache_reset(model: ctypes.c_void_p) -> None:\n    pass",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "fairseq2_kv_cache_alloc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def fairseq2_kv_cache_alloc(\n    model: ctypes.c_void_p, kv_cache_size: int, beam_size: int, max_seq_len: int\n) -> Iterator[None]:\n    memory = torch.zeros(kv_cache_size, dtype=torch.uint8)\n    ctx = ggml_init(\n        params=ggml_init_params(\n            mem_size=kv_cache_size,\n            mem_buffer=ctypes.c_void_p(memory.data_ptr()),\n            no_alloc=False,\n        )",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "fairseq2_spm_tokenize",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def fairseq2_spm_tokenize(\n    model: ctypes.c_void_p, text: bytes, out: Ptr[ggml_tensor]\n) -> None:\n    pass\n@c_fn(lib)\ndef fairseq2_spm_detokenize(\n    model: ctypes.c_void_p, tensor: Ptr[ggml_tensor], out: ctypes.Array[ctypes.c_char]\n) -> ctypes.c_size_t:\n    return 0",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "fairseq2_spm_detokenize",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "def fairseq2_spm_detokenize(\n    model: ctypes.c_void_p, tensor: Ptr[ggml_tensor], out: ctypes.Array[ctypes.c_char]\n) -> ctypes.c_size_t:\n    return 0",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "GgmlNElem",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "GgmlNElem = ctypes.c_int64 * GGML_MAX_DIMS\nGgmlNBytes = ctypes.c_uint64 * GGML_MAX_DIMS\ndef from_file(\n    ctx: ggml_context_p, file: Path, shape: Tuple[int, ...], dtype: type = np.float32\n) -> ggml_tensor_p:\n    data = np.fromfile(str(file), dtype=dtype).reshape(shape)  # type: ignore\n    return from_numpy(ctx, data)\ndef _shape_to_ne(shape: Tuple[int, ...]) -> Tuple[int, int, int, int]:\n    # in GGML ne[0] indicates the contiguous dimension, ie the last one in numpy and torch\n    ne = shape[::-1]",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "GgmlNBytes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "GgmlNBytes = ctypes.c_uint64 * GGML_MAX_DIMS\ndef from_file(\n    ctx: ggml_context_p, file: Path, shape: Tuple[int, ...], dtype: type = np.float32\n) -> ggml_tensor_p:\n    data = np.fromfile(str(file), dtype=dtype).reshape(shape)  # type: ignore\n    return from_numpy(ctx, data)\ndef _shape_to_ne(shape: Tuple[int, ...]) -> Tuple[int, int, int, int]:\n    # in GGML ne[0] indicates the contiguous dimension, ie the last one in numpy and torch\n    ne = shape[::-1]\n    if len(ne) >= GGML_MAX_DIMS:",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "lib.fairseq2_model_set_inference_ctx.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "lib.fairseq2_model_set_inference_ctx.argtypes = [ctypes.c_void_p, ggml_context_p]\ndef Fairseq2Model() -> NativeObj:\n    return NativeObj(\"fairseq2_model\")\nlib.std_string_alloc.argtypes = [ctypes.c_char_p]\nlib.std_string_alloc.restype = ctypes.c_void_p\nlib.std_string_free.argtypes = [ctypes.c_void_p]\nlib.std_string_free.restype = None\nNativeObj._cache[\"std_string\"] = (lib.std_string_alloc, lib.std_string_free)\ndef CppStr(content: str) -> NativeObj:\n    c_str = ctypes.create_string_buffer(content.encode(\"utf-8\"))",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "lib.std_string_alloc.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "lib.std_string_alloc.argtypes = [ctypes.c_char_p]\nlib.std_string_alloc.restype = ctypes.c_void_p\nlib.std_string_free.argtypes = [ctypes.c_void_p]\nlib.std_string_free.restype = None\nNativeObj._cache[\"std_string\"] = (lib.std_string_alloc, lib.std_string_free)\ndef CppStr(content: str) -> NativeObj:\n    c_str = ctypes.create_string_buffer(content.encode(\"utf-8\"))\n    cpp_str = lib.std_string_alloc(c_str)\n    return NativeObj(\"std_string\", cpp_str)\nlib.load_fairseq2_ggml_file.argtypes = [ctypes.c_void_p, ctypes.c_char_p]",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "lib.std_string_alloc.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "lib.std_string_alloc.restype = ctypes.c_void_p\nlib.std_string_free.argtypes = [ctypes.c_void_p]\nlib.std_string_free.restype = None\nNativeObj._cache[\"std_string\"] = (lib.std_string_alloc, lib.std_string_free)\ndef CppStr(content: str) -> NativeObj:\n    c_str = ctypes.create_string_buffer(content.encode(\"utf-8\"))\n    cpp_str = lib.std_string_alloc(c_str)\n    return NativeObj(\"std_string\", cpp_str)\nlib.load_fairseq2_ggml_file.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\nlib.load_fairseq2_ggml_file.restype = ctypes.c_int",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "lib.std_string_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "lib.std_string_free.argtypes = [ctypes.c_void_p]\nlib.std_string_free.restype = None\nNativeObj._cache[\"std_string\"] = (lib.std_string_alloc, lib.std_string_free)\ndef CppStr(content: str) -> NativeObj:\n    c_str = ctypes.create_string_buffer(content.encode(\"utf-8\"))\n    cpp_str = lib.std_string_alloc(c_str)\n    return NativeObj(\"std_string\", cpp_str)\nlib.load_fairseq2_ggml_file.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\nlib.load_fairseq2_ggml_file.restype = ctypes.c_int\ndef load_fairseq2_ggml_file(model_file: Path) -> NativeObj:",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "lib.std_string_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "lib.std_string_free.restype = None\nNativeObj._cache[\"std_string\"] = (lib.std_string_alloc, lib.std_string_free)\ndef CppStr(content: str) -> NativeObj:\n    c_str = ctypes.create_string_buffer(content.encode(\"utf-8\"))\n    cpp_str = lib.std_string_alloc(c_str)\n    return NativeObj(\"std_string\", cpp_str)\nlib.load_fairseq2_ggml_file.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\nlib.load_fairseq2_ggml_file.restype = ctypes.c_int\ndef load_fairseq2_ggml_file(model_file: Path) -> NativeObj:\n    model = Fairseq2Model()",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "NativeObj._cache[\"std_string\"]",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "NativeObj._cache[\"std_string\"] = (lib.std_string_alloc, lib.std_string_free)\ndef CppStr(content: str) -> NativeObj:\n    c_str = ctypes.create_string_buffer(content.encode(\"utf-8\"))\n    cpp_str = lib.std_string_alloc(c_str)\n    return NativeObj(\"std_string\", cpp_str)\nlib.load_fairseq2_ggml_file.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\nlib.load_fairseq2_ggml_file.restype = ctypes.c_int\ndef load_fairseq2_ggml_file(model_file: Path) -> NativeObj:\n    model = Fairseq2Model()\n    bytes_file = ctypes.create_string_buffer(str(model_file).encode(\"utf-8\"))",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "lib.load_fairseq2_ggml_file.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "lib.load_fairseq2_ggml_file.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\nlib.load_fairseq2_ggml_file.restype = ctypes.c_int\ndef load_fairseq2_ggml_file(model_file: Path) -> NativeObj:\n    model = Fairseq2Model()\n    bytes_file = ctypes.create_string_buffer(str(model_file).encode(\"utf-8\"))\n    err = lib.load_fairseq2_ggml_file(model.ptr, bytes_file)\n    if err:\n        raise Exception(\"Failed to load model\")\n    return model\n# lib.unity_audio_encoder_graph.argtypes = [ctypes.c_void_p, ctypes.c_void_p]",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "lib.load_fairseq2_ggml_file.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml",
        "description": "lib.seamless_communication.ggml.ggml",
        "peekOfCode": "lib.load_fairseq2_ggml_file.restype = ctypes.c_int\ndef load_fairseq2_ggml_file(model_file: Path) -> NativeObj:\n    model = Fairseq2Model()\n    bytes_file = ctypes.create_string_buffer(str(model_file).encode(\"utf-8\"))\n    err = lib.load_fairseq2_ggml_file(model.ptr, bytes_file)\n    if err:\n        raise Exception(\"Failed to load model\")\n    return model\n# lib.unity_audio_encoder_graph.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n# lib.unity_audio_encoder_graph.restype = ctypes.POINTER(ggml_cgraph)",
        "detail": "lib.seamless_communication.ggml.ggml",
        "documentation": {}
    },
    {
        "label": "ModelType",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "class ModelType(str, Enum):\n    AUTO = \"auto\"  # inferred from the model name\n    UNITY = \"unity\"\n    NLLB = \"nllb\"\n    MT = \"bitext\"\n    MTS = \"bitext_scripted\"\nUNITY_SMALLER_MODELS = [\n    \"unity_nano\",\n    \"unity_micro\",\n]  # Trained with fairseq2, with custom dict (not original NLLB ones)",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "NllbLikeTokenizer",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "class NllbLikeTokenizer(SentencePieceTokenizerBase):\n    \"\"\"The only difference between this class and NllbTokenizer is it doesn't add a <pad> to control symbol list.\n    Since NllbTokenizer is defined as final, we couldn't inherit from it directly. So copying ~everything\"\"\"\n    langs: Set[str]\n    default_lang: str\n    def __init__(\n        self, pathname: PathLike, langs: Sequence[str], default_lang: str\n    ) -> None:\n        \"\"\"\n        :param pathname:",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "NllbLikeTokenizerLoader",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "class NllbLikeTokenizerLoader(TokenizerLoaderBase[NllbLikeTokenizer]):\n    \"\"\"Loads tokenizers used by NLLB models.\"\"\"\n    @finaloverride\n    def _load(self, pathname: Path, card: AssetCard) -> NllbLikeTokenizer:\n        langs = card.field(\"langs\").as_list(str)\n        default_lang = card.field(\"default_lang\").as_(str)\n        return NllbLikeTokenizer(pathname, langs, default_lang)\ndef convert_state_dict(\n    state_dict: Dict[str, Any], key_map: Optional[Mapping[str, str]] = None\n) -> Dict[str, Any]:",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "convert_state_dict",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def convert_state_dict(\n    state_dict: Dict[str, Any], key_map: Optional[Mapping[str, str]] = None\n) -> Dict[str, Any]:\n    if key_map is None:\n        return state_dict\n    state_dict = convert_model_state_dict(state_dict, key_map=key_map)\n    # We use the built-in version attribute of `torch.nn.Module`.\n    try:\n        del state_dict[\"encoder.version\"]\n    except KeyError:",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "convert_unity_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def convert_unity_model(\n    model_name: str,\n    hparams: Optional[Dict[str, Any]] = None,\n):\n    from seamless_communication.models import unity\n    from seamless_communication.models.unity.builder import UnitYConfig, create_unity_model\n    from seamless_communication.models.unity.model import UnitYModel\n    load_unity_model_without_conversion = ModelLoader[UnitYModel, UnitYConfig](\n        asset_store,\n        download_manager,",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "convert_nllb_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def convert_nllb_model(\n    model_name: str,\n    hparams: Optional[Dict[str, Any]] = None,\n):\n    from fairseq2.models.nllb.loader import load_nllb_tokenizer, load_nllb_model, load_nllb_config\n    model_config = load_nllb_config(model_name)\n    hparams = flatten_config(\n        dataclasses.asdict(model_config), separator=\"__\", overrides=hparams,\n    )\n    hparams[\"multilingual\"] = True",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "convert_bitext_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def convert_bitext_model(\n    model_name: str,\n    hparams: Optional[Dict[str, Any]] = None,\n):\n    from mt import load_mt_model, load_vocab  #, test_mt\n    hparams = hparams or {}\n    hparams[\"multilingual\"] = False\n    model = load_mt_model(model_name)\n    src_vocab, src_spm = load_vocab(model_name, \"src\")\n    tgt_vocab, tgt_spm = load_vocab(model_name, \"tgt\")",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "convert_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def convert_model(\n    model_name: Union[str, torch.nn.Module],\n    out: Optional[Path] = None,\n    model_type: ModelType = ModelType.AUTO,\n    layers: str = \"\",\n    hparams: Optional[Dict[str, Any]] = None,\n    fp16: bool = False,\n) -> None:\n    \"\"\"\n    Entry function for converting different kinds of model into GGML file. Supported model checkpoints:",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "find_children",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def find_children(model: torch.nn.Module, t: type, layer_filter: str = \"\") -> List[Tuple[str, torch.nn.Module]]:\n    queue = list(model._modules.items())\n    modules = []\n    while queue:\n        name, node = queue.pop()\n        if node is None:\n            continue\n        if layer_filter and not re.match(layer_filter, name):\n            continue\n        if isinstance(node, t):",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "fixup_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def fixup_model(model: torch.nn.Module, state_dict: Dict[str, torch.Tensor], layer_filter: str) -> None:\n    # Bake the embedding scaling into the weights\n    frontends = find_children(model, TransformerEmbeddingFrontend, layer_filter)\n    if frontends:\n        log.info(\n            \"Upgrading the following TransformerEmbeddingFrontend: {}\",\n            [x[0] for x in frontends],\n        )\n    for name, frontend in frontends:\n        embed_weights = state_dict[name + \".embed.weight\"]",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "read_vocab",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def read_vocab(tokenizer: Any) -> List[Tuple[str, float]]:\n    vocab_info = tokenizer.vocab_info\n    vocab = [\n        (tokenizer.model.index_to_token(i).replace(\"▁\", \" \"), -i)\n        for i in range(vocab_info.size)\n    ]\n    return vocab  # type: ignore[return-value]\ndef write_ggml_file(\n    out: Path,\n    hparams: Dict[str, Any],",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "write_ggml_file",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def write_ggml_file(\n    out: Path,\n    hparams: Dict[str, Any],\n    layer_config: Dict[str, Any],\n    state_dict: Dict[str, torch.Tensor],\n    vocab: List[Tuple[str, float]],\n    tgt_vocab: Optional[List[Tuple[str, float]]] = None,  # tgt_vocab for bilingual models\n    fp16: bool = False,\n) -> None:\n    with out.open(\"wb\") as o:",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "write_ggml_header",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def write_ggml_header(out: BufferedWriter) -> None:\n    \"\"\"Write GGML header (in reverse cause big-endian)\"\"\"\n    out.write(b\"ggml\"[::-1])\ndef write_hparams(out: BufferedWriter, hparams: Dict[str, Any]) -> None:\n    \"\"\"Write hyper parameters.\n    :params hparams:\n        flattened dict containing model's hyper parameters.\n    \"\"\"\n    simple_vals = {}\n    for key, value in hparams.items():",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "write_hparams",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def write_hparams(out: BufferedWriter, hparams: Dict[str, Any]) -> None:\n    \"\"\"Write hyper parameters.\n    :params hparams:\n        flattened dict containing model's hyper parameters.\n    \"\"\"\n    simple_vals = {}\n    for key, value in hparams.items():\n        try:\n            simple_vals[key] = to_ctype(value)\n        except ValueError:",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "write_vocab",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def write_vocab(out: BufferedWriter, vocab: List[Tuple[str, float]]) -> None:\n    out.write(struct.pack(\"<q\", len(vocab)))\n    if len(vocab) == 0:\n        return\n    # Write all words concatenated in a buffer\n    words = [bytes(w, \"utf8\") for w, score in vocab]\n    packed_words = b\"\\0\".join(words)\n    # We use i32 to allow reusing the string loading codes\n    packed_len = struct.pack(\"<i\", len(packed_words))\n    out.write(packed_len)",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "write_state_dict",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def write_state_dict(\n    out: BufferedWriter, state_dict: Dict[str, torch.Tensor], fp16: bool\n) -> None:\n    \"\"\"Write pytorch state dict.\n    :params state_dict:\n        state dict returned by pytorch model\n    :params fp16:\n        convert float32 tensors to float16 on disk\n    \"\"\"\n    out.write(struct.pack(\"<q\", len(state_dict)))",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "write_string",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def write_string(out: BufferedWriter, value: str) -> None:\n    \"\"\"Write string in utf-8 format.\n    :params value:\n        string value to dump.\n    \"\"\"\n    str_ = value.encode(\"utf-8\")\n    packed_len = struct.pack(\"<i\", len(str_))\n    assert len(packed_len) == 4\n    out.write(packed_len)\n    out.write(str_)",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "write_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def write_tensor(out: BufferedWriter, value: torch.Tensor) -> None:\n    \"\"\"Write torch tensor in ggml format.\n    First we save the number of dimensions and the dtype.\n    Then we save the data as numpy array.\n    :params value:\n        Tensor to dump.\n    \"\"\"\n    if value.dtype is torch.int64:\n        # GGML doesn't have int64, downcast it\n        value = value.to(dtype=torch.int32)",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "torch_to_ggml_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def torch_to_ggml_type(dtype: torch.dtype) -> int:\n    if dtype is torch.float32:\n        return ggml.GGML_TYPE_F32\n    elif dtype is torch.float16:\n        return ggml.GGML_TYPE_F16\n    elif dtype is torch.int32:\n        return ggml.GGML_TYPE_I32\n    elif dtype is torch.int8:\n        return ggml.GGML_TYPE_I8\n    else:",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "flatten_config",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def flatten_config(\n    config: Dict[str, Any],\n    separator: str,\n    overrides: Optional[Dict[str, Any]] = None,\n) -> Dict[str, Any]:\n    \"\"\"Flatten nested dictionnary\n    :param config:\n        nested dictionnary containing model config.\n    :param separator:\n            string separator used when flattening nested hparams",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "read_layer_config",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def read_layer_config(\n    model: torch.nn.Module, layer_filter: str, key_map: Optional[Dict[str, str]] = None\n) -> Dict[str, Any]:\n    layer_config = {}\n    def _append_node_config(node: Any, prefix: str) -> None:\n        for k, v in node.__dict__.items():\n            # Skip special members. In particular all children module and tensors\n            # will be hidden in special dicts `_parameters` and `_modules`\n            if k.startswith(\"_\"):\n                continue",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "to_ctype",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def to_ctype(value: Any) -> Tuple[str, Any]:\n    \"\"\"Transform python type to ctype.\n    Note: we always use little-endian and 8-byte types.\n    This make the format independent of the current platform.\n    :params value:\n        value to cast into ctype\n    :returns:\n        A tuple of ctype and cvalue.\n    \"\"\"\n    if isinstance(value, int):",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "get_cpp_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def get_cpp_type(value: Any) -> str:\n    \"\"\"Return equivalent cpp type in string format\n    :params value:\n        value to cast into ctype\n    :returns:\n        str containing cpp type\n    \"\"\"\n    # used to have compatibility between types\n    try:\n        ctype, _ = to_ctype(value)",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "generate_hparams_struct",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "def generate_hparams_struct(\n    hparams: Dict[str, Any],\n    struct_name: str,\n) -> str:\n    \"\"\"Generate a c++ struct to hold the model hyper-parameters.\n    :param hparams:\n        Flattened config of the model.\n    :param struct_name:\n        Name of the generated struct.\n    \"\"\"",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "Preprocessor",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "Preprocessor = Callable[[Any], Any]\nlog = logging.getLogger(\"ggml_convert\")\nclass ModelType(str, Enum):\n    AUTO = \"auto\"  # inferred from the model name\n    UNITY = \"unity\"\n    NLLB = \"nllb\"\n    MT = \"bitext\"\n    MTS = \"bitext_scripted\"\nUNITY_SMALLER_MODELS = [\n    \"unity_nano\",",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "log = logging.getLogger(\"ggml_convert\")\nclass ModelType(str, Enum):\n    AUTO = \"auto\"  # inferred from the model name\n    UNITY = \"unity\"\n    NLLB = \"nllb\"\n    MT = \"bitext\"\n    MTS = \"bitext_scripted\"\nUNITY_SMALLER_MODELS = [\n    \"unity_nano\",\n    \"unity_micro\",",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "UNITY_SMALLER_MODELS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "UNITY_SMALLER_MODELS = [\n    \"unity_nano\",\n    \"unity_micro\",\n]  # Trained with fairseq2, with custom dict (not original NLLB ones)\nNLLB_2_UNITY_KEYMAP = {\n    r\"^encoder_frontend\\.\": r\"text_encoder_frontend.\",\n    r\"^encoder\\.\"         : r\"text_encoder.\",\n    r\"^decoder\\.\"         : r\"text_decoder.\",\n    r\"^decoder_frontend\\.\": r\"text_decoder_frontend.\",\n}",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "NLLB_2_UNITY_KEYMAP",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.ggml_convert",
        "description": "lib.seamless_communication.ggml.ggml_convert",
        "peekOfCode": "NLLB_2_UNITY_KEYMAP = {\n    r\"^encoder_frontend\\.\": r\"text_encoder_frontend.\",\n    r\"^encoder\\.\"         : r\"text_encoder.\",\n    r\"^decoder\\.\"         : r\"text_decoder.\",\n    r\"^decoder_frontend\\.\": r\"text_decoder_frontend.\",\n}\n@final\nclass NllbLikeTokenizer(SentencePieceTokenizerBase):\n    \"\"\"The only difference between this class and NllbTokenizer is it doesn't add a <pad> to control symbol list.\n    Since NllbTokenizer is defined as final, we couldn't inherit from it directly. So copying ~everything\"\"\"",
        "detail": "lib.seamless_communication.ggml.ggml_convert",
        "documentation": {}
    },
    {
        "label": "MTBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.mt",
        "description": "lib.seamless_communication.ggml.mt",
        "peekOfCode": "class MTBuilder(NllbBuilder):\n    def build_embedding(self) -> StandardEmbedding:\n        return StandardEmbedding(\n            num_embeddings=self.config.vocab_info.size,\n            embedding_dim=self.config.model_dim,\n            pad_idx=self.config.vocab_info.pad_idx,\n            init_fn=lambda x: x,\n            device=self.device,\n            dtype=self.dtype,\n        ).requires_grad_(False)",
        "detail": "lib.seamless_communication.ggml.mt",
        "documentation": {}
    },
    {
        "label": "create_mt_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.mt",
        "description": "lib.seamless_communication.ggml.mt",
        "peekOfCode": "def create_mt_model(\n    config: NllbConfig,\n    *,\n    device: Optional[Device] = None,\n    dtype: Optional[DataType] = None,\n) -> TransformerModel:\n    return MTBuilder(config, device=device, dtype=dtype).build_model()\ndef convert_mt_checkpoint(\n    ckpt: Mapping[str, Any], config: NllbConfig,\n) -> Mapping[str, Any]:",
        "detail": "lib.seamless_communication.ggml.mt",
        "documentation": {}
    },
    {
        "label": "convert_mt_checkpoint",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.mt",
        "description": "lib.seamless_communication.ggml.mt",
        "peekOfCode": "def convert_mt_checkpoint(\n    ckpt: Mapping[str, Any], config: NllbConfig,\n) -> Mapping[str, Any]:\n    global_key_map = {\n        # fmt: off\n        r\"^encoder\\.embed_tokens\\.\":                              r\"encoder_frontend.embed.\",\n        r\"^decoder\\.embed_tokens\\.\":                              r\"decoder_frontend.embed.\",\n        r\"^encoder\\.embed_positions.weights\":                     r\"encoder_frontend.pos_encoder.freqs\",\n        r\"^decoder\\.embed_positions.weights\":                     r\"decoder_frontend.pos_encoder.freqs\",\n        r\"^encoder\\.layernorm_embedding\\.\":                       r\"encoder_frontend.layer_norm.\",",
        "detail": "lib.seamless_communication.ggml.mt",
        "documentation": {}
    },
    {
        "label": "load_vocab",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.mt",
        "description": "lib.seamless_communication.ggml.mt",
        "peekOfCode": "def load_vocab(model_dir: str, mode: Literal[\"src\", \"tgt\"]):\n    vocab_file = f\"{model_dir}/{mode}.spm\"\n    spmp = spm.SentencePieceProcessor(vocab_file)\n    return [\n        (spmp.id_to_piece(id).replace(\"▁\", \" \"), spmp.get_score(id))\n        for id in range(spmp.get_piece_size())\n    ], spmp\ndef load_mt_model(model_dir: str):\n    \"\"\"\n    Load MT model and the vocabulary processors (spm) for source and target languages",
        "detail": "lib.seamless_communication.ggml.mt",
        "documentation": {}
    },
    {
        "label": "load_mt_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.mt",
        "description": "lib.seamless_communication.ggml.mt",
        "peekOfCode": "def load_mt_model(model_dir: str):\n    \"\"\"\n    Load MT model and the vocabulary processors (spm) for source and target languages\n    Args:\n        model_dir: Directory of the model. It must contain files averaged_checkpoint.pt, src.spm and tgt.spm\n    \"\"\"\n    # Create a fairseq2 model card on the fly. This must ensure that we do not have any other fairseq2\n    # environment resolvers and always return\n    model_dir = Path(model_dir)\n    model_card_info = [",
        "detail": "lib.seamless_communication.ggml.mt",
        "documentation": {}
    },
    {
        "label": "test_mt",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.mt",
        "description": "lib.seamless_communication.ggml.mt",
        "peekOfCode": "def test_mt(\n    model: TransformerModel,\n    src_spm: spm.SentencePieceProcessor,\n    tgt_spm: spm.SentencePieceProcessor,\n):\n    from fairseq2.nn.padding import pad_seqs\n    # Tokens of \"This is an example\"\n    src_tokens = torch.LongTensor([688, 153, 62, 4581, 2])\n    src_seqs, src_padding_mask = pad_seqs(src_tokens, src_spm.pad_id())\n    # Force the developer begins with the EOS <s> token",
        "detail": "lib.seamless_communication.ggml.mt",
        "documentation": {}
    },
    {
        "label": "test_ggml_bindings_work",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_ggml_bindings_work(ctx: Ctx) -> None:\n    # Instantiate tensors\n    x = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\n    a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\n    b = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\n    # Use ggml operations to build a computational graph\n    x2 = ggml.ggml_mul(ctx, x, x)\n    f = ggml.ggml_add(ctx, ggml.ggml_mul(ctx, a, x2), b)\n    gf = ggml.ggml_build_forward(f)\n    # Set the input values",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_ggml_matmul",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_ggml_matmul(ctx: Ctx) -> None:\n    # Instantiate tensors\n    a = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F32, 4, 2)\n    x = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F32, 4, 3)\n    # Use ggml operations to build a computational graph\n    y = ggml.ggml_mul_mat(ctx, a, x)\n    assert ggml.shape(y) == (3, 2)\n    gf = ggml.ggml_build_forward(y)\n    # Set the input values\n    ggml.ggml_set_f32(x, 0.0)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_shape_works",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_shape_works(ctx: Ctx) -> None:\n    \"\"\"GGML shape order convention is the reverse from numpy\"\"\"\n    a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 10)\n    assert ggml.shape(a) == (10,)\n    b = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F32, 11, 21)\n    assert ggml.shape(b) == (21, 11)\n    c = ggml.ggml_new_tensor_3d(ctx, ggml.GGML_TYPE_F32, 12, 22, 32)\n    assert ggml.shape(c) == (32, 22, 12)\ndef test_nb_works(ctx: Ctx) -> None:\n    a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 10)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_nb_works",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_nb_works(ctx: Ctx) -> None:\n    a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 10)\n    assert ggml.nb(a) == (4, 40, 40, 40)\n    b = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F16, 11, 21)\n    assert ggml.nb(b) == (2, 22, 462, 462)\n    c = ggml.ggml_new_tensor_3d(ctx, ggml.GGML_TYPE_F32, 12, 22, 32)\n    assert ggml.nb(c) == (4, 48, 1056, 33792)\ndef test_strides_works(ctx: Ctx) -> None:\n    a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 10)\n    assert ggml.strides(a) == np.ones((10,), dtype=np.float32).strides",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_strides_works",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_strides_works(ctx: Ctx) -> None:\n    a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 10)\n    assert ggml.strides(a) == np.ones((10,), dtype=np.float32).strides\n    b = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F32, 11, 21)\n    assert ggml.strides(b) == np.ones((21, 11), dtype=np.float32).strides\n    c = ggml.ggml_new_tensor_3d(ctx, ggml.GGML_TYPE_F32, 12, 22, 32)\n    assert ggml.strides(c) == np.ones((32, 22, 12), dtype=np.float32).strides\ndef test_to_numpy_works_with_f32(ctx: Ctx) -> None:\n    a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 10)\n    na = ggml.to_numpy(a)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_to_numpy_works_with_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_to_numpy_works_with_f32(ctx: Ctx) -> None:\n    a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 10)\n    na = ggml.to_numpy(a)\n    for i in range(10):\n        ggml.ggml_set_f32_1d(a, i, i)\n    assert na[5] == 5\n    assert np.allclose(na, np.array(range(10), dtype=np.float32))\n    ggml.ggml_set_f32_1d(a, 5, -1.5)\n    assert na[5] == -1.5\n    # Note: GGML order of dims is reversed wrt numpy shapes",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_from_numpy_works_with_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_from_numpy_works_with_f32(ctx: Ctx) -> None:\n    a = np.random.normal(size=(10,)).astype(dtype=np.float32)\n    ga = ggml.from_numpy(ctx, a)\n    assert ggml.shape(ga) == (10,)\n    assert ggml.nb(ga) == ggml.nb(ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 10))\n    assert np.allclose(a, ggml.to_numpy(ga))\n    a = np.random.normal(size=(11, 21)).astype(dtype=np.float32)\n    ga = ggml.from_numpy(ctx, a)\n    assert ggml.shape(ga) == (11, 21)\n    assert ggml.nb(ga) == ggml.nb(",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_to_numpy_works_with_f16",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_to_numpy_works_with_f16(ctx: Ctx) -> None:\n    # We explicitly fill the tensor otherwise they might have non-zero values in them.\n    a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F16, 10)\n    na = ggml.to_numpy(a)\n    ggml.ggml_set_f32(a, 2.14)\n    assert np.allclose(na, np.ones((10,), dtype=np.float16) * 2.14)\n    ggml.ggml_set_f32(a, 4.28)\n    assert np.allclose(na, np.ones((10,), dtype=np.float16) * 4.28)\n    b = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F16, 11, 21)\n    nb = ggml.to_numpy(b)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_from_numpy_works_with_f16",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_from_numpy_works_with_f16(ctx: Ctx) -> None:\n    a = np.random.normal(size=(10,)).astype(dtype=np.float16)\n    ga = ggml.from_numpy(ctx, a)\n    assert np.allclose(a, ggml.to_numpy(ga))\n    a = np.random.normal(size=(11, 21)).astype(dtype=np.float16)\n    ga = ggml.from_numpy(ctx, a)\n    assert np.allclose(a, ggml.to_numpy(ga))\n    a = np.random.normal(size=(12, 22, 32)).astype(dtype=np.float16)\n    ga = ggml.from_numpy(ctx, a)\n    assert np.allclose(a, ggml.to_numpy(ga))",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_to_numpy_works_with_transposed",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_to_numpy_works_with_transposed(ctx: Ctx) -> None:\n    ga = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F32, 10, 5)\n    a = ggml.to_numpy(ga)\n    a[...] = np.arange(50).reshape(5, 10).astype(dtype=np.float32)\n    gat = ggml.ggml_transpose(ctx, ga)\n    at = ggml.to_numpy(gat)\n    assert np.allclose(a.T, at)\ndef test_ggml_slice(ctx: Ctx) -> None:\n    ga = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F32, 10, 5)\n    a = ggml.to_numpy(ga)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_ggml_slice",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_ggml_slice(ctx: Ctx) -> None:\n    ga = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F32, 10, 5)\n    a = ggml.to_numpy(ga)\n    a[...] = np.arange(50).reshape(5, 10).astype(dtype=np.float32)\n    gs0 = ggml.ggml_slice(ctx, ga, 0, 3, 7)\n    s0 = ggml.to_numpy(gs0)\n    assert np.allclose(a[:, 3:7], s0)\n    gs1 = ggml.ggml_slice(ctx, ga, 1, 2, 5)\n    s1 = ggml.to_numpy(gs1)\n    assert np.allclose(a[2:5, :], s1)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_ggml_transpose_and_slice",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_ggml_transpose_and_slice(ctx: Ctx) -> None:\n    ga = ggml.ggml_new_tensor_2d(ctx, ggml.GGML_TYPE_F32, 10, 5)\n    a = ggml.to_numpy(ga)\n    a[...] = np.arange(50).reshape(5, 10).astype(dtype=np.float32)\n    gat = ggml.ggml_transpose(ctx, ga)\n    gs0 = ggml.ggml_slice(ctx, gat, 0, 2, 5)\n    s0 = ggml.to_numpy(gs0)\n    assert np.allclose(a.T[:, 2:5], s0)\n    gs1 = ggml.ggml_slice(ctx, gat, 1, 3, 7)\n    s1 = ggml.to_numpy(gs1)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_numpy_mul_mat",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_numpy_mul_mat(ctx: Ctx) -> None:\n    slen, d_in, d_out = (5, 4, 2)\n    # torch.nn and fairseq2.nn assumes (seq_len, dim) to represent inputs,\n    x = np.zeros((slen, d_in), dtype=np.float32)  # (seq_len, dim_in)\n    x[0, :] = [1, 1 / 3, 0, 0]\n    weight = np.eye(d_out, d_in, dtype=np.float32)\n    weight[1, 1] = 1\n    # assert weight.shape == (d_out, d_in) # (dim_out, dim_in)\n    y_exp = x @ weight.T  # (seq_len, dim_out)\n    gx = ggml.from_numpy(ctx, x)  # (dim_in, seq_len)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_flatten",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_flatten(ctx: Ctx, ndim: int) -> None:\n    shape = [11, 7, 5, 3][:ndim]  # Prime numbers to avoid surprises\n    numel = functools.reduce(lambda a, b: a * b, shape, 1)\n    x = torch.arange(numel, dtype=torch.float32).reshape(shape)\n    for torch_dim in range(ndim - 1):\n        ggml_dim = ndim - 1 - torch_dim\n        n = x.shape[torch_dim + 1]\n        gx = ggml.from_numpy(ctx, x)\n        gx1 = ggml.ggml_flatten_1d(ctx, gx, ggml_dim - 1)\n        gy = ggml.ggml_unflatten_1d(ctx, gx1, ggml_dim - 1, n)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_torch_spda_vs_ggml_flash_attn",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_torch_spda_vs_ggml_flash_attn(ctx: Ctx) -> None:\n    slen, d_in, num_heads = (5, 4, 2)\n    torch.random.manual_seed(0)\n    q = torch.zeros((num_heads, slen, d_in))\n    torch.nn.init.uniform_(q, -1, 1)\n    k = torch.zeros((num_heads, slen, d_in))\n    torch.nn.init.uniform_(k, -1, 1)\n    v = torch.zeros((num_heads, slen, d_in))\n    torch.nn.init.uniform_(v, -1, 1)\n    # Note: we are using x for both keys and queries, so every position",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_ggml_softmax_vs_torch",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_ggml_softmax_vs_torch(ctx: Ctx, shape: Tuple[int, ...]) -> None:\n    x = torch.empty(shape)\n    torch.nn.init.uniform_(x, -1, 1)\n    y_exp = torch.softmax(x, dim=-1).numpy()\n    gx = ggml.from_numpy(ctx, x.numpy())\n    gy = ggml.ggml_soft_max(ctx, gx)\n    ggml.build_and_compute(ctx, gy)\n    y = ggml.to_numpy(gy)\n    assert np.allclose(y_exp, y, rtol=1e-3)\n    assert np.allclose(np.argmax(y_exp, axis=-1), np.argmax(y, axis=-1))",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_can_return_hypothesis_ptr",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_can_return_hypothesis_ptr(ctx: Ctx) -> None:\n    hyp_ptr = ggml._testing_return_hypothesis_ptr(ctx)\n    hyp0, hyp1 = hyp_ptr[0], hyp_ptr[1]\n    assert ggml.to_numpy(hyp0.seq).tolist() == [314]\n    assert hyp0.score == pytest.approx(3.14)\n    assert ggml.to_numpy(hyp1.seq).tolist() == [421]\n    assert hyp1.score == pytest.approx(4.21)\n@pytest.mark.parametrize(\"inplace\", [\"\", \"inplace\"])\ndef test_set_2d(ctx: Ctx, inplace: bool):\n    a = torch.empty((5, 3, 2))",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "test_set_2d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "def test_set_2d(ctx: Ctx, inplace: bool):\n    a = torch.empty((5, 3, 2))\n    torch.nn.init.uniform_(a, -1, 1)\n    b = torch.empty((3, 2))\n    torch.nn.init.uniform_(b, -1, 1)\n    a_original = a.clone()\n    # make a copy of `a` before we modify it\n    ga = ggml.from_numpy(ctx, a.clone().numpy())\n    gb = ggml.from_numpy(ctx, b.numpy())\n    a[3, ...] = b",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "Ctx",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "Ctx = ggml.ggml_context_p\nUNITY_MODELS = Path(__file__).parent / \"examples/unity/models\"\nCTX_PARAMS = ggml.ggml_init_params(mem_size=16 * 1024 * 1024, mem_buffer=None)\n@pytest.fixture(name=\"ctx\")\ndef _ctx() -> Iterator[Ctx]:\n    \"\"\"Allocate a new context with 16 MB of memory\"\"\"\n    try:\n        ctx = ggml.ggml_init(params=CTX_PARAMS)\n        yield ctx\n    finally:",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "UNITY_MODELS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "UNITY_MODELS = Path(__file__).parent / \"examples/unity/models\"\nCTX_PARAMS = ggml.ggml_init_params(mem_size=16 * 1024 * 1024, mem_buffer=None)\n@pytest.fixture(name=\"ctx\")\ndef _ctx() -> Iterator[Ctx]:\n    \"\"\"Allocate a new context with 16 MB of memory\"\"\"\n    try:\n        ctx = ggml.ggml_init(params=CTX_PARAMS)\n        yield ctx\n    finally:\n        ggml.ggml_free(ctx)",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "CTX_PARAMS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_ggml_integration",
        "description": "lib.seamless_communication.ggml.test_ggml_integration",
        "peekOfCode": "CTX_PARAMS = ggml.ggml_init_params(mem_size=16 * 1024 * 1024, mem_buffer=None)\n@pytest.fixture(name=\"ctx\")\ndef _ctx() -> Iterator[Ctx]:\n    \"\"\"Allocate a new context with 16 MB of memory\"\"\"\n    try:\n        ctx = ggml.ggml_init(params=CTX_PARAMS)\n        yield ctx\n    finally:\n        ggml.ggml_free(ctx)\ndef test_ggml_bindings_work(ctx: Ctx) -> None:",
        "detail": "lib.seamless_communication.ggml.test_ggml_integration",
        "documentation": {}
    },
    {
        "label": "g_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def g_model(ctx: Ctx) -> c_void_p:\n    model = _load_g_model_once()\n    ggml.lib.fairseq2_model_set_inference_ctx(model.ptr, ctx)\n    return model.ptr\n@functools.lru_cache(maxsize=1)\ndef load_translator() -> Translator:\n    return Translator(\"seamlessM4T_medium\", None, device=torch.device(\"cpu\"))\ndef load_pt_model() -> Any:\n    return load_translator().model\ndef download_sample_audio() -> Any:",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "load_translator",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def load_translator() -> Translator:\n    return Translator(\"seamlessM4T_medium\", None, device=torch.device(\"cpu\"))\ndef load_pt_model() -> Any:\n    return load_translator().model\ndef download_sample_audio() -> Any:\n    Path(DATA).mkdir(exist_ok=True)\n    response = requests.get(TEST_AUDIO_SAMPLE_URL, stream=True)\n    with open(DATA / \"LJ037-0171_sr16k.wav\", \"wb\") as file:\n        for chunk in response.iter_content(chunk_size=1024):\n            if chunk:",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "load_pt_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def load_pt_model() -> Any:\n    return load_translator().model\ndef download_sample_audio() -> Any:\n    Path(DATA).mkdir(exist_ok=True)\n    response = requests.get(TEST_AUDIO_SAMPLE_URL, stream=True)\n    with open(DATA / \"LJ037-0171_sr16k.wav\", \"wb\") as file:\n        for chunk in response.iter_content(chunk_size=1024):\n            if chunk:\n                file.write(chunk)\ndef test_convert_linear(tmp_path: Path) -> None:",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "download_sample_audio",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def download_sample_audio() -> Any:\n    Path(DATA).mkdir(exist_ok=True)\n    response = requests.get(TEST_AUDIO_SAMPLE_URL, stream=True)\n    with open(DATA / \"LJ037-0171_sr16k.wav\", \"wb\") as file:\n        for chunk in response.iter_content(chunk_size=1024):\n            if chunk:\n                file.write(chunk)\ndef test_convert_linear(tmp_path: Path) -> None:\n    module = fairseq2.nn.Linear(16, 24, True)\n    layer_config = read_layer_config(module, \"\")",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_convert_linear",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_convert_linear(tmp_path: Path) -> None:\n    module = fairseq2.nn.Linear(16, 24, True)\n    layer_config = read_layer_config(module, \"\")\n    assert layer_config == {\"input_dim\": 16, \"output_dim\": 24}\n    module_file = tmp_path / \"module.ggml\"\n    convert_model(module, module_file)\n    g_module = ggml.load_fairseq2_ggml_file(module_file)\n    for k, v in layer_config.items():\n        assert (\n            ggml.fairseq2_model_layer_config_int(g_module.ptr, bytes(k, \"ascii\")) == v",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_convert_linear_fp16",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_convert_linear_fp16(tmp_path: Path, ctx: Ctx) -> None:\n    pt_model = torch.nn.ModuleDict({\"linear\": fairseq2.nn.Linear(16, 24, True)})\n    layer_config = read_layer_config(pt_model, \"\")\n    assert layer_config == {\"linear.input_dim\": 16, \"linear.output_dim\": 24}\n    ggml_file = tmp_path / \"linear.ggml\"\n    convert_model(pt_model, ggml_file, fp16=True)\n    assert ggml_file.stat().st_size < (16 * 24 + 24) * 2 * 1.5\n    g_model = ggml.load_fairseq2_ggml_file(ggml_file)\n    ggml.lib.fairseq2_model_set_inference_ctx(g_model.ptr, ctx)\n    x = torch.empty((2, 5, 16))",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_causal_attention_mask",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_causal_attention_mask(ctx: Ctx):\n    x = torch.zeros((1, 10, 32))\n    generator = fairseq2.nn.transformer.CausalAttentionMaskFactory()\n    mask_exp = generator(x, x).materialize().numpy()\n    gx = ggml.from_numpy(ctx, x)\n    gmask = ggml.causal_attention_mask(ctx, gx)\n    ggml.build_and_compute(ctx, gmask)\n    mask = ggml.to_numpy(gmask)\n    assert mask_exp.shape == (10, 10)\n    assert mask.shape == (10, 10)",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_LayerNorm_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_LayerNorm_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    x = torch.empty((2, 21, 1024))\n    torch.nn.init.uniform_(x, -1, 1)\n    pt_model = load_pt_model()\n    y_exp = pt_model.text_encoder.layers[0].ffn_layer_norm(x).numpy()\n    gx = ggml.from_numpy(ctx, x)\n    gy = ggml.forward(\"LayerNorm\", g_model, \"text_encoder.layers.0.ffn_layer_norm\", gx)\n    ggml.build_and_compute(ctx, gy)\n    y = ggml.to_numpy(gy)\n    assert np.allclose(y_exp, y, atol=1e-5)",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_Linear_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_Linear_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    x = torch.empty((2, 21, 1024))\n    torch.nn.init.uniform_(x, -1, 1)\n    pt_model = load_pt_model()\n    y_exp = pt_model.text_encoder.layers[0].ffn.inner_proj(x).numpy()\n    gx = ggml.from_numpy(ctx, x)\n    gy = ggml.forward(\"Linear\", g_model, \"text_encoder.layers.0.ffn.inner_proj\", gx)\n    ggml.build_and_compute(ctx, gy, dump=\"dot/test_Linear_forward.dot\")\n    y = ggml.to_numpy(gy)\n    assert np.allclose(y_exp, y, atol=1e-5)",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_FeedForwardNetwork_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_FeedForwardNetwork_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    x = torch.empty((2, 21, 1024))  # (bs, seq_len, model_dim)\n    torch.nn.init.uniform_(x, -1 / 32, 1 / 32)\n    # Test FFN without LayerNorm\n    pt_model = load_pt_model()\n    y_exp = pt_model.text_encoder.layers[0].ffn(x).numpy()\n    gx = ggml.from_numpy(ctx, x)\n    gy = ggml.forward(\n        \"StandardFeedForwardNetwork\", g_model, \"text_encoder.layers.0.ffn\", gx\n    )",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_MultiheadAttention_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_MultiheadAttention_forward(\n    ctx: Ctx, g_model: c_void_p, lengths: Tuple[int, int]\n) -> None:\n    x = torch.empty((2, 21, 1024))\n    torch.random.manual_seed(0)\n    torch.nn.init.uniform_(x, -1, 1)\n    # Note: we use different lengths for queries and keys,\n    # this tests the implementation in decoding context too.\n    # Note2: ggml_flash_attn requires that we have more keys than queries\n    # qlen, klen = (11, 21) if flash_attn else (21, 13)",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_MultiheadAttention_forward_self_attn_with_cache",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_MultiheadAttention_forward_self_attn_with_cache(\n    ctx: Ctx, g_model: c_void_p\n) -> None:\n    pt_model = load_pt_model()\n    attn = pt_model.text_decoder.layers[0].self_attn\n    x = torch.empty((2, 21, 1024))\n    torch.random.manual_seed(0)\n    torch.nn.init.uniform_(x, -1, 1)\n    state_bag = fairseq2.nn.IncrementalStateBag(100)\n    with ggml.fairseq2_kv_cache_alloc(g_model, 16 * MB, 2, 21):",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_MultiheadAttention_forward_cross_attn_with_cache",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_MultiheadAttention_forward_cross_attn_with_cache(\n    ctx: Ctx, g_model: c_void_p\n) -> None:\n    pt_model = load_pt_model()\n    attn = pt_model.text_decoder.layers[0].encoder_decoder_attn\n    x = torch.empty((2, 21, 1024))\n    torch.random.manual_seed(0)\n    torch.nn.init.uniform_(x, -1, 1)\n    state_bag = fairseq2.nn.IncrementalStateBag(100)\n    with ggml.fairseq2_kv_cache_alloc(g_model, 16 * MB, 2, 21):",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_StandardTransformerEncoderLayer_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_StandardTransformerEncoderLayer_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    x = torch.empty((2, 21, 1024))\n    torch.random.manual_seed(0)\n    torch.nn.init.uniform_(x, -1, 1)\n    pt_model = load_pt_model()\n    layer = pt_model.text_encoder.layers[0]\n    gx = ggml.from_numpy(ctx, x)\n    ggml.ggml_set_name(gx, b\"x\")\n    gy = ggml.forward(\n        \"StandardTransformerEncoderLayer\",",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_StandardConformerEncoderLayer_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_StandardConformerEncoderLayer_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    pt_model = load_pt_model()\n    x = torch.rand(1, 137, 1024)\n    layer = pt_model.speech_encoder.inner.layers[0]\n    gx = ggml.from_numpy(ctx, x[0])\n    ggml.ggml_set_name(gx, b\"x\")\n    gy = ggml.forward(\n        \"StandardConformerEncoderLayer\",\n        g_model,\n        \"speech_encoder.inner.layers.0\",",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_StandardConformerEncoderAdaptorLayer_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_StandardConformerEncoderAdaptorLayer_forward(\n    ctx: Ctx, g_model: c_void_p\n) -> None:\n    pt_model = load_pt_model()\n    torch.random.manual_seed(0)\n    x = torch.rand(1, 137, 1024)\n    layer = pt_model.speech_encoder.adaptor_layers[0]\n    gx = ggml.from_numpy(ctx, x[0])\n    ggml.ggml_set_name(gx, b\"x\")\n    gy = ggml.forward(",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_StandardTransformerEncoder_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_StandardTransformerEncoder_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    x = torch.empty((2, 21, 1024))\n    padding_mask = fairseq2.nn.padding.PaddingMask(torch.tensor([21, 21]), 21)\n    torch.random.manual_seed(0)\n    torch.nn.init.uniform_(x, -1, 1)\n    gx = ggml.from_numpy(ctx, x)\n    ggml.ggml_set_name(gx, b\"x\")\n    gpad = ggml.from_numpy(ctx, padding_mask.materialize())\n    ggml.ggml_set_name(gpad, b\"padding_mask\")\n    gy = ggml.forward(",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_StandardConformerEncoder_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_StandardConformerEncoder_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    pt_model = load_pt_model()\n    if not LOCAL_AUDIO_SAMPLE_PATH.exists():\n        download_sample_audio()\n    wav, _ = torchaudio.load(LOCAL_AUDIO_SAMPLE_PATH)\n    gx = ggml.from_numpy(ctx, wav * 2**15)  # Apply scale before sending into ggml!\n    ggml.ggml_set_name(gx, b\"x\")\n    gy = ggml.forward(\n        \"StandardConformerEncoder\",\n        g_model,",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_WaveformToFbank_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_WaveformToFbank_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    converter = WaveformToFbankConverter(\n        num_mel_bins=80,\n        waveform_scale=2**15,\n        channel_last=True,\n        standardize=True,\n    )\n    extractor = Wav2Vec2FbankFeatureExtractor(80, stride=2, sample_every_k=1)\n    if not LOCAL_AUDIO_SAMPLE_PATH.exists():\n        download_sample_audio()",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_PositionalEmbedding_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_PositionalEmbedding_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    seq = torch.zeros((4, 20, 1024), dtype=torch.float32)\n    pos_encoder = fairseq2.nn.SinusoidalPositionEncoder(1024, 55, _legacy_pad_idx=1)\n    y_exp = pos_encoder(seq, None)[0].numpy()\n    gseq = ggml.from_numpy(ctx, seq[0].clone().numpy())\n    ggml.ggml_set_name(gseq, b\"seq\")\n    gy = ggml.forward(\n        \"PositionalEmbedding\", g_model, \"text_decoder_frontend.pos_encoder\", gseq\n    )\n    gf = ggml.build_and_compute(ctx, gy, dump=True)",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_PositionalEmbedding_forward_with_cache",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_PositionalEmbedding_forward_with_cache(ctx: Ctx, g_model: c_void_p) -> None:\n    seq = torch.zeros((4, 20, 1024), dtype=torch.float32)\n    pos_encoder = fairseq2.nn.SinusoidalPositionEncoder(1024, 55, _legacy_pad_idx=1)\n    pos_encoder.eval()\n    state_bag = fairseq2.nn.IncrementalStateBag(100)\n    with ggml.fairseq2_kv_cache_alloc(g_model, 16 * MB, 2, 21):\n        # Incremental decoding\n        for t in range(20):\n            gseq = ggml.from_numpy(ctx, seq[:, t : t + 1, :].numpy())\n            ggml.ggml_set_name(gseq, b\"seq\")",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_TransformerEmbeddingFrontend_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_TransformerEmbeddingFrontend_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    seq = torch.arange(2 * 20).reshape(2, 20)\n    seq[1, 15:] = 0  # padding for second sentence\n    seq_len = torch.tensor([20, 15])\n    gseq = ggml.from_numpy(ctx, seq.numpy().astype(np.int32))\n    ggml.ggml_set_name(gseq, b\"seq\")\n    gy = ggml.forward(\n        \"TransformerEmbeddingFrontend\", g_model, \"text_decoder_frontend\", gseq\n    )\n    ggml.build_and_compute(ctx, gy)",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_StandardTransformerDecoderLayer_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_StandardTransformerDecoderLayer_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    x = torch.empty((2, 13, 1024))\n    encoder_out = torch.empty((2, 21, 1024))\n    torch.random.manual_seed(0)\n    torch.nn.init.uniform_(x, -1, 1)\n    torch.nn.init.uniform_(encoder_out, -1, 1)\n    self_attn_mask = fairseq2.nn.transformer.CausalAttentionMaskFactory()(x, x)\n    gx = ggml.from_numpy(ctx, x)\n    ggml.ggml_set_name(gx, b\"x\")\n    gself_attn_mask = ggml.from_numpy(ctx, self_attn_mask.materialize().numpy())",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_StandardTransformerDecoder_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_StandardTransformerDecoder_forward(ctx: Ctx, g_model: c_void_p) -> None:\n    x = torch.empty((2, 13, 1024))\n    encoder_out = torch.empty((2, 21, 1024))\n    padding_mask = fairseq2.nn.padding.PaddingMask(torch.tensor([13, 13]), 13)\n    torch.random.manual_seed(0)\n    torch.nn.init.uniform_(x, -1, 1)\n    torch.nn.init.uniform_(encoder_out, -1, 1)\n    gx = ggml.from_numpy(ctx, x)\n    ggml.ggml_set_name(gx, b\"x\")\n    gpad = ggml.from_numpy(ctx, padding_mask.materialize())",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "test_s2tt",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "def test_s2tt(ctx: Ctx, g_model: c_void_p):\n    if not LOCAL_AUDIO_SAMPLE_PATH.exists():\n        download_sample_audio()\n    src_audio_wav, _ = torchaudio.load(LOCAL_AUDIO_SAMPLE_PATH)\n    sample_file = DATA / \"LJ037-0171_sr16k.wav.trans\"\n    translator = load_translator()\n    if not sample_file.exists():\n        decoded_audio = {\n            \"waveform\": src_audio_wav.t(),\n            \"sample_rate\": 16000.0,",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "Ctx",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "Ctx = ggml.ggml_context_p\nUNITY_MODELS = Path(__file__).parent / \"examples/unity/models\"\nFAIRSEQ2_CPP = Path(__file__).parent / \"examples/unity/fairseq2.cpp\"\nUNITY_FLASH_ATTN = \"\\n# define UNITY_FLASH_ATTN 0\\n\" not in FAIRSEQ2_CPP.read_text()\nDATA = Path(__file__).parent / \"test_data\"\nLOCAL_AUDIO_SAMPLE_PATH = DATA / \"LJ037-0171_sr16k.wav\"\nTEST_AUDIO_SAMPLE_URL = (\n    \"https://dl.fbaipublicfiles.com/seamless/tests/LJ037-0171_sr16k.wav\"\n)\nMB = 1024 * 1024",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "UNITY_MODELS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "UNITY_MODELS = Path(__file__).parent / \"examples/unity/models\"\nFAIRSEQ2_CPP = Path(__file__).parent / \"examples/unity/fairseq2.cpp\"\nUNITY_FLASH_ATTN = \"\\n# define UNITY_FLASH_ATTN 0\\n\" not in FAIRSEQ2_CPP.read_text()\nDATA = Path(__file__).parent / \"test_data\"\nLOCAL_AUDIO_SAMPLE_PATH = DATA / \"LJ037-0171_sr16k.wav\"\nTEST_AUDIO_SAMPLE_URL = (\n    \"https://dl.fbaipublicfiles.com/seamless/tests/LJ037-0171_sr16k.wav\"\n)\nMB = 1024 * 1024\n@pytest.fixture(name=\"ctx\")",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "FAIRSEQ2_CPP",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "FAIRSEQ2_CPP = Path(__file__).parent / \"examples/unity/fairseq2.cpp\"\nUNITY_FLASH_ATTN = \"\\n# define UNITY_FLASH_ATTN 0\\n\" not in FAIRSEQ2_CPP.read_text()\nDATA = Path(__file__).parent / \"test_data\"\nLOCAL_AUDIO_SAMPLE_PATH = DATA / \"LJ037-0171_sr16k.wav\"\nTEST_AUDIO_SAMPLE_URL = (\n    \"https://dl.fbaipublicfiles.com/seamless/tests/LJ037-0171_sr16k.wav\"\n)\nMB = 1024 * 1024\n@pytest.fixture(name=\"ctx\")\ndef _ctx() -> Iterator[Ctx]:",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "UNITY_FLASH_ATTN",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "UNITY_FLASH_ATTN = \"\\n# define UNITY_FLASH_ATTN 0\\n\" not in FAIRSEQ2_CPP.read_text()\nDATA = Path(__file__).parent / \"test_data\"\nLOCAL_AUDIO_SAMPLE_PATH = DATA / \"LJ037-0171_sr16k.wav\"\nTEST_AUDIO_SAMPLE_URL = (\n    \"https://dl.fbaipublicfiles.com/seamless/tests/LJ037-0171_sr16k.wav\"\n)\nMB = 1024 * 1024\n@pytest.fixture(name=\"ctx\")\ndef _ctx() -> Iterator[Ctx]:\n    \"\"\"Allocate a new context with 1024 MB of memory\"\"\"",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "DATA",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "DATA = Path(__file__).parent / \"test_data\"\nLOCAL_AUDIO_SAMPLE_PATH = DATA / \"LJ037-0171_sr16k.wav\"\nTEST_AUDIO_SAMPLE_URL = (\n    \"https://dl.fbaipublicfiles.com/seamless/tests/LJ037-0171_sr16k.wav\"\n)\nMB = 1024 * 1024\n@pytest.fixture(name=\"ctx\")\ndef _ctx() -> Iterator[Ctx]:\n    \"\"\"Allocate a new context with 1024 MB of memory\"\"\"\n    try:",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "LOCAL_AUDIO_SAMPLE_PATH",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "LOCAL_AUDIO_SAMPLE_PATH = DATA / \"LJ037-0171_sr16k.wav\"\nTEST_AUDIO_SAMPLE_URL = (\n    \"https://dl.fbaipublicfiles.com/seamless/tests/LJ037-0171_sr16k.wav\"\n)\nMB = 1024 * 1024\n@pytest.fixture(name=\"ctx\")\ndef _ctx() -> Iterator[Ctx]:\n    \"\"\"Allocate a new context with 1024 MB of memory\"\"\"\n    try:\n        mem_size = 16 * MB",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "TEST_AUDIO_SAMPLE_URL",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "TEST_AUDIO_SAMPLE_URL = (\n    \"https://dl.fbaipublicfiles.com/seamless/tests/LJ037-0171_sr16k.wav\"\n)\nMB = 1024 * 1024\n@pytest.fixture(name=\"ctx\")\ndef _ctx() -> Iterator[Ctx]:\n    \"\"\"Allocate a new context with 1024 MB of memory\"\"\"\n    try:\n        mem_size = 16 * MB\n        memory = torch.zeros(mem_size, dtype=torch.uint8)",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "MB",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.test_unity_cpp",
        "description": "lib.seamless_communication.ggml.test_unity_cpp",
        "peekOfCode": "MB = 1024 * 1024\n@pytest.fixture(name=\"ctx\")\ndef _ctx() -> Iterator[Ctx]:\n    \"\"\"Allocate a new context with 1024 MB of memory\"\"\"\n    try:\n        mem_size = 16 * MB\n        memory = torch.zeros(mem_size, dtype=torch.uint8)\n        ctx = ggml.ggml_init(\n            params=ggml.ggml_init_params(\n                mem_size=mem_size,",
        "detail": "lib.seamless_communication.ggml.test_unity_cpp",
        "documentation": {}
    },
    {
        "label": "ggml_object",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_object(ctypes.Structure):\n    pass\nggml_object._fields_ = [\n    (\"offs\", ctypes.c_size_t),\n    (\"size\", ctypes.c_size_t),\n    (\"next\", ctypes.POINTER(ggml_object)),\n    (\"type\", ctypes.c_int),\n    (\"padding\", ctypes.c_char * 4),\n]\nggml_object_p: TypeAlias = \"ctypes._Pointer[ggml_object]\"  # type: ignore",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tensor",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_tensor(ctypes.Structure):\n    \"\"\"n-dimensional tensor\n    Attributes:\n        type (int): ggml_type\n        backend (int): ggml_backend\n        buffer (ctypes.pointer[ggml_backend_buffer]): pointer to backend buffer\n        n_dims (int): number of dimensions\n        ne (ctypes.Array[ctypes.c_int64]): number of elements in each dimension\n        nb (ctypes.Array[ctypes.c_size_t]): stride in bytes for each dimension\n        op (int): ggml operation",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cplan",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_cplan(ctypes.Structure):\n    \"\"\"Compute plan for a ggml computation graph\n    Attributes:\n        work_size (int): size of work buffer\n        work_data (ctypes.pointer[ctypes.c_uint8]): work buffer\n        n_threads (int): number of threads\n        abort_callback (abort_callback_t): abort callback\n        abort_callback_data (ctypes.c_void_p): abort callback data\n    \"\"\"\n    _fields_ = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_hash_set",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_hash_set(ctypes.Structure):\n    _fields_ = [\n        (\"size\", ctypes.c_size_t),\n        (\"keys\", ctypes.POINTER(ctypes.POINTER(ggml_tensor))),\n    ]\n# // computation graph\n# struct ggml_cgraph {\n#     int size;\n#     int n_nodes;\n#     int n_leafs;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cgraph",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_cgraph(ctypes.Structure):\n    \"\"\"ggml computation graph\n    Attributes:\n        n_nodes (int): number of nodes\n        n_leafs (int): number of leafs\n        nodes (ctypes.Array[ggml_tensor_p]): `n_nodes`-length array of compute tensors\n        grads (ctypes.Array[ggml_tensor_p]): `n_nodes`-length array of gradient tensors\n        leafs (ctypes.Array[ggml_tensor_p]): `n_leafs`-length array of parameter tensors\n        visited_hash_table (ctypes.Array[ctypes.POINTER(ggml_tensor)]): hash table of visited tensors\n        order (int): evaluation order",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_scratch",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_scratch(ctypes.Structure):\n    _fields_ = [\n        (\"offs\", ctypes.c_size_t),\n        (\"size\", ctypes.c_size_t),\n        (\"data\", ctypes.c_void_p),\n    ]\n# struct ggml_init_params {\n#     // memory pool\n#     size_t mem_size;   // bytes\n#     void * mem_buffer; // if NULL, memory will be allocated internally",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_init_params",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_init_params(ctypes.Structure):\n    \"\"\"Initialization parameters for a ggml context\n    **NOTE**: Reference counting does not cross into ggml, if you allocate a memory buffer\n    in python using ctypes Arrays or a numpy array, you must keep a reference to it until\n    you free the ggml context otherwise you will encounter a segmentation fault.\n    Attributes:\n        mem_size (int): size of memory pool in bytes\n        mem_buffer (ctypes.c_void_p): pointer to memory pool, if None, memory will be allocated internally\n        no_alloc (bool): don't allocate memory for tensor data\n    \"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_compute_params",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_compute_params(ctypes.Structure):\n    _fields_ = [\n        (\"type\", ctypes.c_int),\n        (\"ith\", ctypes.c_int),\n        (\"nth\", ctypes.c_int),\n        (\"wsize\", ctypes.c_size_t),\n        (\"wdata\", ctypes.c_void_p),\n    ]\nggml_compute_params_p: TypeAlias = \"ctypes._Pointer[ggml_compute_params]\"  # type: ignore\n# // misc",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_params_adam",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_opt_params_adam(ctypes.Structure):\n    _fields_ = [\n        (\"n_iter\", ctypes.c_int),\n        (\"sched\", ctypes.c_float),\n        (\"decay\", ctypes.c_float),\n        (\"decay_min_ndim\", ctypes.c_int),\n        (\"alpha\", ctypes.c_float),\n        (\"beta1\", ctypes.c_float),\n        (\"beta2\", ctypes.c_float),\n        (\"eps\", ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_params_lbfgs",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_opt_params_lbfgs(ctypes.Structure):\n    _fields_ = [\n        (\"m\", ctypes.c_int),\n        (\"n_iter\", ctypes.c_int),\n        (\"max_linesearch\", ctypes.c_int),\n        (\"eps\", ctypes.c_float),\n        (\"ftol\", ctypes.c_float),\n        (\"wolfe\", ctypes.c_float),\n        (\"min_step\", ctypes.c_float),\n        (\"max_step\", ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_params",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_opt_params(ctypes.Structure):\n    _fields_ = [\n        (\"type\", ctypes.c_int),\n        (\"graph_size\", ctypes.c_size_t),\n        (\"n_threads\", ctypes.c_int),\n        (\"past\", ctypes.c_int),\n        (\"delta\", ctypes.c_float),\n        (\"max_no_improvement\", ctypes.c_int),\n        (\"print_forward_graph\", ctypes.c_bool),\n        (\"print_backward_graph\", ctypes.c_bool),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_context_adam",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_opt_context_adam(ctypes.Structure):\n    _fields_ = [\n        (\"g\", ctypes.POINTER(ggml_tensor)),\n        (\"m\", ctypes.POINTER(ggml_tensor)),\n        (\"v\", ctypes.POINTER(ggml_tensor)),\n        (\"pf\", ctypes.POINTER(ggml_tensor)),\n        (\"fx_best\", ctypes.c_float),\n        (\"fx_prev\", ctypes.c_float),\n        (\"n_no_improvement\", ctypes.c_int),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_context_lbfgs",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_opt_context_lbfgs(ctypes.Structure):\n    _fields_ = [\n        (\"x\", ctypes.POINTER(ggml_tensor)),\n        (\"xp\", ctypes.POINTER(ggml_tensor)),\n        (\"g\", ctypes.POINTER(ggml_tensor)),\n        (\"gp\", ctypes.POINTER(ggml_tensor)),\n        (\"d\", ctypes.POINTER(ggml_tensor)),\n        (\"pf\", ctypes.POINTER(ggml_tensor)),\n        (\"lmal\", ctypes.POINTER(ggml_tensor)),\n        (\"lmys\", ctypes.POINTER(ggml_tensor)),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_context",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_opt_context(ctypes.Structure):\n    _fields_ = [\n        (\"ctx\", ggml_context_p),\n        (\"params\", ggml_opt_params),\n        (\"iter\", ctypes.c_int),\n        (\"nx\", ctypes.c_int64),\n        (\"just_initialized\", ctypes.c_bool),\n        (\"loss_before\", ctypes.c_float),\n        (\"loss_after\", ctypes.c_float),\n        (\"adam\", ggml_opt_context_adam),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_type_traits_t",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_type_traits_t(ctypes.Structure):\n    _fields_ = [\n        (\"type_name\", ctypes.c_char_p),\n        (\"blck_size\", ctypes.c_int),\n        (\"type_size\", ctypes.c_size_t),\n        (\"is_quantized\", ctypes.c_bool),\n        (\"to_float\", ggml_to_float_t),\n        (\"from_float\", ggml_from_float_t),\n        (\"from_float_reference\", ggml_from_float_t),\n        (\"vec_dot\", ggml_vec_dot_t),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_graph_copy",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_backend_graph_copy(ctypes.Structure):\n    _fields_ = [\n        (\"buffer\", ggml_backend_buffer_t),\n        (\"ctx_allocated\", ggml_context_p),\n        (\"ctx_unallocated\", ggml_context_p),\n        (\"graph\", ctypes.POINTER(ggml_cgraph)),\n    ]\nggml_backend_graph_copy_t = ggml_backend_graph_copy\n# // Copy a graph to a different backend\n# GGML_API struct ggml_backend_graph_copy ggml_backend_graph_copy(ggml_backend_t backend, struct ggml_cgraph * graph);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_type_i",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_backend_buffer_type_i(ctypes.Structure):\n    _fields_ = [\n        (\"alloc_buffer\", ggml_backend_buffer_i_alloc_buffer),\n        (\"get_alignment\", ggml_backend_buffer_i_get_alignment),\n        (\"get_alloc_size\", ggml_backend_buffer_i_get_alloc_size),\n        (\"supports_backend\", ggml_backend_buffer_i_supports_backend),\n    ]\n# struct ggml_backend_buffer_type {\n#     struct ggml_backend_buffer_type_i  iface;\n#     ggml_backend_buffer_type_context_t context;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_type",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_backend_buffer_type(ctypes.Structure):\n    _fields_ = [\n        (\"iface\", ggml_backend_buffer_type_i),\n        (\"context\", ggml_backend_buffer_type_context_t),\n    ]\n# typedef void * ggml_backend_buffer_context_t;\nggml_backend_buffer_context_t = ctypes.c_void_p\n# struct ggml_backend_buffer_i {\n#     void     (*free_buffer)(ggml_backend_buffer_t buffer);\n#     //void     (*reset)      (ggml_backend_buffer_t buffer); // reset any internal state due to tensor initialization, such as tensor extras",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_backend_buffer_i(ctypes.Structure):\n    _fields_ = [\n        (\"free_buffer\", ggml_backend_buffer_i_free_buffer),\n        (\"get_base\", ggml_backend_buffer_i_get_base),\n        (\"init_tensor\", ggml_backend_buffer_i_init_tensor),\n        (\"set_tensor\", ggml_backend_buffer_i_set_tensor),\n        (\"get_tensor\", ggml_backend_buffer_i_get_tensor),\n        (\"cpy_tensor_from\", ggml_backend_buffer_i_cpy_tensor_from),\n        (\"cpy_tensor_to\", ggml_backend_buffer_i_cpy_tensor_to),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_backend_buffer(ctypes.Structure):\n    _fields_ = [\n        (\"iface\", ggml_backend_buffer_i),\n        (\"buft\", ggml_backend_buffer_type_t),\n        (\"context\", ggml_backend_buffer_context_t),\n        (\"size\", ctypes.c_size_t),\n    ]\n# ggml_backend_buffer_t ggml_backend_buffer_init(\n#                ggml_backend_buffer_type_t      buft,\n#         struct ggml_backend_buffer_i           iface,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_backend_i(ctypes.Structure):\n    _fields_ = [\n        (\"get_name\", ggml_backend_i_get_name),\n        (\"free\", ggml_backend_i_free),\n        (\"get_default_buffer_type\", ggml_backend_i_get_default_buffer_type),\n        (\"set_tensor_async\", ggml_backend_i_set_tensor_async),\n        (\"get_tensor_async\", ggml_backend_i_get_tensor_async),\n        (\"cpy_tensor_from_async\", ggml_backend_i_cpy_tensor_from_async),\n        (\"cpy_tensor_to_async\", ggml_backend_i_cpy_tensor_to_async),\n        (\"synchronize\", ggml_backend_i_synchronize),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend",
        "kind": 6,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "class ggml_backend(ctypes.Structure):\n    _fields_ = [\n        (\"iface\", ggml_backend_i),\n        (\"context\", ggml_backend_context_t),\n    ]\n# //\n# // Backend registry\n# //\n# typedef ggml_backend_t (*ggml_backend_init_fn)(const char * params, void * user_data);\nggml_backend_init_fn = ctypes.CFUNCTYPE(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "load_shared_library",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def load_shared_library(base_path: Path, lib_base_name: str):\n    # Construct the paths to the possible shared library names\n    # Searching for the library in the current directory under the name \"libggml\" (default name\n    # for ggml) and \"ggml\" (default name for this repo)\n    lib_names: List[str] = [\n        f\"lib{lib_base_name}.so\",\n        f\"lib{lib_base_name}.dylib\",\n        f\"{lib_base_name}.dll\",\n    ]\n    cdll_args = dict()  # type: ignore",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_fp16_to_fp32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_fp16_to_fp32(x: ggml_fp16_t) -> float:\n    return lib.ggml_fp16_to_fp32(x)\nlib.ggml_fp16_to_fp32.argtypes = [ggml_fp16_t]\nlib.ggml_fp16_to_fp32.restype = ctypes.c_float\n# GGML_API ggml_fp16_t ggml_fp32_to_fp16(float x);\ndef ggml_fp32_to_fp16(x: ctypes.c_float) -> int:\n    return lib.ggml_fp32_to_fp16(x)\nlib.ggml_fp32_to_fp16.argtypes = [ctypes.c_float]\nlib.ggml_fp32_to_fp16.restype = ggml_fp16_t\n# GGML_API void ggml_fp16_to_fp32_row(const ggml_fp16_t * x, float * y, size_t n);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_fp32_to_fp16",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_fp32_to_fp16(x: ctypes.c_float) -> int:\n    return lib.ggml_fp32_to_fp16(x)\nlib.ggml_fp32_to_fp16.argtypes = [ctypes.c_float]\nlib.ggml_fp32_to_fp16.restype = ggml_fp16_t\n# GGML_API void ggml_fp16_to_fp32_row(const ggml_fp16_t * x, float * y, size_t n);\ndef ggml_fp16_to_fp32_row(\n    x: CFP16Array,\n    y: CFloatArray,\n    n: Union[ctypes.c_int, int],\n) -> None:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_fp16_to_fp32_row",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_fp16_to_fp32_row(\n    x: CFP16Array,\n    y: CFloatArray,\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_fp16_to_fp32_row(x, y, n)\nlib.ggml_fp16_to_fp32_row.argtypes = [\n    ctypes.POINTER(ggml_fp16_t),\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_fp32_to_fp16_row",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_fp32_to_fp16_row(\n    x: CFloatArray,\n    y: CFP16Array,\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_fp32_to_fp16_row(x, y, n)\nlib.ggml_fp32_to_fp16_row.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ggml_fp16_t),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_time_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_time_init():\n    return lib.ggml_time_init()\nlib.ggml_time_init.argtypes = []\nlib.ggml_time_init.restype = None\n# GGML_API int64_t ggml_time_ms(void);\ndef ggml_time_ms() -> int:\n    return lib.ggml_time_ms()\nlib.ggml_time_ms.argtypes = []\nlib.ggml_time_ms.restype = ctypes.c_int64\n# GGML_API int64_t ggml_time_us(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_time_ms",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_time_ms() -> int:\n    return lib.ggml_time_ms()\nlib.ggml_time_ms.argtypes = []\nlib.ggml_time_ms.restype = ctypes.c_int64\n# GGML_API int64_t ggml_time_us(void);\ndef ggml_time_us() -> int:\n    return lib.ggml_time_us()\nlib.ggml_time_us.argtypes = []\nlib.ggml_time_us.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_time_us",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_time_us() -> int:\n    return lib.ggml_time_us()\nlib.ggml_time_us.argtypes = []\nlib.ggml_time_us.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles(void);\ndef ggml_cycles() -> int:\n    return lib.ggml_cycles()\nlib.ggml_cycles.argtypes = []\nlib.ggml_cycles.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles_per_ms(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cycles",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cycles() -> int:\n    return lib.ggml_cycles()\nlib.ggml_cycles.argtypes = []\nlib.ggml_cycles.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles_per_ms(void);\ndef ggml_cycles_per_ms() -> int:\n    return lib.ggml_cycles_per_ms()\nlib.ggml_cycles_per_ms.argtypes = []\nlib.ggml_cycles_per_ms.restype = ctypes.c_int64\n# GGML_API void    ggml_print_backtrace(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cycles_per_ms",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cycles_per_ms() -> int:\n    return lib.ggml_cycles_per_ms()\nlib.ggml_cycles_per_ms.argtypes = []\nlib.ggml_cycles_per_ms.restype = ctypes.c_int64\n# GGML_API void    ggml_print_backtrace(void);\ndef ggml_print_backtrace():\n    return lib.ggml_print_backtrace()\nlib.ggml_print_backtrace.argtypes = []\nlib.ggml_print_backtrace.restype = None\n# GGML_API void    ggml_numa_init(void); // call once for better performance on NUMA systems",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_print_backtrace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_print_backtrace():\n    return lib.ggml_print_backtrace()\nlib.ggml_print_backtrace.argtypes = []\nlib.ggml_print_backtrace.restype = None\n# GGML_API void    ggml_numa_init(void); // call once for better performance on NUMA systems\ndef ggml_numa_init():\n    return lib.ggml_numa_init()\nlib.ggml_numa_init.argtypes = []\nlib.ggml_numa_init.restype = None\n# GGML_API bool    ggml_is_numa(void); // true if init detected that system has >1 NUMA node",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_numa_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_numa_init():\n    return lib.ggml_numa_init()\nlib.ggml_numa_init.argtypes = []\nlib.ggml_numa_init.restype = None\n# GGML_API bool    ggml_is_numa(void); // true if init detected that system has >1 NUMA node\ndef ggml_is_numa() -> bool:\n    return lib.ggml_is_numa()\nlib.ggml_is_numa.argtypes = []\nlib.ggml_is_numa.restype = ctypes.c_bool\n# GGML_API void    ggml_print_object (const struct ggml_object * obj);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_is_numa",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_is_numa() -> bool:\n    return lib.ggml_is_numa()\nlib.ggml_is_numa.argtypes = []\nlib.ggml_is_numa.restype = ctypes.c_bool\n# GGML_API void    ggml_print_object (const struct ggml_object * obj);\ndef ggml_print_object(obj: ggml_object_p):\n    return lib.ggml_print_object(obj)\nlib.ggml_print_object.argtypes = [ctypes.POINTER(ggml_object)]\nlib.ggml_print_object.restype = None\n# GGML_API void    ggml_print_objects(const struct ggml_context * ctx);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_print_object",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_print_object(obj: ggml_object_p):\n    return lib.ggml_print_object(obj)\nlib.ggml_print_object.argtypes = [ctypes.POINTER(ggml_object)]\nlib.ggml_print_object.restype = None\n# GGML_API void    ggml_print_objects(const struct ggml_context * ctx);\ndef ggml_print_objects(ctx: ggml_context_p):\n    return lib.ggml_print_objects(ctx)\nlib.ggml_print_objects.argtypes = [ggml_context_p]\nlib.ggml_print_objects.restype = None\n# GGML_API int64_t ggml_nelements   (const struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_print_objects",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_print_objects(ctx: ggml_context_p):\n    return lib.ggml_print_objects(ctx)\nlib.ggml_print_objects.argtypes = [ggml_context_p]\nlib.ggml_print_objects.restype = None\n# GGML_API int64_t ggml_nelements   (const struct ggml_tensor * tensor);\ndef ggml_nelements(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of elements in a tensor\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_nelements",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_nelements(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of elements in a tensor\n    Parameters:\n        tensor: tensor\n    Returns:\n        number of elements\"\"\"\n    return lib.ggml_nelements(tensor)\nlib.ggml_nelements.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_nrows",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_nrows(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of rows in a tensor\n    Parameters:\n        tensor: tensor\n    Returns:\n        number of rows\"\"\"\n    return lib.ggml_nrows(tensor)\nlib.ggml_nrows.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_nbytes",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_nbytes(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of bytes required to store tensor data\n    Parameters:\n        tensor: tensor\n    Returns:\n        number of bytes\"\"\"\n    return lib.ggml_nbytes(tensor)\nlib.ggml_nbytes.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_nbytes_pad",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_nbytes_pad(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of bytes required to store tensor data, padded to GGML_MEM_ALIGN\n    Parameters:\n        tensor: tensor\n    Returns:\n        number of bytes\"\"\"\n    return lib.ggml_nbytes_pad(tensor)\nlib.ggml_nbytes_pad.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_nbytes_split",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_nbytes_split(\n    tensor: ggml_tensor_p,\n    nrows_split: Union[ctypes.c_int, int],\n) -> int:\n    return lib.ggml_nbytes_split(tensor, nrows_split)\nlib.ggml_nbytes_split.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_int]\nlib.ggml_nbytes_split.restype = ctypes.c_size_t\n# GGML_API int     ggml_blck_size (enum ggml_type type);\ndef ggml_blck_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_blck_size(type)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_blck_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_blck_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_blck_size(type)\nlib.ggml_blck_size.argtypes = [ctypes.c_int]\nlib.ggml_blck_size.restype = ctypes.c_int\n# GGML_API size_t  ggml_type_size (enum ggml_type type); // size in bytes for all elements in a block\ndef ggml_type_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_type_size(type)\nlib.ggml_type_size.argtypes = [ctypes.c_int]\nlib.ggml_type_size.restype = ctypes.c_size_t\n# GGML_API float   ggml_type_sizef(enum ggml_type type); // ggml_type_size()/ggml_blck_size() as float",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_type_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_type_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_type_size(type)\nlib.ggml_type_size.argtypes = [ctypes.c_int]\nlib.ggml_type_size.restype = ctypes.c_size_t\n# GGML_API float   ggml_type_sizef(enum ggml_type type); // ggml_type_size()/ggml_blck_size() as float\ndef ggml_type_sizef(type: Union[ctypes.c_int, int]) -> float:\n    return lib.ggml_type_sizef(type)\nlib.ggml_type_sizef.argtypes = [ctypes.c_int]\nlib.ggml_type_sizef.restype = ctypes.c_float\n# GGML_API const char * ggml_type_name(enum ggml_type type);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_type_sizef",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_type_sizef(type: Union[ctypes.c_int, int]) -> float:\n    return lib.ggml_type_sizef(type)\nlib.ggml_type_sizef.argtypes = [ctypes.c_int]\nlib.ggml_type_sizef.restype = ctypes.c_float\n# GGML_API const char * ggml_type_name(enum ggml_type type);\ndef ggml_type_name(type: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_type_name(type)\nlib.ggml_type_name.argtypes = [ctypes.c_int]\nlib.ggml_type_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_name  (enum ggml_op   op);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_type_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_type_name(type: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_type_name(type)\nlib.ggml_type_name.argtypes = [ctypes.c_int]\nlib.ggml_type_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_name  (enum ggml_op   op);\ndef ggml_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_name(op)\nlib.ggml_op_name.argtypes = [ctypes.c_int]\nlib.ggml_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_symbol(enum ggml_op   op);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_op_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_name(op)\nlib.ggml_op_name.argtypes = [ctypes.c_int]\nlib.ggml_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_symbol(enum ggml_op   op);\ndef ggml_op_symbol(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_symbol(op)\nlib.ggml_op_symbol.argtypes = [ctypes.c_int]\nlib.ggml_op_symbol.restype = ctypes.c_char_p\n# GGML_API const char * ggml_unary_op_name(enum ggml_unary_op op);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_op_symbol",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_op_symbol(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_symbol(op)\nlib.ggml_op_symbol.argtypes = [ctypes.c_int]\nlib.ggml_op_symbol.restype = ctypes.c_char_p\n# GGML_API const char * ggml_unary_op_name(enum ggml_unary_op op);\ndef ggml_unary_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_unary_op_name(op)\nlib.ggml_unary_op_name.argtypes = [ctypes.c_int]\nlib.ggml_unary_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_desc(const struct ggml_tensor * t); // unary or op name",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_unary_op_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_unary_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_unary_op_name(op)\nlib.ggml_unary_op_name.argtypes = [ctypes.c_int]\nlib.ggml_unary_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_desc(const struct ggml_tensor * t); // unary or op name\ndef ggml_op_desc(\n    t: ggml_tensor_p,\n) -> bytes:\n    return lib.ggml_op_desc(t)\nlib.ggml_op_desc.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_op_desc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_op_desc(\n    t: ggml_tensor_p,\n) -> bytes:\n    return lib.ggml_op_desc(t)\nlib.ggml_op_desc.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_op_desc.restype = ctypes.c_char_p\n# GGML_API size_t  ggml_element_size(const struct ggml_tensor * tensor);\ndef ggml_element_size(\n    tensor: ggml_tensor_p,\n) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_element_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_element_size(\n    tensor: ggml_tensor_p,\n) -> int:\n    return lib.ggml_element_size(tensor)\nlib.ggml_element_size.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_element_size.restype = ctypes.c_size_t\n# GGML_API bool    ggml_is_quantized(enum ggml_type type);\ndef ggml_is_quantized(type: Union[ctypes.c_int, int]) -> bool:\n    return lib.ggml_is_quantized(type)\nlib.ggml_is_quantized.argtypes = [ctypes.c_int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_is_quantized",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_is_quantized(type: Union[ctypes.c_int, int]) -> bool:\n    return lib.ggml_is_quantized(type)\nlib.ggml_is_quantized.argtypes = [ctypes.c_int]\nlib.ggml_is_quantized.restype = ctypes.c_bool\n# // TODO: temporary until model loading of ggml examples is refactored\n# GGML_API enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype);\ndef ggml_ftype_to_ggml_type(ftype: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_ftype_to_ggml_type(ftype)\nlib.ggml_ftype_to_ggml_type.argtypes = [ctypes.c_int]\nlib.ggml_ftype_to_ggml_type.restype = ctypes.c_int",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_ftype_to_ggml_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_ftype_to_ggml_type(ftype: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_ftype_to_ggml_type(ftype)\nlib.ggml_ftype_to_ggml_type.argtypes = [ctypes.c_int]\nlib.ggml_ftype_to_ggml_type.restype = ctypes.c_int\n# GGML_API bool ggml_is_transposed(const struct ggml_tensor * tensor);\ndef ggml_is_transposed(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is transposed\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_is_transposed",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_is_transposed(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is transposed\n    Parameters:\n        tensor: tensor\n    Returns:\n        True if tensor is transposed else False\"\"\"\n    return lib.ggml_is_transposed(tensor)\nlib.ggml_is_transposed.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_is_contiguous",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_is_contiguous(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is contiguous\n    Parameters:\n        tensor: tensor\n    Returns:\n        True if tensor is contiguous else False\"\"\"\n    return lib.ggml_is_contiguous(tensor)\nlib.ggml_is_contiguous.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_is_permuted",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_is_permuted(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is permuted\n    Parameters:\n        tensor: tensor\n    Returns:\n        True if tensor is permuted else False\"\"\"\n    return lib.ggml_is_permuted(tensor)\nlib.ggml_is_permuted.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_are_same_shape",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_are_same_shape(\n    t0: ggml_tensor_p,\n    t1: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if two tensors have the same shape\n    Parameters:\n        t0: tensor 0\n        t1: tensor 1\n    Returns:\n        True if tensors have the same shape else False\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tensor_overhead",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tensor_overhead() -> int:\n    \"\"\"Overhead required for a tensor struct in bytes\n    Returns:\n        size of tensor struct in bytes\"\"\"\n    return lib.ggml_tensor_overhead()\nlib.ggml_tensor_overhead.argtypes = []\nlib.ggml_tensor_overhead.restype = ctypes.c_size_t\n# // main\n# GGML_API struct ggml_context * ggml_init(struct ggml_init_params params);\ndef ggml_init(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_init(\n    params: ggml_init_params,\n) -> ggml_context_p:\n    \"\"\"Instantiate a new ggml context with params.\n    You must call `ggml_free()` to free the context.\n    Parameters:\n        params: ggml init params\n    Returns:\n        Pointer to ggml_context\"\"\"\n    return lib.ggml_init(params)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_free(ctx: ggml_context_p):\n    \"\"\"Free the ggml context.\n    Parameters:\n        ctx: ggml context\"\"\"\n    return lib.ggml_free(ctx)\nlib.ggml_free.argtypes = [ggml_context_p]\nlib.ggml_free.restype = None\n# GGML_API size_t  ggml_used_mem(const struct ggml_context * ctx);\ndef ggml_used_mem(ctx: ggml_context_p) -> int:\n    \"\"\"Return the amount of memory used by the ggml context in bytes.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_used_mem",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_used_mem(ctx: ggml_context_p) -> int:\n    \"\"\"Return the amount of memory used by the ggml context in bytes.\n    Parameters:\n        ctx: ggml context\n    Returns:\n        amount of memory used in bytes\"\"\"\n    return lib.ggml_used_mem(ctx)\nlib.ggml_used_mem.argtypes = [ggml_context_p]\nlib.ggml_used_mem.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_set_scratch(struct ggml_context * ctx, struct ggml_scratch scratch);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_scratch",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_scratch(ctx: ggml_context_p, scratch: ggml_scratch) -> int:\n    \"\"\"Set the scratch buffer for the ggml context.\"\"\"\n    return lib.ggml_set_scratch(ctx, scratch)\nlib.ggml_set_scratch.argtypes = [ggml_context_p, ggml_scratch]\nlib.ggml_set_scratch.restype = ctypes.c_size_t\n# GGML_API bool    ggml_get_no_alloc(struct ggml_context * ctx);\ndef ggml_get_no_alloc(ctx: ggml_context_p) -> bool:\n    \"\"\"Return the no_alloc flag for the ggml context.\"\"\"\n    return lib.ggml_get_no_alloc(ctx)\nlib.ggml_get_no_alloc.argtypes = [ggml_context_p]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_no_alloc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_no_alloc(ctx: ggml_context_p) -> bool:\n    \"\"\"Return the no_alloc flag for the ggml context.\"\"\"\n    return lib.ggml_get_no_alloc(ctx)\nlib.ggml_get_no_alloc.argtypes = [ggml_context_p]\nlib.ggml_get_no_alloc.restype = ctypes.c_bool\n# GGML_API void    ggml_set_no_alloc(struct ggml_context * ctx, bool no_alloc);\ndef ggml_set_no_alloc(ctx: ggml_context_p, no_alloc: Union[ctypes.c_bool, bool]):\n    \"\"\"Set the no_alloc flag for the ggml context.\"\"\"\n    return lib.ggml_set_no_alloc(ctx, no_alloc)\nlib.ggml_set_no_alloc.argtypes = [ggml_context_p, ctypes.c_bool]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_no_alloc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_no_alloc(ctx: ggml_context_p, no_alloc: Union[ctypes.c_bool, bool]):\n    \"\"\"Set the no_alloc flag for the ggml context.\"\"\"\n    return lib.ggml_set_no_alloc(ctx, no_alloc)\nlib.ggml_set_no_alloc.argtypes = [ggml_context_p, ctypes.c_bool]\nlib.ggml_set_no_alloc.restype = None\n# GGML_API void *  ggml_get_mem_buffer     (struct ggml_context * ctx);\ndef ggml_get_mem_buffer(ctx: ggml_context_p) -> Optional[ctypes.c_void_p]:\n    \"\"\"Return the memory buffer for the ggml context.\"\"\"\n    return lib.ggml_get_mem_buffer(ctx)\nlib.ggml_get_mem_buffer.argtypes = [ggml_context_p]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_mem_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_mem_buffer(ctx: ggml_context_p) -> Optional[ctypes.c_void_p]:\n    \"\"\"Return the memory buffer for the ggml context.\"\"\"\n    return lib.ggml_get_mem_buffer(ctx)\nlib.ggml_get_mem_buffer.argtypes = [ggml_context_p]\nlib.ggml_get_mem_buffer.restype = ctypes.c_void_p\n# GGML_API size_t  ggml_get_mem_size       (struct ggml_context * ctx);\ndef ggml_get_mem_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the size of the memory buffer for the ggml context in bytes.\"\"\"\n    return lib.ggml_get_mem_size(ctx)\nlib.ggml_get_mem_size.argtypes = [ggml_context_p]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_mem_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_mem_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the size of the memory buffer for the ggml context in bytes.\"\"\"\n    return lib.ggml_get_mem_size(ctx)\nlib.ggml_get_mem_size.argtypes = [ggml_context_p]\nlib.ggml_get_mem_size.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_get_max_tensor_size(const struct ggml_context * ctx);\ndef ggml_get_max_tensor_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the maximum size of a tensor in bytes.\"\"\"\n    return lib.ggml_get_max_tensor_size(ctx)\nlib.ggml_get_max_tensor_size.argtypes = [ggml_context_p]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_max_tensor_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_max_tensor_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the maximum size of a tensor in bytes.\"\"\"\n    return lib.ggml_get_max_tensor_size(ctx)\nlib.ggml_get_max_tensor_size.argtypes = [ggml_context_p]\nlib.ggml_get_max_tensor_size.restype = ctypes.c_size_t\n# GGML_API struct ggml_tensor * ggml_new_tensor(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,\n#         int    n_dims,\n#         const int64_t *ne);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_new_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_new_tensor(\n    ctx: ggml_context_p,\n    type: Union[ctypes.c_int, int],\n    n_dims: Union[ctypes.c_int, int],\n    ne: CInt64Array,\n) -> ggml_tensor_p:\n    \"\"\"Create a new tensor with the given type, number of dimensions, and number of elements in each dimension.\n    Parameters:\n        ctx: ggml context\n        type: ggml type",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_new_tensor_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_new_tensor_1d(\n    ctx: ggml_context_p, type: Union[ctypes.c_int, int], ne0: Union[ctypes.c_int64, int]\n) -> ggml_tensor_p:\n    \"\"\"Create a new 1-dimensional tensor with the given type and number of elements.\n    Parameters:\n        ctx: ggml context\n        type: ggml type\n        ne0: number of elements in dimension 0\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_new_tensor_2d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_new_tensor_2d(\n    ctx: ggml_context_p,\n    type: Union[ctypes.c_int, int],\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    \"\"\"Create a new 2-dimensional tensor with the given type and number of elements in each dimension.\n    Parameters:\n        ctx: ggml context\n        type: ggml type",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_new_tensor_3d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_new_tensor_3d(\n    ctx: ggml_context_p,\n    type: Union[ctypes.c_int, int],\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n    ne2: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    \"\"\"Create a new 3-dimensional tensor with the given type and number of elements in each dimension.\n    Parameters:\n        ctx: ggml context",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_new_tensor_4d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_new_tensor_4d(\n    ctx: ggml_context_p,\n    type: Union[ctypes.c_int, int],\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n    ne2: Union[ctypes.c_int64, int],\n    ne3: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    \"\"\"Create a new 4-dimensional tensor with the given type and number of elements in each dimension.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_new_i32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_new_i32(\n    ctx: ggml_context_p, value: Union[ctypes.c_int32, int]\n) -> ggml_tensor_p:\n    \"\"\"Create a 1 element tensor with the given integer value.\n    Parameters:\n        ctx: ggml context\n        value: integer value\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_new_i32(ctx, value)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_new_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_new_f32(\n    ctx: ggml_context_p,\n    value: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Create a 1 element tensor with the given float value.\n    Parameters:\n        ctx: ggml context\n        value: float value\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_dup_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_dup_tensor(ctx: ggml_context_p, src: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Create a new tensor with the same type and dimensions as the source tensor.\n    Parameters:\n        ctx: ggml context\n        src: source tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_dup_tensor(ctx, src)\nlib.ggml_dup_tensor.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_dup_tensor.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_view_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_view_tensor(ctx: ggml_context_p, src: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Create a new tensor with the same type, dimensions and data as the source tensor.\n    Parameters:\n        ctx: ggml context\n        src: source tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_view_tensor(ctx, src)\nlib.ggml_view_tensor.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_view_tensor.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_first_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_first_tensor(ctx: ggml_context_p) -> ggml_tensor_p:\n    \"\"\"Get the first tensor from the ggml context.\n    Parameters:\n        ctx: ggml context\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_get_first_tensor(ctx)\nlib.ggml_get_first_tensor.argtypes = [ggml_context_p]\nlib.ggml_get_first_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_get_next_tensor (struct ggml_context * ctx, struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_next_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_next_tensor(ctx: ggml_context_p, tensor: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Get the next tensor from the ggml context.\n    Parameters:\n        ctx: ggml context\n        tensor: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_get_next_tensor(ctx, tensor)\nlib.ggml_get_next_tensor.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_get_next_tensor.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_tensor(ctx: ggml_context_p, name: bytes) -> ggml_tensor_p:\n    \"\"\"Get a tensor from the ggml context by name.\n    Parameters:\n        ctx: ggml context\n        name: name of tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_get_tensor(ctx, name)\nlib.ggml_get_tensor.argtypes = [ggml_context_p, ctypes.c_char_p]\nlib.ggml_get_tensor.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_zero",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_zero(\n    tensor: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Zero all elements in a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_set_zero(tensor)\nlib.ggml_set_zero.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_i32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_i32(\n    tensor: ggml_tensor_p,\n    value: Union[ctypes.c_int32, int],\n) -> ggml_tensor_p:\n    \"\"\"Set all elements in a tensor to the given integer value.\n    Parameters:\n        tensor: tensor\n        value: integer value\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_f32(\n    tensor: ggml_tensor_p,\n    value: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Set all elements in a tensor to the given float value.\n    Parameters:\n        tensor: tensor\n        value: float value\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_unravel_index",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_unravel_index(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int64, int],\n    i0,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore\n    i1,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore\n    i2,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore\n    i3,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore\n):\n    \"\"\"Convert a flat index into coordinates.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_i32_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_i32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n) -> int:\n    \"\"\"Get the integer value of the i-th element in a 1-dimensional tensor.\n    Parameters:\n        tensor: tensor\n        i: index of element\n    Returns:\n        integer value of element at index i\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_i32_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_i32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_int32, int],\n):\n    \"\"\"Set the integer value of the i-th element in a 1-dimensional tensor.\n    Parameters:\n        tensor: tensor\n        i: index of element\n        value: integer value to set element to\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_i32_nd",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_i32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n    i2: Union[ctypes.c_int, int],\n    i3: Union[ctypes.c_int, int],\n) -> int:\n    \"\"\"Get the integer value of the element at the given coordinates in a 4-dimensional tensor.\n    Parameters:\n        tensor: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_i32_nd",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_i32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n    i2: Union[ctypes.c_int, int],\n    i3: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_int32, int],\n):\n    \"\"\"Set the integer value of the element at the given coordinates in a 4-dimensional tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_f32_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_f32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n) -> float:\n    \"\"\"Get the float value of the i-th element in a 1-dimensional tensor.\n    Parameters:\n        tensor: tensor\n    Returns:\n        float value of element at index i\"\"\"\n    return lib.ggml_get_f32_1d(tensor, i)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_f32_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_f32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_float, float],\n):\n    \"\"\"Set the float value of the i-th element in a 1-dimensional tensor.\n    Parameters:\n        tensor: tensor\n        i: index of element\n        value: float value to set element to\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_f32_nd",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_f32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n    i2: Union[ctypes.c_int, int],\n    i3: Union[ctypes.c_int, int],\n) -> float:\n    \"\"\"Get the float value of the element at the given coordinates in a 4-dimensional tensor.\n    Parameters:\n        tensor: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_f32_nd",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_f32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n    i2: Union[ctypes.c_int, int],\n    i3: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_float, float],\n):\n    \"\"\"Set the float value of the element at the given coordinates in a 4-dimensional tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_data",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_data(\n    tensor: ggml_tensor_p,\n) -> Optional[ctypes.c_void_p]:\n    \"\"\"Get the data pointer of a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:\n        Pointer to data, or None if tensor has no data\"\"\"\n    return lib.ggml_get_data(tensor)\nlib.ggml_get_data.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_data_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_data_f32(\n    tensor: ggml_tensor_p,\n) -> Optional[CFloatArray]:\n    \"\"\"Get the data pointer of a tensor as a float array.\n    Parameters:\n        tensor: tensor\n    Returns:\n        (Optional[ctypes.Array[ctypes.c_float]]): array of float to data, or None if tensor has no data\n    \"\"\"\n    return lib.ggml_get_data_f32(tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_unary_op",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_unary_op(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the unary operation of a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:\n        unary operation\"\"\"\n    return lib.ggml_get_unary_op(tensor)\nlib.ggml_get_unary_op.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_name(\n    tensor: ggml_tensor_p,\n) -> bytes:\n    \"\"\"Get the name of a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:\n        name of tensor\"\"\"\n    return lib.ggml_get_name(tensor)\nlib.ggml_get_name.argtypes = [ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_name(\n    tensor: ggml_tensor_p,\n    name: bytes,\n) -> ggml_tensor_p:\n    \"\"\"Set the name of a tensor.\n    Parameters:\n        tensor: tensor\n        name: name to set tensor to\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_format_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_format_name(\n    tensor: ggml_tensor_p,\n    fmt: bytes,\n    *args: Sequence[Union[bool, int, float, str]],\n) -> ggml_tensor_p:\n    \"\"\"Format the name of a tensor using the given format c string and arguments.\n    Parameters:\n        tensor: tensor\n        fmt: format c string\n        args: arguments to format string",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_dup",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_dup(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_dup(ctx, a)\nlib.ggml_dup.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_dup.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_dup_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_dup_inplace(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_dup_inplace(ctx, a)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_dup_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_dup_inplace(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_dup_inplace(ctx, a)\nlib.ggml_dup_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_dup_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_add(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_add",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_add(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Add two tensors together and return the result.\n    Parameters:\n        ctx: ggml context\n        a: first tensor\n        b: second tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_add_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_add_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Add two tensors together and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: first tensor\n        b: second tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_add_cast",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_add_cast(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    type: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Add two tensors together and cast the result to the given type.\n    Parameters:\n        ctx: ggml context\n        a: first tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_add1",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_add1(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_add1(ctx, a, b)\nlib.ggml_add1.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_add1_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_add1_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_add1_inplace(ctx, a, b)\nlib.ggml_add1_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_acc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_acc(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    nb1: Union[ctypes.c_size_t, int],\n    nb2: Union[ctypes.c_size_t, int],\n    nb3: Union[ctypes.c_size_t, int],\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_acc(ctx, a, b, nb1, nb2, nb3, offset)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_acc_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_acc_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    nb1: Union[ctypes.c_size_t, int],\n    nb2: Union[ctypes.c_size_t, int],\n    nb3: Union[ctypes.c_size_t, int],\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_acc_inplace(ctx, a, b, nb1, nb2, nb3, offset)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sub",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sub(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Subtract two tensors and return the result.\n    Parameters:\n        ctx: ggml context\n        a: first tensor\n        b: second tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sub_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sub_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Subtract two tensors and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: first tensor\n        b: second tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_mul",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_mul(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Element-wise multiply two tensors and return the result.\n    Parameters:\n        ctx: ggml context\n        a: first tensor\n        b: second tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_mul_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_mul_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Element-wise multiply two tensors and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: first tensor\n        b: second tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_div",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_div(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Element-wise divide two tensors and return the result.\n    Parameters:\n        ctx: ggml context\n        a: first tensor\n        b: second tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_div_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_div_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Element-wise divide two tensors and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: first tensor\n        b: second tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sqr",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sqr(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sqr_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sqr_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sqrt",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sqrt(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square root all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sqrt_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sqrt_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square root all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_sqrt_inplace(ctx, a)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_log",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_log(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the natural logarithm of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_log(ctx, a)\nlib.ggml_log.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_log.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_log_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_log_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Take the natural logarithm of all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sum",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sum(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Sum all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_sum(ctx, a)\nlib.ggml_sum.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sum.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sum_rows",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sum_rows(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Sum all elements in a tensor along the first axis and return the result.\n    sums along rows, with input shape [a,b,c,d] return shape [1,b,c,d]\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_sum_rows(ctx, a)\nlib.ggml_sum_rows.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_mean",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_mean(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the mean of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_mean(ctx, a)\nlib.ggml_mean.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_mean.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_argmax",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_argmax(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the argmax of all elements in a tensor and return the result.\n    argmax along rows\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_argmax(ctx, a)\nlib.ggml_argmax.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_repeat",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_repeat(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Repeat a tensor to fit the shape of another tensor.\n    If a is the same shape as b, and a is not parameter, return a\n    Parameters:\n        ctx: ggml context\n        a: tensor to repeat",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_repeat_back",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_repeat_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_repeat_back(ctx, a, b)\nlib.ggml_repeat_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_concat",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_concat(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Concatenate two tensors along the second axis and return the result.\n    Parameters:\n        ctx: ggml context\n        a: first tensor\n        b: second tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_abs",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_abs(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the absolute value of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_abs(ctx, a)\nlib.ggml_abs.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_abs.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_abs_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_abs_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Take the absolute value of all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sgn",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sgn(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Get the sign of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_sgn(ctx, a)\nlib.ggml_sgn.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sgn.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_sgn_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_sgn_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Get the sign of all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_neg",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_neg(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Negate all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_neg(ctx, a)\nlib.ggml_neg.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_neg.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_neg_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_neg_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Negate all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_step",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_step(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_step(ctx, a)\nlib.ggml_step.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_step.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_tanh(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_tanh(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the tanh activation function to all elements in a tensor and return the result.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tanh",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tanh(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the tanh activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_tanh(ctx, a)\nlib.ggml_tanh.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_tanh.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tanh_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tanh_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the tanh activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_elu",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_elu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the ELU activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_elu(ctx, a)\nlib.ggml_elu.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_elu.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_elu_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_elu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the ELU activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_relu",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_relu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the ReLU activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_relu(ctx, a)\nlib.ggml_relu.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_relu.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_leaky_relu",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_leaky_relu(\n    ctx: ggml_context_p, a: ggml_tensor_p, negative_slope: float, inplace: bool\n) -> ggml_tensor_p:\n    \"\"\"Apply the Leaky ReLU activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n        negative_slope: negative slope\n        inplace: whether to store the result in the first tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_relu_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_relu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the ReLU activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gelu",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_gelu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_gelu(ctx, a)\nlib.ggml_gelu.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_gelu.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gelu_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_gelu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gelu_quick",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_gelu_quick(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_gelu_quick(ctx, a)\nlib.ggml_gelu_quick.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_gelu_quick.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gelu_quick_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_gelu_quick_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_silu",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_silu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the Sigmoid Linear Unit activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_silu(ctx, a)\nlib.ggml_silu.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_silu.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_silu_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_silu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the Sigmoid Linear Unit activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_silu_back",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_silu_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_silu_back(ctx, a, b)\nlib.ggml_silu_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_norm",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_norm(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Normalize all elements in a tensor along the first axis and return the result.\n    normalize along rows.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_norm_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_norm_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Normalize all elements in a tensor along the first axis and store the result in the first tensor.\n    normalize along rows.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rms_norm",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rms_norm(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Compute the RMS norm of a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n        eps: float",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rms_norm_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rms_norm_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    return lib.ggml_rms_norm_inplace(ctx, a, eps)\nlib.ggml_rms_norm_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_float,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_group_norm",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_group_norm(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_groups: int,\n) -> ggml_tensor_p:\n    \"\"\"Group normalize a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n        n_groups: int",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_group_norm_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_group_norm_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_groups: int,\n) -> ggml_tensor_p:\n    \"\"\"Group normalize a tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n        n_groups: int",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rms_norm_back",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rms_norm_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    return lib.ggml_rms_norm_back(ctx, a, b, eps)\nlib.ggml_rms_norm_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_mul_mat",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_mul_mat(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Multiply two matrices and return the result.\n    A: k columns, n rows => [ne03, ne02, n, k]\n    B: k columns, m rows  (i.e. we transpose it internally) => [ne03 * x, ne02 * y, m, k]\n    result is n columns, m rows => [ne03 * x, ne02 * y, m, n]\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_mul_mat_id",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_mul_mat_id(\n    ctx: ggml_context_p,\n    as_,  # type: ctypes.POINTER(ctypes.POINTER(ggml_tensor)) # type: ignore\n    n_as: int,\n    ids: ggml_tensor_p,\n    id_: int,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Multiply two matrices and return the result.\n    indirect matrix multiplication",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_out_prod",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_out_prod(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Compute the outer product of two matrices and return the result.\n    A: m columns, n rows,\n    B: p columns, n rows,\n    result is m columns, p rows\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_scale",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_scale(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Scale a tensor by another tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n        b: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_scale_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_scale_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Scale a tensor by another tensor and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    nb1: Union[ctypes.c_size_t, int],\n    nb2: Union[ctypes.c_size_t, int],\n    nb3: Union[ctypes.c_size_t, int],\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_set(ctx, a, b, nb1, nb2, nb3, offset)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    nb1: Union[ctypes.c_size_t, int],\n    nb2: Union[ctypes.c_size_t, int],\n    nb3: Union[ctypes.c_size_t, int],\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_set_inplace(ctx, a, b, nb1, nb2, nb3, offset)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_set_1d(ctx, a, b, offset)\nlib.ggml_set_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_1d_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_1d_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_set_1d_inplace(ctx, a, b, offset)\nlib.ggml_set_1d_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_2d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_2d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    nb1: Union[ctypes.c_size_t, int],\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_set_2d(ctx, a, b, nb1, offset)\nlib.ggml_set_2d.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_2d_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_2d_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    nb1: Union[ctypes.c_size_t, int],\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_set_2d_inplace(ctx, a, b, nb1, offset)\nlib.ggml_set_2d_inplace.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpy",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpy(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_cpy(ctx, a, b)\nlib.ggml_cpy.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpy_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpy_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_cpy_inplace(ctx, a, b)\nlib.ggml_cpy_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cont",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cont(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Make a tensor contiguous and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_cont(ctx, a)\nlib.ggml_cont.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_cont.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cont_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cont_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Make a tensor contiguous and store the result in the first tensor.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cont_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cont_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    return lib.ggml_cont_1d(ctx, a, ne0)\nlib.ggml_cont_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cont_2d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cont_2d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    return lib.ggml_cont_2d(ctx, a, ne0, ne1)\nlib.ggml_cont_2d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cont_3d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cont_3d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n    ne2: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    return lib.ggml_cont_3d(ctx, a, ne0, ne1, ne2)\nlib.ggml_cont_3d.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cont_4d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cont_4d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n    ne2: Union[ctypes.c_int64, int],\n    ne3: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    return lib.ggml_cont_4d(ctx, a, ne0, ne1, ne2, ne3)\nlib.ggml_cont_4d.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_reshape",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_reshape(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_reshape(ctx, a, b)\nlib.ggml_reshape.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_reshape_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_reshape_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    return lib.ggml_reshape_1d(ctx, a, ne0)\nlib.ggml_reshape_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_reshape_2d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_reshape_2d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    return lib.ggml_reshape_2d(ctx, a, ne0, ne1)\nlib.ggml_reshape_2d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_reshape_3d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_reshape_3d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n    ne2: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    return lib.ggml_reshape_3d(ctx, a, ne0, ne1, ne2)\nlib.ggml_reshape_3d.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_reshape_4d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_reshape_4d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n    ne2: Union[ctypes.c_int64, int],\n    ne3: Union[ctypes.c_int64, int],\n) -> ggml_tensor_p:\n    return lib.ggml_reshape_4d(ctx, a, ne0, ne1, ne2, ne3)\nlib.ggml_reshape_4d.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_view_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_view_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_view_1d(ctx, a, ne0, offset)\nlib.ggml_view_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_view_2d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_view_2d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n    nb1: Union[ctypes.c_size_t, int],\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:\n    return lib.ggml_view_2d(ctx, a, ne0, ne1, nb1, offset)\nlib.ggml_view_2d.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_view_3d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_view_3d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n    ne2: Union[ctypes.c_int64, int],\n    nb1: Union[ctypes.c_size_t, int],\n    nb2: Union[ctypes.c_size_t, int],\n    offset: Union[ctypes.c_size_t, int],\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_view_4d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_view_4d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],\n    ne1: Union[ctypes.c_int64, int],\n    ne2: Union[ctypes.c_int64, int],\n    ne3: Union[ctypes.c_int64, int],\n    nb1: Union[ctypes.c_size_t, int],\n    nb2: Union[ctypes.c_size_t, int],\n    nb3: Union[ctypes.c_size_t, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_permute",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_permute(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    axis0: Union[ctypes.c_int, int],\n    axis1: Union[ctypes.c_int, int],\n    axis2: Union[ctypes.c_int, int],\n    axis3: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_permute(ctx, a, axis0, axis1, axis2, axis3)\nlib.ggml_permute.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_transpose",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_transpose(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Transpose *the first two dimensions* of a tensor and return the result.\n    alias for `ggml_permute(ctx, a, 1, 0, 2, 3)`\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_transpose(ctx, a)\nlib.ggml_transpose.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_rows",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_rows(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_get_rows(ctx, a, b)\nlib.ggml_get_rows.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_rows_back",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_rows_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    c: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_get_rows_back(ctx, a, b, c)\nlib.ggml_get_rows_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_diag",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_diag(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_diag(ctx, a)\nlib.ggml_diag.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_diag.restype = ctypes.POINTER(ggml_tensor)\n# // set elements above the diagonal to -INF\n# GGML_API struct ggml_tensor * ggml_diag_mask_inf(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_past);\ndef ggml_diag_mask_inf(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_diag_mask_inf",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_diag_mask_inf(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_past: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_diag_mask_inf(ctx, a, n_past)\nlib.ggml_diag_mask_inf.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_diag_mask_inf_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_diag_mask_inf_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_past: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_diag_mask_inf_inplace(ctx, a, n_past)\nlib.ggml_diag_mask_inf_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_diag_mask_zero",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_diag_mask_zero(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_past: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_diag_mask_zero(ctx, a, n_past)\nlib.ggml_diag_mask_zero.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_diag_mask_zero_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_diag_mask_zero_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_past: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_diag_mask_zero_inplace(ctx, a, n_past)\nlib.ggml_diag_mask_zero_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_soft_max",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_soft_max(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_soft_max(ctx, a)\nlib.ggml_soft_max.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_soft_max.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_soft_max_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_soft_max_inplace(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_soft_max_inplace(ctx, a)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_soft_max_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_soft_max_inplace(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_soft_max_inplace(ctx, a)\nlib.ggml_soft_max_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_soft_max_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // fused soft_max(a*scale + mask)\n# // mask is optional\n# GGML_API struct ggml_tensor * ggml_soft_max_ext(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * mask,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_soft_max_ext",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_soft_max_ext(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    mask: ggml_tensor_p,\n    scale: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    return lib.ggml_soft_max_ext(ctx, a, mask, scale)\nlib.ggml_soft_max_ext.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_soft_max_back",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_soft_max_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_soft_max_back(ctx, a, b)\nlib.ggml_soft_max_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_soft_max_back_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_soft_max_back_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_soft_max_back_inplace(ctx, a, b)\nlib.ggml_soft_max_back_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rope",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rope(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    n_dims: Union[ctypes.c_int, int],\n    mode: Union[ctypes.c_int, int],\n    n_ctx: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Rotary position embedding\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rope_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rope_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    n_dims: Union[ctypes.c_int, int],\n    mode: Union[ctypes.c_int, int],\n    n_ctx: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Rotary position embedding inplace\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rope_custom",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rope_custom(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    n_dims: Union[ctypes.c_int, int],\n    mode: Union[ctypes.c_int, int],\n    n_ctx: Union[ctypes.c_int, int],\n    n_orig_ctx: Union[ctypes.c_int, int],\n    freq_base: Union[ctypes.c_float, float],\n    freq_scale: Union[ctypes.c_float, float],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rope_custom_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rope_custom_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    n_dims: Union[ctypes.c_int, int],\n    mode: Union[ctypes.c_int, int],\n    n_ctx: Union[ctypes.c_int, int],\n    n_orig_ctx: Union[ctypes.c_int, int],\n    freq_base: Union[ctypes.c_float, float],\n    freq_scale: Union[ctypes.c_float, float],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rope_yarn_corr_dims",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rope_yarn_corr_dims(\n    n_dims: Union[ctypes.c_int, int],\n    n_orig_ctx: Union[ctypes.c_int, int],\n    freq_base: Union[ctypes.c_float, float],\n    beta_fast: Union[ctypes.c_float, float],\n    beta_slow: Union[ctypes.c_float, float],\n    dims: CFloatArray,\n) -> None:\n    \"\"\"Compute correction dims for YaRN RoPE scaling\"\"\"\n    return lib.ggml_rope_yarn_corr_dims(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rope_xpos_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rope_xpos_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    n_dims: Union[ctypes.c_int, int],\n    base: Union[ctypes.c_float, float],\n    down: Union[ctypes.c_bool, bool],\n) -> ggml_tensor_p:\n    \"\"\"xPos RoPE, in-place, returns view(a)\"\"\"\n    return lib.ggml_rope_xpos_inplace(ctx, a, b, n_dims, base, down)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_rope_back",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_rope_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    n_dims: Union[ctypes.c_int, int],\n    mode: Union[ctypes.c_int, int],\n    n_ctx: Union[ctypes.c_int, int],\n    n_orig_ctx: Union[ctypes.c_int, int],\n    freq_base: Union[ctypes.c_float, float],\n    freq_scale: Union[ctypes.c_float, float],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_alibi",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_alibi(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_past: Union[ctypes.c_int, int],\n    n_head: Union[ctypes.c_int, int],\n    bias_max: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    return lib.ggml_alibi(ctx, a, n_past, n_head, bias_max)\nlib.ggml_alibi.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_clamp",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_clamp(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    min: Union[ctypes.c_float, float],\n    max: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Clamp tensor values between min and max\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_im2col",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_im2col(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    s0: Union[ctypes.c_int, int],\n    s1: Union[ctypes.c_int, int],\n    p0: Union[ctypes.c_int, int],\n    p1: Union[ctypes.c_int, int],\n    d0: Union[ctypes.c_int, int],\n    d1: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_conv_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_conv_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    s0: Union[ctypes.c_int, int],\n    p0: Union[ctypes.c_int, int],\n    d0: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Convolution 1D\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_conv_1d_ph",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_conv_1d_ph(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    s: Union[ctypes.c_int, int],\n    d: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Convolution 1D with padding = half\n    Parameters:\n        a: input tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_conv_transpose_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_conv_transpose_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    s0: Union[ctypes.c_int, int],\n    p0: Union[ctypes.c_int, int],\n    d0: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Convolution transpose 1D\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_conv_2d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_conv_2d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    s0: Union[ctypes.c_int, int],\n    s1: Union[ctypes.c_int, int],\n    p0: Union[ctypes.c_int, int],\n    p1: Union[ctypes.c_int, int],\n    d0: Union[ctypes.c_int, int],\n    d1: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_conv_2d_sk_p0",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_conv_2d_sk_p0(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Convolution 2D\n    Parameters:\n        a: input tensor\n        b: filter tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_conv_2d_s1_ph",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_conv_2d_s1_ph(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Convolution 2D with stride = 1 and padding = half\n    Parameters:\n        a: input tensor\n        b: filter tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_conv_transpose_2d_p0",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_conv_transpose_2d_p0(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    stride: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Convolution Transpose 2D with padding = zero\n    Parameters:\n        a: input tensor\n        b: filter tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_pool_1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_pool_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    op: Union[ctypes.c_int, int],\n    k0: Union[ctypes.c_int, int],\n    s0: Union[ctypes.c_int, int],\n    p0: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"1D Pooling\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_pool_2d",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_pool_2d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    op: Union[ctypes.c_int, int],\n    k0: Union[ctypes.c_int, int],\n    k1: Union[ctypes.c_int, int],\n    s0: Union[ctypes.c_int, int],\n    s1: Union[ctypes.c_int, int],\n    p0: Union[ctypes.c_float, float],\n    p1: Union[ctypes.c_float, float],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_upscale",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_upscale(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    scale_factor: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Upscale\n    Parameters:\n        a: input tensor\n        scale_factor: scale factor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_pad",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_pad(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    p0: Union[ctypes.c_int, int],\n    p1: Union[ctypes.c_int, int],\n    p2: Union[ctypes.c_int, int],\n    p3: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Pad tensor with zeros\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_argsort",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_argsort(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    order: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Argsort\n    Parameters:\n        a: input tensor\n        order: sort order\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_top_k",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_top_k(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    k: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    \"\"\"Top k elements per row\n    Parameters:\n        a: input tensor\n        k: number of elements\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_flash_attn",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_flash_attn(\n    ctx: ggml_context_p,\n    q: ggml_tensor_p,\n    k: ggml_tensor_p,\n    v: ggml_tensor_p,\n    masked: Union[ctypes.c_bool, bool],\n) -> ggml_tensor_p:\n    return lib.ggml_flash_attn(ctx, q, k, v, masked)\nlib.ggml_flash_attn.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_flash_attn_back",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_flash_attn_back(\n    ctx: ggml_context_p,\n    q: ggml_tensor_p,\n    k: ggml_tensor_p,\n    v: ggml_tensor_p,\n    d: ggml_tensor_p,\n    masked: Union[ctypes.c_bool, bool],\n) -> ggml_tensor_p:\n    return lib.ggml_flash_attn_back(ctx, q, k, v, d, masked)\nlib.ggml_flash_attn_back.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_flash_ff",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_flash_ff(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b0: ggml_tensor_p,\n    b1: ggml_tensor_p,\n    c0: ggml_tensor_p,\n    c1: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_flash_ff(ctx, a, b0, b1, c0, c1)\nlib.ggml_flash_ff.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_win_part",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_win_part(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    w: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_win_part(ctx, a, w)\nlib.ggml_win_part.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_win_unpart",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_win_unpart(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    w0: Union[ctypes.c_int, int],\n    h0: Union[ctypes.c_int, int],\n    w: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_win_unpart(ctx, a, w0, h0, w)\nlib.ggml_win_unpart.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_unary",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_unary(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    op: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_unary(ctx, a, op)\nlib.ggml_unary.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_unary_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_unary_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    op: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_unary_inplace(ctx, a, op)\nlib.ggml_unary_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_get_rel_pos",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_get_rel_pos(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    qh: Union[ctypes.c_int, int],\n    kh: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:\n    return lib.ggml_get_rel_pos(ctx, a, qh, kh)\nlib.ggml_get_rel_pos.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_add_rel_pos",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_add_rel_pos(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    pw: ggml_tensor_p,\n    ph: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_add_rel_pos(ctx, a, pw, ph)\nlib.ggml_add_rel_pos.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_add_rel_pos_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_add_rel_pos_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    pw: ggml_tensor_p,\n    ph: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_add_rel_pos_inplace(ctx, a, pw, ph)\nlib.ggml_add_rel_pos_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_unary_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_unary_f32(\n    ctx: ggml_context_p, a: ggml_tensor_p, fun: \"ctypes._FuncPointer\"  # type: ignore\n) -> ggml_tensor_p:\n    return lib.ggml_map_unary_f32(ctx, a, fun)\nlib.ggml_map_unary_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ggml_unary_op_f32_t,\n]\nlib.ggml_map_unary_f32.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_unary_inplace_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_unary_inplace_f32(\n    ctx: ggml_context_p, a: ggml_tensor_p, fun: \"ctypes._FuncPointer\"  # type: ignore\n) -> ggml_tensor_p:\n    return lib.ggml_map_unary_inplace_f32(ctx, a, fun)\nlib.ggml_map_unary_inplace_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ggml_unary_op_f32_t,\n]\nlib.ggml_map_unary_inplace_f32.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_binary_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_binary_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n) -> ggml_tensor_p:\n    return lib.ggml_map_binary_f32(ctx, a, b, fun)\nlib.ggml_map_binary_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_binary_inplace_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_binary_inplace_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n) -> ggml_tensor_p:\n    return lib.ggml_map_binary_inplace_f32(ctx, a, b, fun)\nlib.ggml_map_binary_inplace_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom1_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom1_f32(\n    ctx: ggml_context_p, a: ggml_tensor_p, fun: \"ctypes._FuncPointer\"  # type: ignore\n) -> ggml_tensor_p:\n    \"\"\"Custom unary operator on a tensor.\n    Example:\n        ```python\n        import ggml\n        @ggml.ggml_custom1_op_f32_t\n        def custom_op(b: ggml.tensor_p, a: ggml.tensor_p):\n            # do something with a and copy to b",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom1_inplace_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom1_inplace_f32(\n    ctx: ggml_context_p, a: ggml_tensor_p, fun: \"ctypes._CFuncPtr\"  # type: ignore\n) -> ggml_tensor_p:\n    \"\"\"Custom unary operator on a tensor inplace.\n    Parameters:\n        a: input tensor\n        fun (ggml.ggml_custom1_op_f32_t): function to apply to each element\n    Returns:\n        output tensor\"\"\"\n    return lib.ggml_map_custom1_inplace_f32(ctx, a, fun)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom2_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom2_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n) -> ggml_tensor_p:\n    \"\"\"Custom binary operator on two tensors.\n    Parameters:\n        a: input tensor\n        b: input tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom2_inplace_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom2_inplace_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n) -> ggml_tensor_p:\n    \"\"\"Custom binary operator on two tensors inplace.\n    Parameters:\n        a: input tensor\n        b: input tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom3_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom3_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    c: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n) -> ggml_tensor_p:\n    \"\"\"Custom ternary operator on three tensors.\n    Parameters:\n        a: input tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom3_inplace_f32",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom3_inplace_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    c: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n) -> ggml_tensor_p:\n    \"\"\"Custom ternary operator on three tensors inplace.\n    Parameters:\n        a: input tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom1",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom1(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n    n_tasks: Union[ctypes.c_int, int],\n    userdata: Optional[ctypes.c_void_p],\n) -> ggml_tensor_p:\n    return lib.ggml_map_custom1(ctx, a, fun, n_tasks, userdata)\nlib.ggml_map_custom1.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom1_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom1_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n    n_tasks: Union[ctypes.c_int, int],\n    userdata: Optional[ctypes.c_void_p],\n) -> ggml_tensor_p:\n    return lib.ggml_map_custom1_inplace(ctx, a, fun, n_tasks, userdata)\nlib.ggml_map_custom1_inplace.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom2",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom2(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n    n_tasks: Union[ctypes.c_int, int],\n    userdata: Optional[ctypes.c_void_p],\n) -> ggml_tensor_p:\n    return lib.ggml_map_custom2(ctx, a, b, fun, n_tasks, userdata)\nlib.ggml_map_custom2.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom2_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom2_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n    n_tasks: Union[ctypes.c_int, int],\n    userdata: Optional[ctypes.c_void_p],\n) -> ggml_tensor_p:\n    return lib.ggml_map_custom2_inplace(ctx, a, b, fun, n_tasks, userdata)\nlib.ggml_map_custom2_inplace.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom3",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom3(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    c: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n    n_tasks: Union[ctypes.c_int, int],\n    userdata: Optional[ctypes.c_void_p],\n) -> ggml_tensor_p:\n    return lib.ggml_map_custom3(ctx, a, b, c, fun, n_tasks, userdata)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_map_custom3_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_map_custom3_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    c: ggml_tensor_p,\n    fun: \"ctypes._FuncPointer\",  # type: ignore\n    n_tasks: Union[ctypes.c_int, int],\n    userdata: Optional[ctypes.c_void_p],\n) -> ggml_tensor_p:\n    return lib.ggml_map_custom3_inplace(ctx, a, b, c, fun, n_tasks, userdata)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cross_entropy_loss",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cross_entropy_loss(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_cross_entropy_loss(ctx, a, b)\nlib.ggml_cross_entropy_loss.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cross_entropy_loss_back",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cross_entropy_loss_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n    c: ggml_tensor_p,\n) -> ggml_tensor_p:\n    return lib.ggml_cross_entropy_loss_back(ctx, a, b, c)\nlib.ggml_cross_entropy_loss_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_set_param",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_set_param(ctx: ggml_context_p, tensor: ggml_tensor_p):\n    return lib.ggml_set_param(ctx, tensor)\nlib.ggml_set_param.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_set_param.restype = None\n# GGML_API void ggml_build_forward_expand (struct ggml_cgraph * cgraph, struct ggml_tensor * tensor);\ndef ggml_build_forward_expand(\n    cgraph: ggml_cgraph_p,\n    tensor: ggml_tensor_p,\n):\n    \"\"\"Add a tensor to the forward computation graph. This is used to",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_build_forward_expand",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_build_forward_expand(\n    cgraph: ggml_cgraph_p,\n    tensor: ggml_tensor_p,\n):\n    \"\"\"Add a tensor to the forward computation graph. This is used to\n    compute and save the value of the tensor.\n    Parameters:\n        cgraph: The graph.\n        tensor: The tensor.\"\"\"\n    return lib.ggml_build_forward_expand(cgraph, tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_build_backward_expand",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_build_backward_expand(\n    ctx: ggml_context_p,\n    gf: ggml_cgraph_p,\n    gb: ggml_cgraph_p,\n    keep: Union[ctypes.c_bool, bool],\n):\n    \"\"\"Add a tensor to the backward computation graph. This is used to\n    compute the gradient of the tensor.\n    Parameters:\n        ctx: The context.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_new_graph",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_new_graph(ctx: ggml_context_p) -> ggml_cgraph_p:\n    \"\"\"Create a new graph.\n    Parameters:\n        ctx: The context.\n    Returns:\n        The graph.\"\"\"\n    return lib.ggml_new_graph(ctx)\nlib.ggml_new_graph.argtypes = [ggml_context_p]\nlib.ggml_new_graph.restype = ctypes.POINTER(ggml_cgraph)\n# GGML_API struct ggml_cgraph * ggml_new_graph_custom  (struct ggml_context * ctx, size_t size, bool grads);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_new_graph_custom",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_new_graph_custom(\n    ctx: ggml_context_p,\n    size: Union[ctypes.c_size_t, int],\n    grads: Union[ctypes.c_bool, bool],\n) -> ggml_cgraph_p:\n    \"\"\"Create a new graph with custom size and grads.\n    Parameters:\n        ctx: The context.\n        size: The size of the graph.\n        grads: Whether to keep the gradients.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_dup",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_dup(\n    ctx: ggml_context_p,\n    cgraph: ggml_cgraph_p,\n) -> ggml_cgraph_p:\n    \"\"\"Duplicate a graph.\n    Parameters:\n        ctx: The context.\n        cgraph: The graph.\n    Returns:\n        The graph.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_view",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_view(\n    cgraph: ggml_cgraph_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n) -> ggml_cgraph:\n    \"\"\"View a graph.\n    Parameters:\n        cgraph: The graph.\n        i0: The start index.\n        i1: The end index.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_cpy",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_cpy(\n    src: ggml_cgraph_p,\n    dst: ggml_cgraph_p,\n):\n    \"\"\"Copy a graph.\n    Parameters:\n        src: The source graph.\n        dst: The destination graph.\"\"\"\n    return lib.ggml_graph_cpy(src, dst)\nlib.ggml_graph_cpy.argtypes = [ctypes.POINTER(ggml_cgraph), ctypes.POINTER(ggml_cgraph)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_reset",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_reset(\n    cgraph: ggml_cgraph_p,\n):\n    \"\"\"Reset a graph.\n    Parameters:\n        cgraph: The graph.\"\"\"\n    return lib.ggml_graph_reset(cgraph)\nlib.ggml_graph_reset.argtypes = [ctypes.POINTER(ggml_cgraph)]\nlib.ggml_graph_reset.restype = None\n# GGML_API void                 ggml_graph_clear       (struct ggml_cgraph * cgraph);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_clear",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_clear(\n    cgraph: ggml_cgraph_p,\n):\n    \"\"\"Clear a graph.\n    Parameters:\n        cgraph: The graph.\"\"\"\n    return lib.ggml_graph_clear(cgraph)\nlib.ggml_graph_clear.argtypes = [ctypes.POINTER(ggml_cgraph)]\nlib.ggml_graph_clear.restype = None\n# GGML_API size_t ggml_graph_overhead(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_overhead",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_overhead() -> int:\n    \"\"\"Get the overhead of the graph.\"\"\"\n    return lib.ggml_graph_overhead()\nlib.ggml_graph_overhead.argtypes = []\nlib.ggml_graph_overhead.restype = ctypes.c_size_t\n# GGML_API size_t ggml_graph_overhead_custom(size_t size, bool grads);\ndef ggml_graph_overhead_custom(\n    size: Union[ctypes.c_size_t, int],\n    grads: Union[ctypes.c_bool, bool],\n) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_overhead_custom",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_overhead_custom(\n    size: Union[ctypes.c_size_t, int],\n    grads: Union[ctypes.c_bool, bool],\n) -> int:\n    return lib.ggml_graph_overhead_custom(size, grads)\nlib.ggml_graph_overhead_custom.argtypes = [ctypes.c_size_t, ctypes.c_bool]\nlib.ggml_graph_overhead_custom.restype = ctypes.c_size_t\n# // ggml_graph_plan() has to be called before ggml_graph_compute()\n# // when plan.work_size > 0, caller must allocate memory for plan.work_data\n# GGML_API struct ggml_cplan ggml_graph_plan   (struct ggml_cgraph * cgraph, int n_threads /*= GGML_DEFAULT_N_THREADS*/);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_plan",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_plan(\n    cgraph: ggml_cgraph_p,\n    n_threads: Union[ctypes.c_int, int] = GGML_DEFAULT_N_THREADS,\n) -> ggml_cplan:\n    \"\"\"Plan the computation graph.\n    Parameters:\n        cgraph: The graph.\n        n_threads: The number of threads to use.\n    Returns:\n        The plan.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_compute",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_compute(\n    cgraph: ggml_cgraph_p,\n    cplan: ggml_cplan_p,\n) -> int:\n    return lib.ggml_graph_compute(cgraph, cplan)\nlib.ggml_graph_compute.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_cplan),\n]\nlib.ggml_graph_compute.restype = ctypes.c_int",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_compute_with_ctx",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_compute_with_ctx(\n    ctx: ggml_context_p,\n    cgraph: ggml_cgraph_p,\n    n_threads: Union[ctypes.c_int, int],\n):\n    \"\"\"Compute the graph with a context.\n    Parameters:\n        ctx: The context.\n        cgraph: The graph.\n        n_threads: The number of threads to use.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_get_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_get_tensor(\n    cgraph: ggml_cgraph_p,\n    name: bytes,\n) -> ggml_tensor_p:\n    \"\"\"Get a tensor from the graph by name.\n    Parameters:\n        cgraph: The graph.\n        name: The name of the tensor.\n    Returns:\n        The tensor.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_export",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_export(\n    cgraph: ggml_cgraph_p,\n    fname: bytes,\n):\n    return lib.ggml_graph_export(cgraph, fname)\nlib.ggml_graph_export.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.c_char_p,\n]\nlib.ggml_graph_export.restype = None",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_import",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_import(\n    fname: bytes,\n    ctx_data: \"ctypes._Pointer[ggml_context_p]\",  # type: ignore\n    ctx_eval: \"ctypes._Pointer[ggml_context_p]\",  # type: ignore\n) -> ggml_cgraph_p:\n    return lib.ggml_graph_import(fname, ctx_data, ctx_eval)\nlib.ggml_graph_import.argtypes = [\n    ctypes.c_char_p,\n    ctypes.POINTER(ggml_context_p),\n    ctypes.POINTER(ggml_context_p),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_print",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_print(\n    cgraph: ggml_cgraph_p,\n):\n    return lib.ggml_graph_print(cgraph)\nlib.ggml_graph_print.argtypes = [ctypes.POINTER(ggml_cgraph)]\nlib.ggml_graph_print.restype = None\n# // dump the graph into a file using the dot format\n# GGML_API void ggml_graph_dump_dot(const struct ggml_cgraph * gb, const struct ggml_cgraph * gf, const char * filename);\ndef ggml_graph_dump_dot(\n    gb: ggml_cgraph_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_graph_dump_dot",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_graph_dump_dot(\n    gb: ggml_cgraph_p,\n    gf: ggml_cgraph_p,\n    filename: bytes,\n):\n    return lib.ggml_graph_dump_dot(gb, gf, filename)\nlib.ggml_graph_dump_dot.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.c_char_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_build_backward_gradient_checkpointing",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_build_backward_gradient_checkpointing(\n    ctx: ggml_context_p,\n    gf: ggml_cgraph_p,\n    gb: ggml_cgraph_p,\n    gb_tmp: ggml_cgraph_p,\n    checkpoints: \"ctypes._Pointer[ggml_tensor_p]\",  # type: ignore\n    n_checkpoints: Union[ctypes.c_int, int],\n):\n    return lib.ggml_build_backward_gradient_checkpointing(\n        ctx, gf, gb, gb_tmp, checkpoints, n_checkpoints",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_default_params",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_opt_default_params(type: Union[ctypes.c_int, bool]) -> ggml_opt_params:\n    return lib.ggml_opt_default_params(type)\nlib.ggml_opt_default_params.argtypes = [ctypes.c_int]\nlib.ggml_opt_default_params.restype = ggml_opt_params\n# // optimize the function defined by the tensor f\n# GGML_API enum ggml_opt_result ggml_opt(\n#         struct ggml_context * ctx,\n#         struct ggml_opt_params params,\n#         struct ggml_tensor * f);\ndef ggml_opt(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_opt(\n    ctx: ggml_context_p,\n    params: ggml_opt_params,\n    f: ggml_tensor_p,\n) -> int:\n    return lib.ggml_opt(ctx, params, f)\nlib.ggml_opt.argtypes = [ggml_context_p, ggml_opt_params, ctypes.POINTER(ggml_tensor)]\nlib.ggml_opt.restype = ctypes.c_int\n# // initialize optimizer context\n# GGML_API void ggml_opt_init(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_opt_init(\n    ctx: ggml_context_p,\n    opt: \"ctypes._Pointer[ggml_opt_context]\",  # type: ignore\n    params: ggml_opt_params,\n    nx: Union[ctypes.c_int64, int],\n):\n    return lib.ggml_opt_init(ctx, opt, params, nx)\nlib.ggml_opt_init.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_opt_context),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_resume",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_opt_resume(\n    ctx: ggml_context_p,\n    opt: \"ctypes._Pointer[ggml_opt_context]\",  # type: ignore\n    f: ggml_tensor_p,\n) -> int:\n    return lib.ggml_opt_resume(ctx, opt, f)\nlib.ggml_opt_resume.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_opt_context),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_resume_g",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_opt_resume_g(\n    ctx: ggml_context_p,\n    opt: \"ctypes._Pointer[ggml_opt_context]\",  # type: ignore\n    f: ggml_tensor_p,\n    gf: ggml_cgraph_p,\n    gb: ggml_cgraph_p,\n    callback: \"ctypes._CFuncPtr[None, ctypes.c_void_p, ctypes.c_int, ctypes.POINTER(ctypes.c_float), ctypes.POINTER(ctypes.c_bool)]\",  # type: ignore\n    callback_data: ctypes.c_void_p,\n) -> int:\n    return lib.ggml_opt_resume_g(ctx, opt, f, gf, gb, callback, callback_data)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q4_0",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q4_0(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q4_0(src, dst, n, k, hist)\nlib.ggml_quantize_q4_0.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q4_1",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q4_1(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q4_1(src, dst, n, k, hist)\nlib.ggml_quantize_q4_1.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q5_0",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q5_0(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q5_0(src, dst, n, k, hist)\nlib.ggml_quantize_q5_0.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q5_1",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q5_1(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q5_1(src, dst, n, k, hist)\nlib.ggml_quantize_q5_1.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q8_0",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q8_0(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q8_0(src, dst, n, k, hist)\nlib.ggml_quantize_q8_0.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q2_K",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q2_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q2_K(src, dst, n, k, hist)\nlib.ggml_quantize_q2_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q3_K",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q3_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q3_K(src, dst, n, k, hist)\nlib.ggml_quantize_q3_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q4_K",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q4_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q4_K(src, dst, n, k, hist)\nlib.ggml_quantize_q4_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q5_K",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q5_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q5_K(src, dst, n, k, hist)\nlib.ggml_quantize_q5_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_q6_K",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_q6_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q6_K(src, dst, n, k, hist)\nlib.ggml_quantize_q6_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_quantize_chunk",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_quantize_chunk(\n    type: Union[ctypes.c_int, int],\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    start: Union[ctypes.c_int, int],\n    n: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_chunk(type, src, dst, start, n, hist)\nlib.ggml_quantize_chunk.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_avx",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_avx() -> int:\n    return lib.ggml_cpu_has_avx()\nlib.ggml_cpu_has_avx.argtypes = []\nlib.ggml_cpu_has_avx.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx2       (void);\ndef ggml_cpu_has_avx2() -> int:\n    return lib.ggml_cpu_has_avx2()\nlib.ggml_cpu_has_avx2.argtypes = []\nlib.ggml_cpu_has_avx2.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512     (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_avx2",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_avx2() -> int:\n    return lib.ggml_cpu_has_avx2()\nlib.ggml_cpu_has_avx2.argtypes = []\nlib.ggml_cpu_has_avx2.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512     (void);\ndef ggml_cpu_has_avx512() -> int:\n    return lib.ggml_cpu_has_avx512()\nlib.ggml_cpu_has_avx512.argtypes = []\nlib.ggml_cpu_has_avx512.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vbmi(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_avx512",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_avx512() -> int:\n    return lib.ggml_cpu_has_avx512()\nlib.ggml_cpu_has_avx512.argtypes = []\nlib.ggml_cpu_has_avx512.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vbmi(void);\ndef ggml_cpu_has_avx512_vbmi() -> int:\n    return lib.ggml_cpu_has_avx512_vbmi()\nlib.ggml_cpu_has_avx512_vbmi.argtypes = []\nlib.ggml_cpu_has_avx512_vbmi.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vnni(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_avx512_vbmi",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_avx512_vbmi() -> int:\n    return lib.ggml_cpu_has_avx512_vbmi()\nlib.ggml_cpu_has_avx512_vbmi.argtypes = []\nlib.ggml_cpu_has_avx512_vbmi.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vnni(void);\ndef ggml_cpu_has_avx512_vnni() -> int:\n    return lib.ggml_cpu_has_avx512_vnni()\nlib.ggml_cpu_has_avx512_vnni.argtypes = []\nlib.ggml_cpu_has_avx512_vnni.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fma        (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_avx512_vnni",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_avx512_vnni() -> int:\n    return lib.ggml_cpu_has_avx512_vnni()\nlib.ggml_cpu_has_avx512_vnni.argtypes = []\nlib.ggml_cpu_has_avx512_vnni.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fma        (void);\ndef ggml_cpu_has_fma() -> int:\n    return lib.ggml_cpu_has_fma()\nlib.ggml_cpu_has_fma.argtypes = []\nlib.ggml_cpu_has_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_neon       (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_fma",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_fma() -> int:\n    return lib.ggml_cpu_has_fma()\nlib.ggml_cpu_has_fma.argtypes = []\nlib.ggml_cpu_has_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_neon       (void);\ndef ggml_cpu_has_neon() -> int:\n    return lib.ggml_cpu_has_neon()\nlib.ggml_cpu_has_neon.argtypes = []\nlib.ggml_cpu_has_neon.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_arm_fma    (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_neon",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_neon() -> int:\n    return lib.ggml_cpu_has_neon()\nlib.ggml_cpu_has_neon.argtypes = []\nlib.ggml_cpu_has_neon.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_arm_fma    (void);\ndef ggml_cpu_has_arm_fma() -> int:\n    return lib.ggml_cpu_has_arm_fma()\nlib.ggml_cpu_has_arm_fma.argtypes = []\nlib.ggml_cpu_has_arm_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_metal      (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_arm_fma",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_arm_fma() -> int:\n    return lib.ggml_cpu_has_arm_fma()\nlib.ggml_cpu_has_arm_fma.argtypes = []\nlib.ggml_cpu_has_arm_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_metal      (void);\ndef ggml_cpu_has_metal() -> int:\n    return lib.ggml_cpu_has_metal()\nlib.ggml_cpu_has_metal.argtypes = []\nlib.ggml_cpu_has_metal.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_f16c       (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_metal",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_metal() -> int:\n    return lib.ggml_cpu_has_metal()\nlib.ggml_cpu_has_metal.argtypes = []\nlib.ggml_cpu_has_metal.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_f16c       (void);\ndef ggml_cpu_has_f16c() -> int:\n    return lib.ggml_cpu_has_f16c()\nlib.ggml_cpu_has_f16c.argtypes = []\nlib.ggml_cpu_has_f16c.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fp16_va    (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_f16c",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_f16c() -> int:\n    return lib.ggml_cpu_has_f16c()\nlib.ggml_cpu_has_f16c.argtypes = []\nlib.ggml_cpu_has_f16c.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fp16_va    (void);\ndef ggml_cpu_has_fp16_va() -> int:\n    return lib.ggml_cpu_has_fp16_va()\nlib.ggml_cpu_has_fp16_va.argtypes = []\nlib.ggml_cpu_has_fp16_va.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_wasm_simd  (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_fp16_va",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_fp16_va() -> int:\n    return lib.ggml_cpu_has_fp16_va()\nlib.ggml_cpu_has_fp16_va.argtypes = []\nlib.ggml_cpu_has_fp16_va.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_wasm_simd  (void);\ndef ggml_cpu_has_wasm_simd() -> int:\n    return lib.ggml_cpu_has_wasm_simd()\nlib.ggml_cpu_has_wasm_simd.argtypes = []\nlib.ggml_cpu_has_wasm_simd.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_blas       (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_wasm_simd",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_wasm_simd() -> int:\n    return lib.ggml_cpu_has_wasm_simd()\nlib.ggml_cpu_has_wasm_simd.argtypes = []\nlib.ggml_cpu_has_wasm_simd.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_blas       (void);\ndef ggml_cpu_has_blas() -> int:\n    return lib.ggml_cpu_has_blas()\nlib.ggml_cpu_has_blas.argtypes = []\nlib.ggml_cpu_has_blas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_cublas     (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_blas",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_blas() -> int:\n    return lib.ggml_cpu_has_blas()\nlib.ggml_cpu_has_blas.argtypes = []\nlib.ggml_cpu_has_blas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_cublas     (void);\ndef ggml_cpu_has_cublas() -> int:\n    return lib.ggml_cpu_has_cublas()\nlib.ggml_cpu_has_cublas.argtypes = []\nlib.ggml_cpu_has_cublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_clblast    (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_cublas",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_cublas() -> int:\n    return lib.ggml_cpu_has_cublas()\nlib.ggml_cpu_has_cublas.argtypes = []\nlib.ggml_cpu_has_cublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_clblast    (void);\ndef ggml_cpu_has_clblast() -> int:\n    return lib.ggml_cpu_has_clblast()\nlib.ggml_cpu_has_clblast.argtypes = []\nlib.ggml_cpu_has_clblast.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_gpublas    (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_clblast",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_clblast() -> int:\n    return lib.ggml_cpu_has_clblast()\nlib.ggml_cpu_has_clblast.argtypes = []\nlib.ggml_cpu_has_clblast.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_gpublas    (void);\ndef ggml_cpu_has_gpublas() -> int:\n    return lib.ggml_cpu_has_gpublas()\nlib.ggml_cpu_has_gpublas.argtypes = []\nlib.ggml_cpu_has_gpublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_sse3       (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_gpublas",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_gpublas() -> int:\n    return lib.ggml_cpu_has_gpublas()\nlib.ggml_cpu_has_gpublas.argtypes = []\nlib.ggml_cpu_has_gpublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_sse3       (void);\ndef ggml_cpu_has_sse3() -> int:\n    return lib.ggml_cpu_has_sse3()\nlib.ggml_cpu_has_sse3.argtypes = []\nlib.ggml_cpu_has_sse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_ssse3      (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_sse3",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_sse3() -> int:\n    return lib.ggml_cpu_has_sse3()\nlib.ggml_cpu_has_sse3.argtypes = []\nlib.ggml_cpu_has_sse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_ssse3      (void);\ndef ggml_cpu_has_ssse3() -> int:\n    return lib.ggml_cpu_has_ssse3()\nlib.ggml_cpu_has_ssse3.argtypes = []\nlib.ggml_cpu_has_ssse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_vsx        (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_ssse3",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_ssse3() -> int:\n    return lib.ggml_cpu_has_ssse3()\nlib.ggml_cpu_has_ssse3.argtypes = []\nlib.ggml_cpu_has_ssse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_vsx        (void);\ndef ggml_cpu_has_vsx() -> int:\n    return lib.ggml_cpu_has_vsx()\nlib.ggml_cpu_has_vsx.argtypes = []\nlib.ggml_cpu_has_vsx.restype = ctypes.c_int\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cpu_has_vsx",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cpu_has_vsx() -> int:\n    return lib.ggml_cpu_has_vsx()\nlib.ggml_cpu_has_vsx.argtypes = []\nlib.ggml_cpu_has_vsx.restype = ctypes.c_int\n# //\n# // Internal types and functions exposed for tests and benchmarks\n# //\n# typedef void (*ggml_to_float_t)(const void * x, float * y, int k);\nggml_to_float_t = ctypes.CFUNCTYPE(\n    None, ctypes.c_void_p, ctypes.POINTER(ctypes.c_float), ctypes.c_int",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_internal_get_type_traits",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_internal_get_type_traits(type: Union[ctypes.c_int, int]) -> ggml_type_traits_t:\n    return lib.ggml_internal_get_type_traits(type)\nlib.ggml_internal_get_type_traits.argtypes = [ctypes.c_int]\nlib.ggml_internal_get_type_traits.restype = ggml_type_traits_t\n#####################################################\n# GGML ALLOC API\n# source: ggml-alloc.h\n#####################################################\n# struct ggml_backend;\n# struct ggml_backend_buffer;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_new",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_new(\n    data: ctypes.c_void_p,\n    size: Union[ctypes.c_size_t, int],\n    alignment: Union[ctypes.c_size_t, int],\n) -> ggml_allocr_t:\n    return lib.ggml_allocr_new(data, size, alignment)\nlib.ggml_allocr_new.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t]\nlib.ggml_allocr_new.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_measure(size_t alignment);\ndef ggml_allocr_new_measure(alignment: Union[ctypes.c_size_t, int]) -> ggml_allocr_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_new_measure",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_new_measure(alignment: Union[ctypes.c_size_t, int]) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_measure(alignment)\nlib.ggml_allocr_new_measure.argtypes = [ctypes.c_size_t]\nlib.ggml_allocr_new_measure.restype = ggml_allocr_t\n# // initialize allocator for use with ggml-backend\n# GGML_API ggml_allocr_t ggml_allocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_allocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_from_buffer(buffer)\nlib.ggml_allocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_allocr_new_from_buffer.restype = ggml_allocr_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_new_from_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_from_buffer(buffer)\nlib.ggml_allocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_allocr_new_from_buffer.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_allocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_from_backend(backend, size)\nlib.ggml_allocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_new_from_backend",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_from_backend(backend, size)\nlib.ggml_allocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_allocr_new_from_backend.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_measure_from_backend(struct ggml_backend * backend);\ndef ggml_allocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_measure_from_backend(backend)\nlib.ggml_allocr_new_measure_from_backend.argtypes = [ggml_backend_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_new_measure_from_backend",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_measure_from_backend(backend)\nlib.ggml_allocr_new_measure_from_backend.argtypes = [ggml_backend_t]\nlib.ggml_allocr_new_measure_from_backend.restype = ggml_allocr_t\n# GGML_API struct ggml_backend_buffer * ggml_allocr_get_buffer(ggml_allocr_t alloc);\ndef ggml_allocr_get_buffer(alloc: ggml_allocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_allocr_get_buffer(alloc)\nlib.ggml_allocr_get_buffer.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_get_buffer.restype = ggml_backend_buffer_p\n# // tell the allocator to parse nodes following the order described in the list",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_get_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_get_buffer(alloc: ggml_allocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_allocr_get_buffer(alloc)\nlib.ggml_allocr_get_buffer.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_get_buffer.restype = ggml_backend_buffer_p\n# // tell the allocator to parse nodes following the order described in the list\n# // you should call this if your graph are optimized to execute out-of-order\n# GGML_API void   ggml_allocr_set_parse_seq(ggml_allocr_t alloc, const int * list, int n);\ndef ggml_allocr_set_parse_seq(\n    alloc: ggml_allocr_t,\n    list: \"ctypes._Pointer(ctypes.c_int)\",  # type: ignore",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_set_parse_seq",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_set_parse_seq(\n    alloc: ggml_allocr_t,\n    list: \"ctypes._Pointer(ctypes.c_int)\",  # type: ignore\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_allocr_set_parse_seq(alloc, list, n)\nlib.ggml_allocr_set_parse_seq.argtypes = [\n    ggml_allocr_t,\n    ctypes.POINTER(ctypes.c_int),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_free(alloc: ggml_allocr_t) -> None:\n    return lib.ggml_allocr_free(alloc)\nlib.ggml_allocr_free.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_free.restype = None\n# GGML_API bool   ggml_allocr_is_measure (ggml_allocr_t alloc);\ndef ggml_allocr_is_measure(alloc: ggml_allocr_t) -> ctypes.c_bool:\n    return lib.ggml_allocr_is_measure(alloc)\nlib.ggml_allocr_is_measure.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_allocr_reset      (ggml_allocr_t alloc);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_is_measure",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_is_measure(alloc: ggml_allocr_t) -> ctypes.c_bool:\n    return lib.ggml_allocr_is_measure(alloc)\nlib.ggml_allocr_is_measure.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_allocr_reset      (ggml_allocr_t alloc);\ndef ggml_allocr_reset(alloc: ggml_allocr_t) -> None:\n    return lib.ggml_allocr_reset(alloc)\nlib.ggml_allocr_reset.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_reset.restype = None\n# GGML_API void   ggml_allocr_alloc      (ggml_allocr_t alloc, struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_reset",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_reset(alloc: ggml_allocr_t) -> None:\n    return lib.ggml_allocr_reset(alloc)\nlib.ggml_allocr_reset.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_reset.restype = None\n# GGML_API void   ggml_allocr_alloc      (ggml_allocr_t alloc, struct ggml_tensor * tensor);\ndef ggml_allocr_alloc(alloc: ggml_allocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_allocr_alloc(alloc, tensor)\nlib.ggml_allocr_alloc.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_allocr_alloc.restype = None\n# GGML_API size_t ggml_allocr_max_size   (ggml_allocr_t alloc);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_alloc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_alloc(alloc: ggml_allocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_allocr_alloc(alloc, tensor)\nlib.ggml_allocr_alloc.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_allocr_alloc.restype = None\n# GGML_API size_t ggml_allocr_max_size   (ggml_allocr_t alloc);\ndef ggml_allocr_max_size(alloc: ggml_allocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_allocr_max_size(alloc)\nlib.ggml_allocr_max_size.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_max_size.restype = ctypes.c_size_t\n# GGML_API size_t ggml_allocr_alloc_graph(ggml_allocr_t alloc, struct ggml_cgraph * graph);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_max_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_max_size(alloc: ggml_allocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_allocr_max_size(alloc)\nlib.ggml_allocr_max_size.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_max_size.restype = ctypes.c_size_t\n# GGML_API size_t ggml_allocr_alloc_graph(ggml_allocr_t alloc, struct ggml_cgraph * graph);\ndef ggml_allocr_alloc_graph(alloc: ggml_allocr_t, graph: ggml_cgraph_p) -> int:\n    return lib.ggml_allocr_alloc_graph(alloc, graph)\nlib.ggml_allocr_alloc_graph.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_cgraph)]\nlib.ggml_allocr_alloc_graph.restype = ctypes.c_size_t\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_alloc_graph",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_allocr_alloc_graph(alloc: ggml_allocr_t, graph: ggml_cgraph_p) -> int:\n    return lib.ggml_allocr_alloc_graph(alloc, graph)\nlib.ggml_allocr_alloc_graph.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_cgraph)]\nlib.ggml_allocr_alloc_graph.restype = ctypes.c_size_t\n# //\n# // ggml-backend v2 API\n# //\n# // Separate tensor and graph allocator objects\n# // This is necessary for multi-backend allocation because the graph allocator needs to use multiple tensor allocators\n# // The original API is kept as a wrapper around the new API",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_new",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_new(\n    data: ctypes.c_void_p,\n    size: Union[ctypes.c_size_t, int],\n    alignment: Union[ctypes.c_size_t, int],\n) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new(data, size, alignment)\nlib.ggml_tallocr_new.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t]\nlib.ggml_tallocr_new.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_measure(size_t alignment);\ndef ggml_tallocr_new_measure(alignment: Union[ctypes.c_size_t, int]) -> ggml_tallocr_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_new_measure",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_new_measure(alignment: Union[ctypes.c_size_t, int]) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_measure(alignment)\nlib.ggml_tallocr_new_measure.argtypes = [ctypes.c_size_t]\nlib.ggml_tallocr_new_measure.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_tallocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_buffer(buffer)\nlib.ggml_tallocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_tallocr_new_from_buffer.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_new_from_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_buffer(buffer)\nlib.ggml_tallocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_tallocr_new_from_buffer.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_tallocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_backend(backend, size)\nlib.ggml_tallocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_new_from_backend",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_backend(backend, size)\nlib.ggml_tallocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_tallocr_new_from_backend.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_measure_from_backend(struct ggml_backend * backend);\ndef ggml_tallocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_measure_from_backend(backend)\nlib.ggml_tallocr_new_measure_from_backend.argtypes = [ggml_backend_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_new_measure_from_backend",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_measure_from_backend(backend)\nlib.ggml_tallocr_new_measure_from_backend.argtypes = [ggml_backend_t]\nlib.ggml_tallocr_new_measure_from_backend.restype = ggml_tallocr_t\n# GGML_API struct ggml_backend_buffer * ggml_tallocr_get_buffer(ggml_tallocr_t talloc);\ndef ggml_tallocr_get_buffer(talloc: ggml_tallocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_tallocr_get_buffer(talloc)\nlib.ggml_tallocr_get_buffer.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_get_buffer.restype = ggml_backend_buffer_p\n# GGML_API void   ggml_tallocr_free       (ggml_tallocr_t talloc);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_get_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_get_buffer(talloc: ggml_tallocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_tallocr_get_buffer(talloc)\nlib.ggml_tallocr_get_buffer.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_get_buffer.restype = ggml_backend_buffer_p\n# GGML_API void   ggml_tallocr_free       (ggml_tallocr_t talloc);\ndef ggml_tallocr_free(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_free(talloc)\nlib.ggml_tallocr_free.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_free.restype = None\n# GGML_API bool   ggml_tallocr_is_measure (ggml_tallocr_t talloc);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_free(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_free(talloc)\nlib.ggml_tallocr_free.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_free.restype = None\n# GGML_API bool   ggml_tallocr_is_measure (ggml_tallocr_t talloc);\ndef ggml_tallocr_is_measure(talloc: ggml_tallocr_t) -> bool:\n    return lib.ggml_tallocr_is_measure(talloc)\nlib.ggml_tallocr_is_measure.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_tallocr_reset      (ggml_tallocr_t talloc);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_is_measure",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_is_measure(talloc: ggml_tallocr_t) -> bool:\n    return lib.ggml_tallocr_is_measure(talloc)\nlib.ggml_tallocr_is_measure.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_tallocr_reset      (ggml_tallocr_t talloc);\ndef ggml_tallocr_reset(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_reset(talloc)\nlib.ggml_tallocr_reset.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_reset.restype = None\n# GGML_API void   ggml_tallocr_alloc      (ggml_tallocr_t talloc, struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_reset",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_reset(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_reset(talloc)\nlib.ggml_tallocr_reset.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_reset.restype = None\n# GGML_API void   ggml_tallocr_alloc      (ggml_tallocr_t talloc, struct ggml_tensor * tensor);\ndef ggml_tallocr_alloc(talloc: ggml_tallocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_tallocr_alloc(talloc, tensor)\nlib.ggml_tallocr_alloc.argtypes = [ggml_tallocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_tallocr_alloc.restype = None\n# GGML_API size_t ggml_tallocr_max_size   (ggml_tallocr_t talloc);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_alloc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_alloc(talloc: ggml_tallocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_tallocr_alloc(talloc, tensor)\nlib.ggml_tallocr_alloc.argtypes = [ggml_tallocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_tallocr_alloc.restype = None\n# GGML_API size_t ggml_tallocr_max_size   (ggml_tallocr_t talloc);\ndef ggml_tallocr_max_size(talloc: ggml_tallocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_tallocr_max_size(talloc)\nlib.ggml_tallocr_max_size.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_max_size.restype = ctypes.c_size_t\n# // Graph allocator",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_max_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_tallocr_max_size(talloc: ggml_tallocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_tallocr_max_size(talloc)\nlib.ggml_tallocr_max_size.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_max_size.restype = ctypes.c_size_t\n# // Graph allocator\n# typedef struct ggml_gallocr * ggml_gallocr_t;\nggml_gallocr_t = ctypes.c_void_p\n# GGML_API ggml_gallocr_t ggml_gallocr_new(void);\ndef ggml_gallocr_new() -> ggml_gallocr_t:\n    return lib.ggml_gallocr_new()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gallocr_new",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_gallocr_new() -> ggml_gallocr_t:\n    return lib.ggml_gallocr_new()\nlib.ggml_gallocr_new.argtypes = []\nlib.ggml_gallocr_new.restype = ggml_gallocr_t\n# GGML_API void   ggml_gallocr_free(ggml_gallocr_t galloc);\ndef ggml_gallocr_free(galloc: ggml_gallocr_t) -> None:\n    return lib.ggml_gallocr_free(galloc)\nlib.ggml_gallocr_free.argtypes = [ggml_gallocr_t]\nlib.ggml_gallocr_free.restype = None\n# GGML_API void   ggml_gallocr_set_parse_seq(ggml_gallocr_t galloc, const int * list, int n);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gallocr_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_gallocr_free(galloc: ggml_gallocr_t) -> None:\n    return lib.ggml_gallocr_free(galloc)\nlib.ggml_gallocr_free.argtypes = [ggml_gallocr_t]\nlib.ggml_gallocr_free.restype = None\n# GGML_API void   ggml_gallocr_set_parse_seq(ggml_gallocr_t galloc, const int * list, int n);\ndef ggml_gallocr_set_parse_seq(\n    galloc: ggml_gallocr_t,\n    list: \"ctypes._Pointer(ctypes.c_int)\",  # type: ignore\n    n: Union[ctypes.c_int, int],\n) -> None:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gallocr_set_parse_seq",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_gallocr_set_parse_seq(\n    galloc: ggml_gallocr_t,\n    list: \"ctypes._Pointer(ctypes.c_int)\",  # type: ignore\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_gallocr_set_parse_seq(galloc, list, n)\nlib.ggml_gallocr_set_parse_seq.argtypes = [\n    ggml_gallocr_t,\n    ctypes.POINTER(ctypes.c_int),\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gallocr_alloc_graph",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_gallocr_alloc_graph(\n    galloc: ggml_gallocr_t, talloc: ggml_tallocr_t, graph: ggml_cgraph_p\n) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_gallocr_alloc_graph(galloc, talloc, graph)\nlib.ggml_gallocr_alloc_graph.argtypes = [\n    ggml_gallocr_t,\n    ggml_tallocr_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_gallocr_alloc_graph.restype = ctypes.c_size_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gallocr_alloc_graph_n",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_gallocr_alloc_graph_n(\n    galloc: ggml_gallocr_t,\n    graph: ggml_cgraph_p,\n    hash_set: ggml_hash_set,\n    hash_node_talloc: \"ctypes._Pointer(ggml_tallocr_t)\",  # type: ignore\n) -> None:\n    return lib.ggml_gallocr_alloc_graph_n(galloc, graph, hash_set, hash_node_talloc)\nlib.ggml_gallocr_alloc_graph_n.argtypes = [\n    ggml_gallocr_t,\n    ctypes.POINTER(ggml_cgraph),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_alloc_ctx_tensors_from_buft",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_alloc_ctx_tensors_from_buft(\n    ctx: ggml_context_p, buft: ggml_backend_buffer_type_p\n) -> ggml_backend_buffer_p:\n    return lib.ggml_backend_alloc_ctx_tensors_from_buft(ctx, buft)\nlib.ggml_backend_alloc_ctx_tensors_from_buft.argtypes = [\n    ggml_context_p,\n    ggml_backend_buffer_type_p,\n]\nlib.ggml_backend_alloc_ctx_tensors_from_buft.restype = ggml_backend_buffer_p\n# GGML_API struct ggml_backend_buffer * ggml_backend_alloc_ctx_tensors(struct ggml_context * ctx, struct ggml_backend * backend);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_alloc_ctx_tensors",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_alloc_ctx_tensors(\n    ctx: ggml_context_p, backend: ggml_backend_t\n) -> ggml_backend_buffer_p:\n    return lib.ggml_backend_alloc_ctx_tensors(ctx, backend)\nlib.ggml_backend_alloc_ctx_tensors.argtypes = [\n    ggml_context_p,\n    ggml_backend_t,\n]\nlib.ggml_backend_alloc_ctx_tensors.restype = ggml_backend_buffer_p\n#####################################################",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buft_alloc_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buft_alloc_buffer(\n    buft: ggml_backend_buffer_type_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_buft_alloc_buffer(buft, size)\nlib.ggml_backend_buft_alloc_buffer.argtypes = [\n    ggml_backend_buffer_type_t,\n    ctypes.c_size_t,\n]\nlib.ggml_backend_buft_alloc_buffer.restype = ggml_backend_buffer_t\n# GGML_API size_t ggml_backend_buft_get_alignment (ggml_backend_buffer_type_t buft);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buft_get_alignment",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buft_get_alignment(\n    buft: ggml_backend_buffer_type_t,\n) -> int:\n    return lib.ggml_backend_buft_get_alignment(buft)\nlib.ggml_backend_buft_get_alignment.argtypes = [ggml_backend_buffer_type_t]\nlib.ggml_backend_buft_get_alignment.restype = ctypes.c_size_t\n# GGML_API size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, struct ggml_tensor * tensor);\ndef ggml_backend_buft_get_alloc_size(\n    buft: ggml_backend_buffer_type_t, tensor: ggml_tensor_p\n) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buft_get_alloc_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buft_get_alloc_size(\n    buft: ggml_backend_buffer_type_t, tensor: ggml_tensor_p\n) -> int:\n    return lib.ggml_backend_buft_get_alloc_size(buft, tensor)\nlib.ggml_backend_buft_get_alloc_size.argtypes = [\n    ggml_backend_buffer_type_t,\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_buft_get_alloc_size.restype = ctypes.c_size_t\n# GGML_API bool ggml_backend_buft_supports_backend(ggml_backend_buffer_type_t buft, ggml_backend_t backend);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buft_supports_backend",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buft_supports_backend(\n    buft: ggml_backend_buffer_type_t, backend: ggml_backend_t\n) -> bool:\n    return lib.ggml_backend_buft_supports_backend(buft, backend)\nlib.ggml_backend_buft_supports_backend.argtypes = [\n    ggml_backend_buffer_type_t,\n    ggml_backend_t,\n]\nlib.ggml_backend_buft_supports_backend.restype = ctypes.c_bool\n# // buffer",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buffer_free(\n    buffer: ggml_backend_buffer_t,\n):\n    return lib.ggml_backend_buffer_free(buffer)\nlib.ggml_backend_buffer_free.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_free.restype = None\n# GGML_API void * ggml_backend_buffer_get_base      (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_get_base(\n    buffer: ggml_backend_buffer_t,\n) -> ctypes.c_void_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_get_base",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buffer_get_base(\n    buffer: ggml_backend_buffer_t,\n) -> ctypes.c_void_p:\n    return lib.ggml_backend_buffer_get_base(buffer)\nlib.ggml_backend_buffer_get_base.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_base.restype = ctypes.c_void_p\n# GGML_API size_t ggml_backend_buffer_get_size      (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_get_size(\n    buffer: ggml_backend_buffer_t,\n) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_get_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buffer_get_size(\n    buffer: ggml_backend_buffer_t,\n) -> int:\n    return lib.ggml_backend_buffer_get_size(buffer)\nlib.ggml_backend_buffer_get_size.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_size.restype = ctypes.c_size_t\n# GGML_API void   ggml_backend_buffer_init_tensor   (ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_buffer_init_tensor(\n    buffer: ggml_backend_buffer_t,\n    tensor: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_init_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buffer_init_tensor(\n    buffer: ggml_backend_buffer_t,\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_backend_buffer_init_tensor(buffer, tensor)\nlib.ggml_backend_buffer_init_tensor.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_buffer_init_tensor.restype = None",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_get_alignment",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buffer_get_alignment(\n    buffer: ggml_backend_buffer_t,\n) -> int:\n    return lib.ggml_backend_buffer_get_alignment(buffer)\nlib.ggml_backend_buffer_get_alignment.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_alignment.restype = ctypes.c_size_t\n# GGML_API size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_buffer_get_alloc_size(\n    buffer: ggml_backend_buffer_t, tensor: ggml_tensor_p\n) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_get_alloc_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buffer_get_alloc_size(\n    buffer: ggml_backend_buffer_t, tensor: ggml_tensor_p\n) -> int:\n    return lib.ggml_backend_buffer_get_alloc_size(buffer, tensor)\nlib.ggml_backend_buffer_get_alloc_size.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_buffer_get_alloc_size.restype = ctypes.c_size_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_buffer_type(ggml_backend_buffer_t buffer);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buffer_type(\n    buffer: ggml_backend_buffer_t,\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_buffer_type(buffer)\nlib.ggml_backend_buffer_type.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_type.restype = ggml_backend_buffer_type_t\n# //\n# // Backend\n# //\n# GGML_API const char * ggml_backend_name(ggml_backend_t backend);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_name(\n    backend: ggml_backend_t,\n) -> bytes:\n    return lib.ggml_backend_name(backend)\nlib.ggml_backend_name.argtypes = [ggml_backend_t]\nlib.ggml_backend_name.restype = ctypes.c_char_p\n# GGML_API void         ggml_backend_free(ggml_backend_t backend);\ndef ggml_backend_free(\n    backend: ggml_backend_t,\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_free(\n    backend: ggml_backend_t,\n):\n    return lib.ggml_backend_free(backend)\nlib.ggml_backend_free.argtypes = [ggml_backend_t]\nlib.ggml_backend_free.restype = None\n# GGML_API ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend);\ndef ggml_backend_get_default_buffer_type(\n    backend: ggml_backend_t,\n) -> ggml_backend_buffer_type_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_get_default_buffer_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_get_default_buffer_type(\n    backend: ggml_backend_t,\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_get_default_buffer_type(backend)\nlib.ggml_backend_get_default_buffer_type.argtypes = [ggml_backend_t]\nlib.ggml_backend_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size);\ndef ggml_backend_alloc_buffer(\n    backend: ggml_backend_t,\n    size: Union[ctypes.c_size_t, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_alloc_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_alloc_buffer(\n    backend: ggml_backend_t,\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_alloc_buffer(backend, size)\nlib.ggml_backend_alloc_buffer.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_backend_alloc_buffer.restype = ggml_backend_buffer_t\n# GGML_API size_t                     ggml_backend_get_alignment(ggml_backend_t backend);\ndef ggml_backend_get_alignment(\n    backend: ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_get_alignment",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_get_alignment(\n    backend: ggml_backend_t,\n) -> int:\n    return lib.ggml_backend_get_alignment(backend)\nlib.ggml_backend_get_alignment.argtypes = [ggml_backend_t]\nlib.ggml_backend_get_alignment.restype = ctypes.c_size_t\n# GGML_API void ggml_backend_tensor_set_async(ggml_backend_t backend,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_set_async(\n    backend: ggml_backend_t,\n    tensor: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_tensor_set_async",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_tensor_set_async(\n    backend: ggml_backend_t,\n    tensor: ggml_tensor_p,\n    data: ctypes.c_void_p,\n    offset: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_backend_tensor_set_async(backend, tensor, data, offset, size)\nlib.ggml_backend_tensor_set_async.argtypes = [\n    ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_tensor_get_async",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_tensor_get_async(\n    backend: ggml_backend_t,\n    tensor: ggml_tensor_p,\n    data: ctypes.c_void_p,\n    offset: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_backend_tensor_get_async(backend, tensor, data, offset, size)\nlib.ggml_backend_tensor_get_async.argtypes = [\n    ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_tensor_set",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_tensor_set(\n    tensor: ggml_tensor_p,\n    data: ctypes.c_void_p,\n    offset: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_backend_tensor_set(tensor, data, offset, size)\nlib.ggml_backend_tensor_set.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_tensor_get",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_tensor_get(\n    tensor: ggml_tensor_p,\n    data: ctypes.c_void_p,\n    offset: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_backend_tensor_get(tensor, data, offset, size)\nlib.ggml_backend_tensor_get.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_synchronize",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_synchronize(\n    backend: ggml_backend_t,\n):\n    return lib.ggml_backend_synchronize(backend)\nlib.ggml_backend_synchronize.argtypes = [ggml_backend_t]\nlib.ggml_backend_synchronize.restype = None\n# GGML_API ggml_backend_graph_plan_t ggml_backend_graph_plan_create (ggml_backend_t backend, struct ggml_cgraph * cgraph);\ndef ggml_backend_graph_plan_create(\n    backend: ggml_backend_t,\n    cgraph: ggml_cgraph_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_graph_plan_create",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_graph_plan_create(\n    backend: ggml_backend_t,\n    cgraph: ggml_cgraph_p,\n) -> ggml_backend_graph_plan_t:\n    return lib.ggml_backend_graph_plan_create(backend, cgraph)\nlib.ggml_backend_graph_plan_create.argtypes = [\n    ggml_backend_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_backend_graph_plan_create.restype = ggml_backend_graph_plan_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_graph_plan_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_graph_plan_free(\n    backend: ggml_backend_t,\n    plan: ggml_backend_graph_plan_t,\n):\n    return lib.ggml_backend_graph_plan_free(backend, plan)\nlib.ggml_backend_graph_plan_free.argtypes = [ggml_backend_t, ggml_backend_graph_plan_t]\nlib.ggml_backend_graph_plan_free.restype = None\n# GGML_API void ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan);\ndef ggml_backend_graph_plan_compute(\n    backend: ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_graph_plan_compute",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_graph_plan_compute(\n    backend: ggml_backend_t,\n    plan: ggml_backend_graph_plan_t,\n):\n    return lib.ggml_backend_graph_plan_compute(backend, plan)\nlib.ggml_backend_graph_plan_compute.argtypes = [\n    ggml_backend_t,\n    ggml_backend_graph_plan_t,\n]\nlib.ggml_backend_graph_plan_compute.restype = None",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_graph_compute",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_graph_compute(\n    backend: ggml_backend_t,\n    cgraph: ggml_cgraph_p,\n):\n    return lib.ggml_backend_graph_compute(backend, cgraph)\nlib.ggml_backend_graph_compute.argtypes = [ggml_backend_t, ctypes.POINTER(ggml_cgraph)]\nlib.ggml_backend_graph_compute.restype = None\n# GGML_API bool ggml_backend_supports_op       (ggml_backend_t backend, const struct ggml_tensor * op);\ndef ggml_backend_supports_op(\n    backend: ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_supports_op",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_supports_op(\n    backend: ggml_backend_t,\n    op: ggml_tensor_p,\n) -> Union[ctypes.c_bool, bool]:\n    return lib.ggml_backend_supports_op(backend, op)\nlib.ggml_backend_supports_op.argtypes = [ggml_backend_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_backend_supports_op.restype = ctypes.c_bool\n# // tensor copy between different backends\n# GGML_API void ggml_backend_tensor_copy(struct ggml_tensor * src, struct ggml_tensor * dst);\ndef ggml_backend_tensor_copy(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_tensor_copy",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_tensor_copy(\n    src: ggml_tensor_p,\n    dst: ggml_tensor_p,\n):\n    return lib.ggml_backend_tensor_copy(src, dst)\nlib.ggml_backend_tensor_copy.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_tensor_copy.restype = None",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_tensor_copy_async",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_tensor_copy_async(\n    backend: ggml_backend_t,\n    src: ggml_tensor_p,\n    dst: ggml_tensor_p,\n):\n    return lib.ggml_backend_tensor_copy_async(backend, src, dst)\n# lib.ggml_backend_tensor_copy_async.argtypes = [\n#     ggml_backend_t,\n#     ctypes.POINTER(ggml_tensor),\n#     ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_cpu_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_cpu_init() -> ggml_backend_t:\n    return lib.ggml_backend_cpu_init()\nlib.ggml_backend_cpu_init.argtypes = []\nlib.ggml_backend_cpu_init.restype = ggml_backend_t\n# GGML_API bool ggml_backend_is_cpu(ggml_backend_t backend);\ndef ggml_backend_is_cpu(\n    backend: ggml_backend_t,\n) -> bool:\n    return lib.ggml_backend_is_cpu(backend)\nlib.ggml_backend_is_cpu.argtypes = [ggml_backend_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_is_cpu",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_is_cpu(\n    backend: ggml_backend_t,\n) -> bool:\n    return lib.ggml_backend_is_cpu(backend)\nlib.ggml_backend_is_cpu.argtypes = [ggml_backend_t]\nlib.ggml_backend_is_cpu.restype = ctypes.c_bool\n# GGML_API void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads);\ndef ggml_backend_cpu_set_n_threads(\n    backend_cpu: ggml_backend_t,\n    n_threads: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_cpu_set_n_threads",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_cpu_set_n_threads(\n    backend_cpu: ggml_backend_t,\n    n_threads: Union[ctypes.c_int, int],\n):\n    return lib.ggml_backend_cpu_set_n_threads(backend_cpu, n_threads)\nlib.ggml_backend_cpu_set_n_threads.argtypes = [ggml_backend_t, ctypes.c_int]\nlib.ggml_backend_cpu_set_n_threads.restype = None\n# // Create a backend buffer from an existing pointer\n# GGML_API ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void * ptr, size_t size);\ndef ggml_backend_cpu_buffer_from_ptr(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_cpu_buffer_from_ptr",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_cpu_buffer_from_ptr(\n    ptr: ctypes.c_void_p,\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_cpu_buffer_from_ptr(ptr, size)\nlib.ggml_backend_cpu_buffer_from_ptr.argtypes = [ctypes.c_void_p, ctypes.c_size_t]\nlib.ggml_backend_cpu_buffer_from_ptr.restype = ggml_backend_buffer_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type(void);\ndef ggml_backend_cpu_buffer_type() -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_cpu_buffer_type()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_cpu_buffer_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_cpu_buffer_type() -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_cpu_buffer_type()\nlib.ggml_backend_cpu_buffer_type.argtypes = []\nlib.ggml_backend_cpu_buffer_type.restype = ggml_backend_buffer_type_t\n# //\n# // Backend registry\n# //\n# // The backend registry is a registry of all the available backends, and allows initializing backends in a generic way\n# GGML_API size_t                     ggml_backend_reg_get_count(void);\ndef ggml_backend_reg_get_count() -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_reg_get_count",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_reg_get_count() -> int:\n    return lib.ggml_backend_reg_get_count()\nlib.ggml_backend_reg_get_count.argtypes = []\nlib.ggml_backend_reg_get_count.restype = ctypes.c_size_t\n# GGML_API size_t                     ggml_backend_reg_find_by_name(const char * name);\ndef ggml_backend_reg_find_by_name(\n    name: bytes,\n) -> int:\n    return lib.ggml_backend_reg_find_by_name(name)\nlib.ggml_backend_reg_find_by_name.argtypes = [ctypes.c_char_p]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_reg_find_by_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_reg_find_by_name(\n    name: bytes,\n) -> int:\n    return lib.ggml_backend_reg_find_by_name(name)\nlib.ggml_backend_reg_find_by_name.argtypes = [ctypes.c_char_p]\nlib.ggml_backend_reg_find_by_name.restype = ctypes.c_size_t\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend_from_str(const char * backend_str); // str is name[:params]\ndef ggml_backend_reg_init_backend_from_str(\n    backend_str: bytes,\n) -> ggml_backend_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_reg_init_backend_from_str",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_reg_init_backend_from_str(\n    backend_str: bytes,\n) -> ggml_backend_t:\n    return lib.ggml_backend_reg_init_backend_from_str(backend_str)\nlib.ggml_backend_reg_init_backend_from_str.argtypes = [ctypes.c_char_p]\nlib.ggml_backend_reg_init_backend_from_str.restype = ggml_backend_t\n# GGML_API const char *               ggml_backend_reg_get_name(size_t i);\ndef ggml_backend_reg_get_name(\n    i: Union[ctypes.c_size_t, int],\n) -> bytes:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_reg_get_name",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_reg_get_name(\n    i: Union[ctypes.c_size_t, int],\n) -> bytes:\n    return lib.ggml_backend_reg_get_name(i)\nlib.ggml_backend_reg_get_name.argtypes = [ctypes.c_size_t]\nlib.ggml_backend_reg_get_name.restype = ctypes.c_char_p\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend(size_t i, const char * params); // params is backend-specific\ndef ggml_backend_reg_init_backend(\n    i: Union[ctypes.c_size_t, int],\n    params: bytes,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_reg_init_backend",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_reg_init_backend(\n    i: Union[ctypes.c_size_t, int],\n    params: bytes,\n) -> ggml_backend_t:\n    return lib.ggml_backend_reg_init_backend(i, params)\nlib.ggml_backend_reg_init_backend.argtypes = [ctypes.c_size_t, ctypes.c_char_p]\nlib.ggml_backend_reg_init_backend.restype = ggml_backend_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_reg_get_default_buffer_type(size_t i);\ndef ggml_backend_reg_get_default_buffer_type(\n    i: Union[ctypes.c_size_t, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_reg_get_default_buffer_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_reg_get_default_buffer_type(\n    i: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_reg_get_default_buffer_type(i)\nlib.ggml_backend_reg_get_default_buffer_type.argtypes = [ctypes.c_size_t]\nlib.ggml_backend_reg_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_reg_alloc_buffer(size_t i, size_t size);\ndef ggml_backend_reg_alloc_buffer(\n    i: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_reg_alloc_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_reg_alloc_buffer(\n    i: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_reg_alloc_buffer(i, size)\nlib.ggml_backend_reg_alloc_buffer.argtypes = [ctypes.c_size_t, ctypes.c_size_t]\nlib.ggml_backend_reg_alloc_buffer.restype = ggml_backend_buffer_t\n# //\n# // Backend scheduler\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_sched_new",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_sched_new(\n    backends: ggml_backend_t,\n    n_backends: Union[ctypes.c_int, int],\n) -> ggml_backend_sched_t:\n    return lib.ggml_backend_sched_new(backends, n_backends)\nlib.ggml_backend_sched_new.argtypes = [ggml_backend_t, ctypes.c_int]\nlib.ggml_backend_sched_new.restype = ggml_backend_sched_t\n# GGML_API void ggml_backend_sched_free(ggml_backend_sched_t sched);\ndef ggml_backend_sched_free(\n    sched: ggml_backend_sched_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_sched_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_sched_free(\n    sched: ggml_backend_sched_t,\n):\n    return lib.ggml_backend_sched_free(sched)\nlib.ggml_backend_sched_free.argtypes = [ggml_backend_sched_t]\nlib.ggml_backend_sched_free.restype = None\n# // Initialize backend buffers from a measure graph\n# GGML_API void ggml_backend_sched_init_measure(ggml_backend_sched_t sched, struct ggml_cgraph * measure_graph);\ndef ggml_backend_sched_init_measure(\n    sched: ggml_backend_sched_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_sched_init_measure",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_sched_init_measure(\n    sched: ggml_backend_sched_t,\n    measure_graph: ggml_cgraph_p,\n):\n    return lib.ggml_backend_sched_init_measure(sched, measure_graph)\nlib.ggml_backend_sched_init_measure.argtypes = [\n    ggml_backend_sched_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_backend_sched_init_measure.restype = None",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_sched_get_tallocr",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_sched_get_tallocr(\n    sched: ggml_backend_sched_t,\n    backend: ggml_backend_t,\n) -> ggml_tallocr_t:\n    return lib.ggml_backend_sched_get_tallocr(sched, backend)\nlib.ggml_backend_sched_get_tallocr.argtypes = [ggml_backend_sched_t, ggml_backend_t]\nlib.ggml_backend_sched_get_tallocr.restype = ggml_tallocr_t\n# GGML_API ggml_backend_buffer_t ggml_backend_sched_get_buffer (ggml_backend_sched_t sched, ggml_backend_t backend);\ndef ggml_backend_sched_get_buffer(\n    sched: ggml_backend_sched_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_sched_get_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_sched_get_buffer(\n    sched: ggml_backend_sched_t,\n    backend: ggml_backend_t,\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_sched_get_buffer(sched, backend)\nlib.ggml_backend_sched_get_buffer.argtypes = [ggml_backend_sched_t, ggml_backend_t]\nlib.ggml_backend_sched_get_buffer.restype = ggml_backend_buffer_t\n# GGML_API void ggml_backend_sched_set_node_backend(ggml_backend_sched_t sched, struct ggml_tensor * node, ggml_backend_t backend);\ndef ggml_backend_sched_set_node_backend(\n    sched: ggml_backend_sched_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_sched_set_node_backend",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_sched_set_node_backend(\n    sched: ggml_backend_sched_t,\n    node: ggml_tensor_p,\n    backend: ggml_backend_t,\n):\n    return lib.ggml_backend_sched_set_node_backend(sched, node, backend)\nlib.ggml_backend_sched_set_node_backend.argtypes = [\n    ggml_backend_sched_t,\n    ctypes.POINTER(ggml_tensor),\n    ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_sched_graph_compute",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_sched_graph_compute(\n    sched: ggml_backend_sched_t,\n    graph: ggml_cgraph_p,\n):\n    return lib.ggml_backend_sched_graph_compute(sched, graph)\nlib.ggml_backend_sched_graph_compute.argtypes = [\n    ggml_backend_sched_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_backend_sched_graph_compute.restype = None",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_graph_copy",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_graph_copy(\n    backend: ggml_backend_t,\n    graph: ggml_cgraph_p,\n) -> ggml_backend_graph_copy_t:\n    return lib.ggml_backend_graph_copy(backend, graph)\nlib.ggml_backend_graph_copy.argtypes = [\n    ggml_backend_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_backend_graph_copy.restype = ggml_backend_graph_copy_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_graph_copy_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_graph_copy_free(\n    copy: ggml_backend_graph_copy_t,\n):\n    return lib.ggml_backend_graph_copy_free(copy)\nlib.ggml_backend_graph_copy_free.argtypes = [ggml_backend_graph_copy_t]\nlib.ggml_backend_graph_copy_free.restype = None\n# typedef bool (*ggml_backend_eval_callback)(int node_index, struct ggml_tensor * t1, struct ggml_tensor * t2, void * user_data);\nggml_backend_eval_callback = ctypes.CFUNCTYPE(\n    ctypes.c_bool,\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_compare_graph_backend",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_compare_graph_backend(\n    backend1: ggml_backend_t,\n    backend2: ggml_backend_t,\n    graph: ggml_cgraph_p,\n    callback,\n    user_data: ctypes.c_void_p,\n):\n    return lib.ggml_backend_compare_graph_backend(\n        backend1, backend2, graph, callback, user_data\n    )",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_tensor_alloc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_tensor_alloc(\n    buffer: ggml_backend_buffer_t,\n    tensor: ggml_tensor_p,\n    addr: ctypes.c_void_p,\n):\n    return lib.ggml_backend_tensor_alloc(buffer, tensor, addr)\nlib.ggml_backend_tensor_alloc.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_view_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_view_init(\n    buffer: ggml_backend_buffer_t,\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_backend_view_init(buffer, tensor)\nlib.ggml_backend_view_init.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_view_init.restype = None",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_buffer_init(\n    buft: ggml_backend_buffer_type_t,\n    iface: ggml_backend_buffer_i,\n    context: ggml_backend_buffer_context_t,\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_buffer_init(buft, iface, context, size)\nlib.ggml_backend_buffer_init.argtypes = [\n    ggml_backend_buffer_type_t,\n    ggml_backend_buffer_i,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_register",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_register(\n    name: bytes,\n    init_fn,\n    default_buffer_type: ggml_backend_buffer_type_t,\n    user_data: ctypes.c_void_p,\n):\n    return lib.ggml_backend_register(name, init_fn, default_buffer_type, user_data)\nlib.ggml_backend_register.argtypes = [\n    ctypes.c_char_p,\n    ggml_backend_init_fn,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_init_cublas",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_init_cublas():\n    return lib.ggml_init_cublas()\nif GGML_USE_CUBLAS:\n    lib.ggml_init_cublas.argtypes = []\n    lib.ggml_init_cublas.restype = None\n# // Returns `true` if there are available CUDA devices and cublas loads successfully; otherwise, it returns `false`.\n# GGML_API bool   ggml_cublas_loaded(void);\ndef ggml_cublas_loaded() -> bool:\n    return lib.ggml_cublas_loaded()\nif GGML_USE_CUBLAS:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cublas_loaded",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cublas_loaded() -> bool:\n    return lib.ggml_cublas_loaded()\nif GGML_USE_CUBLAS:\n    lib.ggml_cublas_loaded.argtypes = []\n    lib.ggml_cublas_loaded.restype = ctypes.c_bool\n# void * ggml_cuda_host_malloc(size_t size);\ndef ggml_cuda_host_malloc(\n    size: Union[ctypes.c_size_t, int],\n) -> Optional[ctypes.c_void_p]:\n    return lib.ggml_cuda_host_malloc(size)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_host_malloc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_host_malloc(\n    size: Union[ctypes.c_size_t, int],\n) -> Optional[ctypes.c_void_p]:\n    return lib.ggml_cuda_host_malloc(size)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_host_malloc.argtypes = [ctypes.c_size_t]\n    lib.ggml_cuda_host_malloc.restype = ctypes.c_void_p\n# void   ggml_cuda_host_free(void * ptr);\ndef ggml_cuda_host_free(\n    ptr: ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_host_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_host_free(\n    ptr: ctypes.c_void_p,\n):\n    return lib.ggml_cuda_host_free(ptr)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_host_free.argtypes = [ctypes.c_void_p]\n    lib.ggml_cuda_host_free.restype = None\n# GGML_API bool   ggml_cuda_can_mul_mat(const struct ggml_tensor * src0, const struct ggml_tensor * src1, struct ggml_tensor * dst);\ndef ggml_cuda_can_mul_mat(\n    src0: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_can_mul_mat",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_can_mul_mat(\n    src0: ggml_tensor_p,\n    src1: ggml_tensor_p,\n    dst: ggml_tensor_p,\n) -> bool:\n    return lib.ggml_cuda_can_mul_mat(src0, src1, dst)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_can_mul_mat.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n        ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_set_tensor_split",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_set_tensor_split(\n    tensor_split: CFloatArray,\n):\n    return lib.ggml_cuda_set_tensor_split(tensor_split)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_set_tensor_split.argtypes = [ctypes.POINTER(ctypes.c_float)]\n    lib.ggml_cuda_set_tensor_split.restype = None\n# void   ggml_cuda_transform_tensor(void * data, struct ggml_tensor * tensor);\ndef ggml_cuda_transform_tensor(\n    data: ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_transform_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_transform_tensor(\n    data: ctypes.c_void_p,\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_cuda_transform_tensor(data, tensor)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_transform_tensor.argtypes = [\n        ctypes.c_void_p,\n        ctypes.POINTER(ggml_tensor),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_free_data",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_free_data(\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_cuda_free_data(tensor)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_free_data.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n    ]\n    lib.ggml_cuda_free_data.restype = None\n# void   ggml_cuda_assign_buffers(struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_assign_buffers",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_assign_buffers(\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_cuda_assign_buffers(tensor)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_assign_buffers.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n    ]\n    lib.ggml_cuda_assign_buffers.restype = None\n# void   ggml_cuda_assign_buffers_no_scratch(struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_assign_buffers_no_scratch",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_assign_buffers_no_scratch(\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_cuda_assign_buffers_no_scratch(tensor)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_assign_buffers_no_scratch.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n    ]\n    lib.ggml_cuda_assign_buffers_no_scratch.restype = None\n# GGML_API void   ggml_cuda_assign_buffers_force_inplace(struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_assign_buffers_force_inplace",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_assign_buffers_force_inplace(\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_cuda_assign_buffers_force_inplace(tensor)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_assign_buffers_force_inplace.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n    ]\n    lib.ggml_cuda_assign_buffers_force_inplace.restype = None\n# GGML_API void   ggml_cuda_assign_buffers_no_alloc(struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_assign_buffers_no_alloc",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_assign_buffers_no_alloc(\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_cuda_assign_buffers_no_alloc(tensor)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_assign_buffers_no_alloc.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n    ]\n    lib.ggml_cuda_assign_buffers_no_alloc.restype = None\n# GGML_API void   ggml_cuda_assign_scratch_offset(struct ggml_tensor * tensor, size_t offset);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_assign_scratch_offset",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_assign_scratch_offset(\n    tensor: ggml_tensor_p,\n    offset: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_cuda_assign_scratch_offset(tensor, offset)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_assign_scratch_offset.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n        ctypes.c_size_t,\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_copy_to_device",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_copy_to_device(\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_cuda_copy_to_device(tensor)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_copy_to_device.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n    ]\n    lib.ggml_cuda_copy_to_device.restype = None\n# void   ggml_cuda_set_main_device(int main_device);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_set_main_device",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_set_main_device(\n    main_device: Union[ctypes.c_int, int],\n):\n    return lib.ggml_cuda_set_main_device(main_device)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_set_main_device.argtypes = [\n        ctypes.c_int,\n    ]\n    lib.ggml_cuda_set_main_device.restype = None\n# GGML_API void   ggml_cuda_set_mul_mat_q(bool mul_mat_q);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_set_mul_mat_q",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_set_mul_mat_q(\n    mul_mat_q: Union[ctypes.c_bool, bool],\n):\n    return lib.ggml_cuda_set_mul_mat_q(mul_mat_q)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_set_mul_mat_q.argtypes = [\n        ctypes.c_bool,\n    ]\n    lib.ggml_cuda_set_mul_mat_q.restype = None\n# void   ggml_cuda_set_scratch_size(size_t scratch_size);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_set_scratch_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_set_scratch_size(\n    scratch_size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_cuda_set_scratch_size(scratch_size)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_set_scratch_size.argtypes = [\n        ctypes.c_size_t,\n    ]\n    lib.ggml_cuda_set_scratch_size.restype = None\n# void   ggml_cuda_free_scratch(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_free_scratch",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_free_scratch():\n    return lib.ggml_cuda_free_scratch()\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_free_scratch.argtypes = []\n    lib.ggml_cuda_free_scratch.restype = None\n# GGML_API bool   ggml_cuda_compute_forward(struct ggml_compute_params * params, struct ggml_tensor * tensor);\ndef ggml_cuda_compute_forward(\n    params: ggml_compute_params_p,\n    tensor: ggml_tensor_p,\n) -> bool:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_compute_forward",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_compute_forward(\n    params: ggml_compute_params_p,\n    tensor: ggml_tensor_p,\n) -> bool:\n    return lib.ggml_cuda_compute_forward(params, tensor)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_compute_forward.argtypes = [\n        ctypes.POINTER(ggml_compute_params),\n        ctypes.POINTER(ggml_tensor),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_get_device_count",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_get_device_count() -> int:\n    return lib.ggml_cuda_get_device_count()\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_get_device_count.argtypes = []\n    lib.ggml_cuda_get_device_count.restype = ctypes.c_int\n# GGML_API void   ggml_cuda_get_device_description(int device, char * description, size_t description_size);\ndef ggml_cuda_get_device_description(\n    device: Union[ctypes.c_int, int],\n    description: bytes,\n    description_size: Union[ctypes.c_size_t, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cuda_get_device_description",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cuda_get_device_description(\n    device: Union[ctypes.c_int, int],\n    description: bytes,\n    description_size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_cuda_get_device_description(device, description, description_size)\nif GGML_USE_CUBLAS:\n    lib.ggml_cuda_get_device_description.argtypes = [\n        ctypes.c_int,\n        ctypes.c_char_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_cuda_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_cuda_init() -> ggml_backend_t:\n    return lib.ggml_backend_cuda_init()\nif GGML_USE_CUBLAS:\n    lib.ggml_backend_cuda_init.argtypes = []\n    lib.ggml_backend_cuda_init.restype = ggml_backend_t\n# GGML_API bool ggml_backend_is_cuda(ggml_backend_t backend);\ndef ggml_backend_is_cuda(\n    backend: ggml_backend_t,\n) -> bool:\n    return lib.ggml_backend_is_cuda(backend)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_is_cuda",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_is_cuda(\n    backend: ggml_backend_t,\n) -> bool:\n    return lib.ggml_backend_is_cuda(backend)\nif GGML_USE_CUBLAS:\n    lib.ggml_backend_is_cuda.argtypes = [ggml_backend_t]\n    lib.ggml_backend_is_cuda.restype = ctypes.c_bool\n# GGML_API int  ggml_backend_cuda_get_device(ggml_backend_t backend);\ndef ggml_backend_cuda_get_device(\n    backend: ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_cuda_get_device",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_cuda_get_device(\n    backend: ggml_backend_t,\n) -> int:\n    return lib.ggml_backend_cuda_get_device(backend)\nif GGML_USE_CUBLAS:\n    lib.ggml_backend_cuda_get_device.argtypes = [ggml_backend_t]\n    lib.ggml_backend_cuda_get_device.restype = ctypes.c_int\n# GGML_API ggml_backend_buffer_type_t ggml_backend_cuda_buffer_type(int device);\ndef ggml_backend_cuda_buffer_type(\n    device: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_cuda_buffer_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_cuda_buffer_type(\n    device: Union[ctypes.c_int, int],\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_cuda_buffer_type(device)\nif GGML_USE_CUBLAS:\n    lib.ggml_backend_cuda_buffer_type.argtypes = [ctypes.c_int]\n    lib.ggml_backend_cuda_buffer_type.restype = ggml_backend_buffer_type_t\n# // pinned host buffer for use with CPU backend for faster copies between CPU and GPU\n# GGML_API ggml_backend_buffer_type_t ggml_backend_cuda_host_buffer_type(void);\ndef ggml_backend_cuda_host_buffer_type() -> ggml_backend_buffer_type_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_cuda_host_buffer_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_cuda_host_buffer_type() -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_cuda_host_buffer_type()\nif GGML_USE_CUBLAS:\n    lib.ggml_backend_cuda_host_buffer_type.argtypes = []\n    lib.ggml_backend_cuda_host_buffer_type.restype = ggml_backend_buffer_type_t\n#####################################################\n# GGML METAL API\n# source: ggml-metal.h\n#####################################################\nGGML_USE_METAL = hasattr(lib, \"ggml_metal_init\")",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_log_set_callback",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_log_set_callback(\n    log_callback,  # type: \"ctypes._CFuncPtr\" # type: ignore\n    user_data: ctypes.c_void_p,\n):\n    return lib.ggml_metal_log_set_callback(log_callback, user_data)\nif GGML_USE_METAL:\n    lib.ggml_metal_log_set_callback.argtypes = [\n        ggml_log_callback,\n        ctypes.c_void_p,\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_init(\n    n_cb: Union[ctypes.c_int, int],\n) -> ggml_metal_context_p:\n    return lib.ggml_metal_init(n_cb)\nif GGML_USE_METAL:\n    lib.ggml_metal_init.argtypes = [ctypes.c_int]\n    lib.ggml_metal_init.restype = ggml_metal_context_p\n# void ggml_metal_free(struct ggml_metal_context * ctx);\ndef ggml_metal_free(\n    ctx: ggml_metal_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_free",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_free(\n    ctx: ggml_metal_context_p,\n):\n    return lib.ggml_metal_free(ctx)\nif GGML_USE_METAL:\n    lib.ggml_metal_free.argtypes = [ggml_metal_context_p]\n    lib.ggml_metal_free.restype = None\n# // set the number of command buffers to use\n# void ggml_metal_set_n_cb(struct ggml_metal_context * ctx, int n_cb);\ndef ggml_metal_set_n_cb(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_set_n_cb",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_set_n_cb(\n    ctx: ggml_metal_context_p,\n    n_cb: Union[ctypes.c_int, int],\n):\n    return lib.ggml_metal_set_n_cb(ctx, n_cb)\nif GGML_USE_METAL:\n    lib.ggml_metal_set_n_cb.argtypes = [ggml_metal_context_p, ctypes.c_int]\n    lib.ggml_metal_set_n_cb.restype = None\n# // creates a mapping between a host memory buffer and a device memory buffer\n# // - make sure to map all buffers used in the graph before calling ggml_metal_graph_compute",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_add_buffer",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_add_buffer(\n    ctx: ggml_metal_context_p,\n    name: bytes,\n    data: ctypes.c_void_p,\n    size: Union[ctypes.c_size_t, int],\n    max_size: Union[ctypes.c_size_t, int],\n) -> bool:\n    return lib.ggml_metal_add_buffer(ctx, name, data, size, max_size)\nif GGML_USE_METAL:\n    lib.ggml_metal_add_buffer.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_set_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_set_tensor(\n    ctx: ggml_metal_context_p,\n    t: ggml_tensor_p,\n):\n    return lib.ggml_metal_set_tensor(ctx, t)\nif GGML_USE_METAL:\n    lib.ggml_metal_set_tensor.argtypes = [\n        ggml_metal_context_p,\n        ctypes.POINTER(ggml_tensor),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_get_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_get_tensor(\n    ctx: ggml_metal_context_p,\n    t: ggml_tensor_p,\n):\n    return lib.ggml_metal_get_tensor(ctx, t)\nif GGML_USE_METAL:\n    lib.ggml_metal_get_tensor.argtypes = [\n        ggml_metal_context_p,\n        ctypes.POINTER(ggml_tensor),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_graph_find_concurrency",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_graph_find_concurrency(\n    ctx: ggml_metal_context_p,\n    gf: ggml_cgraph_p,\n    check_mem: Union[ctypes.c_bool, bool],\n):\n    return lib.ggml_metal_graph_find_concurrency(ctx, gf, check_mem)\nif GGML_USE_METAL:\n    lib.ggml_metal_graph_find_concurrency.argtypes = [\n        ggml_metal_context_p,\n        ctypes.POINTER(ggml_cgraph),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_if_optimized",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_if_optimized(\n    ctx: ggml_metal_context_p,\n) -> int:\n    return lib.ggml_metal_if_optimized(ctx)\nif GGML_USE_METAL:\n    lib.ggml_metal_if_optimized.argtypes = [\n        ggml_metal_context_p,\n    ]\n    lib.ggml_metal_if_optimized.restype = ctypes.c_int\n# // output the concur_list for ggml_alloc",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_get_concur_list",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_get_concur_list(\n    ctx: ggml_metal_context_p,\n) -> CIntPointer:\n    return lib.ggml_metal_get_concur_list(ctx)\nif GGML_USE_METAL:\n    lib.ggml_metal_get_concur_list.argtypes = [\n        ggml_metal_context_p,\n    ]\n    lib.ggml_metal_get_concur_list.restype = ctypes.POINTER(ctypes.c_int)\n# // same as ggml_graph_compute but uses Metal",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_graph_compute",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_metal_graph_compute(\n    ctx: ggml_metal_context_p,\n    gf: ggml_cgraph_p,\n):\n    return lib.ggml_metal_graph_compute(ctx, gf)\nif GGML_USE_METAL:\n    lib.ggml_metal_graph_compute.argtypes = [\n        ggml_metal_context_p,\n        ctypes.POINTER(ggml_cgraph),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_metal_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_metal_init() -> ggml_backend_t:\n    return lib.ggml_backend_metal_init()\nif GGML_USE_METAL:\n    lib.ggml_backend_metal_init.argtypes = []\n    lib.ggml_backend_metal_init.restype = ggml_backend_t\n# GGML_API bool ggml_backend_is_metal(ggml_backend_t backend);\ndef ggml_backend_is_metal(\n    backend: ggml_backend_t,\n) -> bool:\n    return lib.ggml_backend_is_metal(backend)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_is_metal",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_is_metal(\n    backend: ggml_backend_t,\n) -> bool:\n    return lib.ggml_backend_is_metal(backend)\nif GGML_USE_METAL:\n    lib.ggml_backend_is_metal.argtypes = [ggml_backend_t]\n    lib.ggml_backend_is_metal.restype = ctypes.c_bool\n# GGML_API void ggml_backend_metal_set_n_cb(ggml_backend_t backend, int n_cb);\ndef ggml_backend_metal_set_n_cb(\n    backend: ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_metal_set_n_cb",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_metal_set_n_cb(\n    backend: ggml_backend_t,\n    n_cb: Union[ctypes.c_int, int],\n):\n    return lib.ggml_backend_metal_set_n_cb(backend, n_cb)\nif GGML_USE_METAL:\n    lib.ggml_backend_metal_set_n_cb.argtypes = [ggml_backend_t, ctypes.c_int]\n    lib.ggml_backend_metal_set_n_cb.restype = None\n# GGML_API ggml_backend_buffer_type_t ggml_backend_metal_buffer_type(void);\ndef ggml_backend_metal_buffer_type() -> ggml_backend_buffer_type_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_metal_buffer_type",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_metal_buffer_type() -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_metal_buffer_type()\nif GGML_USE_METAL:\n    lib.ggml_backend_metal_buffer_type.argtypes = []\n    lib.ggml_backend_metal_buffer_type.restype = ggml_backend_buffer_type_t\n# // helper to check if the device supports a specific family\n# // ideally, the user code should be doing these checks\n# // ref: https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf\n# GGML_API bool ggml_backend_metal_supports_family(ggml_backend_t backend, int family);\ndef ggml_backend_metal_supports_family(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_metal_supports_family",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_backend_metal_supports_family(\n    backend: ggml_backend_t,\n    family: Union[ctypes.c_int, int],\n) -> bool:\n    return lib.ggml_backend_metal_supports_family(backend, family)\nif GGML_USE_METAL:\n    lib.ggml_backend_metal_supports_family.argtypes = [ggml_backend_t, ctypes.c_int]\n    lib.ggml_backend_metal_supports_family.restype = ctypes.c_bool\n#####################################################\n# GGML OPENCL API",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cl_init",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cl_init():\n    return lib.ggml_cl_init()\nif GGML_USE_CLBLAST:\n    lib.ggml_cl_init.argtypes = []\n    lib.ggml_cl_init.restype = None\n# void   ggml_cl_mul(const struct ggml_tensor * src0, const struct ggml_tensor * src1, struct ggml_tensor * dst);\ndef ggml_cl_mul(\n    src0: ggml_tensor_p,\n    src1: ggml_tensor_p,\n    dst: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cl_mul",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cl_mul(\n    src0: ggml_tensor_p,\n    src1: ggml_tensor_p,\n    dst: ggml_tensor_p,\n):\n    return lib.ggml_cl_mul(src0, src1, dst)\nif GGML_USE_CLBLAST:\n    lib.ggml_cl_mul.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n        ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cl_can_mul_mat",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cl_can_mul_mat(\n    src0: ggml_tensor_p,\n    src1: ggml_tensor_p,\n    dst: ggml_tensor_p,\n) -> bool:\n    return lib.ggml_cl_can_mul_mat(src0, src1, dst)\nif GGML_USE_CLBLAST:\n    lib.ggml_cl_can_mul_mat.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n        ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cl_mul_mat_get_wsize",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cl_mul_mat_get_wsize(\n    src0: ggml_tensor_p,\n    src1: ggml_tensor_p,\n    dst: ggml_tensor_p,\n) -> int:\n    return lib.ggml_cl_mul_mat_get_wsize(src0, src1, dst)\nif GGML_USE_CLBLAST:\n    lib.ggml_cl_mul_mat_get_wsize.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n        ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cl_mul_mat",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cl_mul_mat(\n    src0: ggml_tensor_p,\n    src1: ggml_tensor_p,\n    dst: ggml_tensor_p,\n    wdata: ctypes.c_void_p,\n    wsize: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_cl_mul_mat(src0, src1, dst, wdata, wsize)\nif GGML_USE_CLBLAST:\n    lib.ggml_cl_mul_mat.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cl_free_data",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cl_free_data(\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_cl_free_data(tensor)\nif GGML_USE_CLBLAST:\n    lib.ggml_cl_free_data.argtypes = [\n        ctypes.POINTER(ggml_tensor),\n    ]\n    lib.ggml_cl_free_data.restype = None\n# void ggml_cl_transform_tensor(void * data, struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_cl_transform_tensor",
        "kind": 2,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "def ggml_cl_transform_tensor(\n    data: ctypes.c_void_p,\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_cl_transform_tensor(data, tensor)\nif GGML_USE_CLBLAST:\n    lib.ggml_cl_transform_tensor.argtypes = [\n        ctypes.c_void_p,\n        ctypes.POINTER(ggml_tensor),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "params",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "params = ggml.ggml_init_params(mem_size=16 * 1024 * 1024, mem_buffer=None)\nctx = ggml.ggml_init(params=params)\n# Instantiate tensors\nx = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\na = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\nb = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\n# Use ggml operations to build a computational graph\nx2 = ggml.ggml_mul(ctx, x, x)\nf = ggml.ggml_add(ctx, ggml.ggml_mul(ctx, a, x2), b)\ngf = ggml.ggml_new_graph(ctx)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ctx",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ctx = ggml.ggml_init(params=params)\n# Instantiate tensors\nx = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\na = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\nb = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\n# Use ggml operations to build a computational graph\nx2 = ggml.ggml_mul(ctx, x, x)\nf = ggml.ggml_add(ctx, ggml.ggml_mul(ctx, a, x2), b)\ngf = ggml.ggml_new_graph(ctx)\nggml.ggml_build_forward_expand(gf, f)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "x = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\na = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\nb = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\n# Use ggml operations to build a computational graph\nx2 = ggml.ggml_mul(ctx, x, x)\nf = ggml.ggml_add(ctx, ggml.ggml_mul(ctx, a, x2), b)\ngf = ggml.ggml_new_graph(ctx)\nggml.ggml_build_forward_expand(gf, f)\n# Set the input values\nggml.ggml_set_f32(x, 2.0)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "a = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\nb = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\n# Use ggml operations to build a computational graph\nx2 = ggml.ggml_mul(ctx, x, x)\nf = ggml.ggml_add(ctx, ggml.ggml_mul(ctx, a, x2), b)\ngf = ggml.ggml_new_graph(ctx)\nggml.ggml_build_forward_expand(gf, f)\n# Set the input values\nggml.ggml_set_f32(x, 2.0)\nggml.ggml_set_f32(a, 3.0)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "b = ggml.ggml_new_tensor_1d(ctx, ggml.GGML_TYPE_F32, 1)\n# Use ggml operations to build a computational graph\nx2 = ggml.ggml_mul(ctx, x, x)\nf = ggml.ggml_add(ctx, ggml.ggml_mul(ctx, a, x2), b)\ngf = ggml.ggml_new_graph(ctx)\nggml.ggml_build_forward_expand(gf, f)\n# Set the input values\nggml.ggml_set_f32(x, 2.0)\nggml.ggml_set_f32(a, 3.0)\nggml.ggml_set_f32(b, 4.0)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "x2",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "x2 = ggml.ggml_mul(ctx, x, x)\nf = ggml.ggml_add(ctx, ggml.ggml_mul(ctx, a, x2), b)\ngf = ggml.ggml_new_graph(ctx)\nggml.ggml_build_forward_expand(gf, f)\n# Set the input values\nggml.ggml_set_f32(x, 2.0)\nggml.ggml_set_f32(a, 3.0)\nggml.ggml_set_f32(b, 4.0)\n# Compute the graph\nggml.ggml_graph_compute_with_ctx(ctx, gf, 1)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "f = ggml.ggml_add(ctx, ggml.ggml_mul(ctx, a, x2), b)\ngf = ggml.ggml_new_graph(ctx)\nggml.ggml_build_forward_expand(gf, f)\n# Set the input values\nggml.ggml_set_f32(x, 2.0)\nggml.ggml_set_f32(a, 3.0)\nggml.ggml_set_f32(b, 4.0)\n# Compute the graph\nggml.ggml_graph_compute_with_ctx(ctx, gf, 1)\n# Get the output value",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "gf",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "gf = ggml.ggml_new_graph(ctx)\nggml.ggml_build_forward_expand(gf, f)\n# Set the input values\nggml.ggml_set_f32(x, 2.0)\nggml.ggml_set_f32(a, 3.0)\nggml.ggml_set_f32(b, 4.0)\n# Compute the graph\nggml.ggml_graph_compute_with_ctx(ctx, gf, 1)\n# Get the output value\noutput = ggml.ggml_get_f32_1d(f, 0)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "output = ggml.ggml_get_f32_1d(f, 0)\nassert output == 16.0\n# Free the context\nggml.ggml_free(ctx)\n```\n\"\"\"\nimport os\nimport sys\nimport ctypes\nimport pathlib",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "base_path",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "base_path = pathlib.Path(__file__).parent.resolve() / \"build/examples/unity\"\nlib_base_name = \"fairseq2_cpp\"\nlib = load_shared_library(base_path, lib_base_name)\n#####################################################\n# GGML Utility Types\n#####################################################\nCFloatArray: TypeAlias = \"ctypes.Array[ctypes.c_float]\"\nCInt64Array: TypeAlias = \"ctypes.Array[ctypes.c_int64]\"\nCIntPointer: TypeAlias = \"ctypes._Pointer[ctypes.c_int]\"  # type: ignore\nCCharPointer: TypeAlias = \"ctypes._Pointer[ctypes.c_char]\"  # type: ignore",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib_base_name",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib_base_name = \"fairseq2_cpp\"\nlib = load_shared_library(base_path, lib_base_name)\n#####################################################\n# GGML Utility Types\n#####################################################\nCFloatArray: TypeAlias = \"ctypes.Array[ctypes.c_float]\"\nCInt64Array: TypeAlias = \"ctypes.Array[ctypes.c_int64]\"\nCIntPointer: TypeAlias = \"ctypes._Pointer[ctypes.c_int]\"  # type: ignore\nCCharPointer: TypeAlias = \"ctypes._Pointer[ctypes.c_char]\"  # type: ignore\n#####################################################",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib = load_shared_library(base_path, lib_base_name)\n#####################################################\n# GGML Utility Types\n#####################################################\nCFloatArray: TypeAlias = \"ctypes.Array[ctypes.c_float]\"\nCInt64Array: TypeAlias = \"ctypes.Array[ctypes.c_int64]\"\nCIntPointer: TypeAlias = \"ctypes._Pointer[ctypes.c_int]\"  # type: ignore\nCCharPointer: TypeAlias = \"ctypes._Pointer[ctypes.c_char]\"  # type: ignore\n#####################################################\n# GGML API",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FILE_MAGIC",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FILE_MAGIC = 0x67676D6C\nGGML_FILE_VERSION = 1\n# define GGML_QNT_VERSION        2    // bump this on quantization format changes\n# define GGML_QNT_VERSION_FACTOR 1000 // do not change this\nGGML_QNT_VERSION = 2\nGGML_QNT_VERSION_FACTOR = 1000\n# define GGML_MAX_DIMS           4\n# define GGML_MAX_PARAMS         2048\n# define GGML_MAX_CONTEXTS       64\n# define GGML_MAX_SRC            10",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FILE_VERSION",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FILE_VERSION = 1\n# define GGML_QNT_VERSION        2    // bump this on quantization format changes\n# define GGML_QNT_VERSION_FACTOR 1000 // do not change this\nGGML_QNT_VERSION = 2\nGGML_QNT_VERSION_FACTOR = 1000\n# define GGML_MAX_DIMS           4\n# define GGML_MAX_PARAMS         2048\n# define GGML_MAX_CONTEXTS       64\n# define GGML_MAX_SRC            10\n# define GGML_MAX_NAME           64",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_QNT_VERSION",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_QNT_VERSION = 2\nGGML_QNT_VERSION_FACTOR = 1000\n# define GGML_MAX_DIMS           4\n# define GGML_MAX_PARAMS         2048\n# define GGML_MAX_CONTEXTS       64\n# define GGML_MAX_SRC            10\n# define GGML_MAX_NAME           64\n# define GGML_MAX_OP_PARAMS      64\n# define GGML_DEFAULT_N_THREADS  4\n# define GGML_DEFAULT_GRAPH_SIZE 2048",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_QNT_VERSION_FACTOR",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_QNT_VERSION_FACTOR = 1000\n# define GGML_MAX_DIMS           4\n# define GGML_MAX_PARAMS         2048\n# define GGML_MAX_CONTEXTS       64\n# define GGML_MAX_SRC            10\n# define GGML_MAX_NAME           64\n# define GGML_MAX_OP_PARAMS      64\n# define GGML_DEFAULT_N_THREADS  4\n# define GGML_DEFAULT_GRAPH_SIZE 2048\nGGML_MAX_DIMS = 4",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_MAX_DIMS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_MAX_DIMS = 4\nGGML_MAX_PARAMS = 2048\nGGML_MAX_CONTEXTS = 64\nGGML_MAX_SRC = 10\nGGML_MAX_NAME = 64\nGGML_MAX_OP_PARAMS = 64\nGGML_DEFAULT_N_THREADS = 4\nGGML_DEFAULT_GRAPH_SIZE = 2048\n# #if UINTPTR_MAX == 0XFFFFFFFF\n#     #define GGML_MEMALIGN 4",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_MAX_PARAMS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_MAX_PARAMS = 2048\nGGML_MAX_CONTEXTS = 64\nGGML_MAX_SRC = 10\nGGML_MAX_NAME = 64\nGGML_MAX_OP_PARAMS = 64\nGGML_DEFAULT_N_THREADS = 4\nGGML_DEFAULT_GRAPH_SIZE = 2048\n# #if UINTPTR_MAX == 0XFFFFFFFF\n#     #define GGML_MEMALIGN 4\n# #else",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_MAX_CONTEXTS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_MAX_CONTEXTS = 64\nGGML_MAX_SRC = 10\nGGML_MAX_NAME = 64\nGGML_MAX_OP_PARAMS = 64\nGGML_DEFAULT_N_THREADS = 4\nGGML_DEFAULT_GRAPH_SIZE = 2048\n# #if UINTPTR_MAX == 0XFFFFFFFF\n#     #define GGML_MEMALIGN 4\n# #else\n#     # define GGML_MEMALIGN 16",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_MAX_SRC",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_MAX_SRC = 10\nGGML_MAX_NAME = 64\nGGML_MAX_OP_PARAMS = 64\nGGML_DEFAULT_N_THREADS = 4\nGGML_DEFAULT_GRAPH_SIZE = 2048\n# #if UINTPTR_MAX == 0XFFFFFFFF\n#     #define GGML_MEMALIGN 4\n# #else\n#     # define GGML_MEMALIGN 16\n# #endif",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_MAX_NAME",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_MAX_NAME = 64\nGGML_MAX_OP_PARAMS = 64\nGGML_DEFAULT_N_THREADS = 4\nGGML_DEFAULT_GRAPH_SIZE = 2048\n# #if UINTPTR_MAX == 0XFFFFFFFF\n#     #define GGML_MEMALIGN 4\n# #else\n#     # define GGML_MEMALIGN 16\n# #endif\nGGML_MEMALIGN = (",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_MAX_OP_PARAMS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_MAX_OP_PARAMS = 64\nGGML_DEFAULT_N_THREADS = 4\nGGML_DEFAULT_GRAPH_SIZE = 2048\n# #if UINTPTR_MAX == 0XFFFFFFFF\n#     #define GGML_MEMALIGN 4\n# #else\n#     # define GGML_MEMALIGN 16\n# #endif\nGGML_MEMALIGN = (\n    16 if ctypes.sizeof(ctypes.c_void_p) == 4 else 32",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_DEFAULT_N_THREADS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_DEFAULT_N_THREADS = 4\nGGML_DEFAULT_GRAPH_SIZE = 2048\n# #if UINTPTR_MAX == 0XFFFFFFFF\n#     #define GGML_MEMALIGN 4\n# #else\n#     # define GGML_MEMALIGN 16\n# #endif\nGGML_MEMALIGN = (\n    16 if ctypes.sizeof(ctypes.c_void_p) == 4 else 32\n)  # FIXME: Check if this is correct",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_DEFAULT_GRAPH_SIZE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_DEFAULT_GRAPH_SIZE = 2048\n# #if UINTPTR_MAX == 0XFFFFFFFF\n#     #define GGML_MEMALIGN 4\n# #else\n#     # define GGML_MEMALIGN 16\n# #endif\nGGML_MEMALIGN = (\n    16 if ctypes.sizeof(ctypes.c_void_p) == 4 else 32\n)  # FIXME: Check if this is correct\n# #define GGML_EXIT_SUCCESS 0",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_MEMALIGN",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_MEMALIGN = (\n    16 if ctypes.sizeof(ctypes.c_void_p) == 4 else 32\n)  # FIXME: Check if this is correct\n# #define GGML_EXIT_SUCCESS 0\nGGML_EXIT_SUCCESS = 0\n# #define GGML_EXIT_ABORTED 1\nGGML_EXIT_ABORTED = 1\n# define GGUF_MAGIC \"GGUF\"\nGGUF_MAGIC = \"GGUF\"\n# define GGUF_VERSION 3",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_EXIT_SUCCESS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_EXIT_SUCCESS = 0\n# #define GGML_EXIT_ABORTED 1\nGGML_EXIT_ABORTED = 1\n# define GGUF_MAGIC \"GGUF\"\nGGUF_MAGIC = \"GGUF\"\n# define GGUF_VERSION 3\nGGUF_VERSION = 3\n# #define GGUF_DEFAULT_ALIGNMENT 32\nGGUF_DEFAULT_ALIGNMENT = 32\n# TODO: Check if this is correct",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_EXIT_ABORTED",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_EXIT_ABORTED = 1\n# define GGUF_MAGIC \"GGUF\"\nGGUF_MAGIC = \"GGUF\"\n# define GGUF_VERSION 3\nGGUF_VERSION = 3\n# #define GGUF_DEFAULT_ALIGNMENT 32\nGGUF_DEFAULT_ALIGNMENT = 32\n# TODO: Check if this is correct\n# typedef uint16_t ggml_fp16_t;\nggml_fp16_t = ctypes.c_uint16",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_MAGIC",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_MAGIC = \"GGUF\"\n# define GGUF_VERSION 3\nGGUF_VERSION = 3\n# #define GGUF_DEFAULT_ALIGNMENT 32\nGGUF_DEFAULT_ALIGNMENT = 32\n# TODO: Check if this is correct\n# typedef uint16_t ggml_fp16_t;\nggml_fp16_t = ctypes.c_uint16\nCFP16Array: TypeAlias = \"ctypes.Array[ggml_fp16_t]\"\n# GGML_API float       ggml_fp16_to_fp32(ggml_fp16_t x);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_VERSION",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_VERSION = 3\n# #define GGUF_DEFAULT_ALIGNMENT 32\nGGUF_DEFAULT_ALIGNMENT = 32\n# TODO: Check if this is correct\n# typedef uint16_t ggml_fp16_t;\nggml_fp16_t = ctypes.c_uint16\nCFP16Array: TypeAlias = \"ctypes.Array[ggml_fp16_t]\"\n# GGML_API float       ggml_fp16_to_fp32(ggml_fp16_t x);\ndef ggml_fp16_to_fp32(x: ggml_fp16_t) -> float:\n    return lib.ggml_fp16_to_fp32(x)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_DEFAULT_ALIGNMENT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_DEFAULT_ALIGNMENT = 32\n# TODO: Check if this is correct\n# typedef uint16_t ggml_fp16_t;\nggml_fp16_t = ctypes.c_uint16\nCFP16Array: TypeAlias = \"ctypes.Array[ggml_fp16_t]\"\n# GGML_API float       ggml_fp16_to_fp32(ggml_fp16_t x);\ndef ggml_fp16_to_fp32(x: ggml_fp16_t) -> float:\n    return lib.ggml_fp16_to_fp32(x)\nlib.ggml_fp16_to_fp32.argtypes = [ggml_fp16_t]\nlib.ggml_fp16_to_fp32.restype = ctypes.c_float",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_fp16_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_fp16_t = ctypes.c_uint16\nCFP16Array: TypeAlias = \"ctypes.Array[ggml_fp16_t]\"\n# GGML_API float       ggml_fp16_to_fp32(ggml_fp16_t x);\ndef ggml_fp16_to_fp32(x: ggml_fp16_t) -> float:\n    return lib.ggml_fp16_to_fp32(x)\nlib.ggml_fp16_to_fp32.argtypes = [ggml_fp16_t]\nlib.ggml_fp16_to_fp32.restype = ctypes.c_float\n# GGML_API ggml_fp16_t ggml_fp32_to_fp16(float x);\ndef ggml_fp32_to_fp16(x: ctypes.c_float) -> int:\n    return lib.ggml_fp32_to_fp16(x)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_fp16_to_fp32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_fp16_to_fp32.argtypes = [ggml_fp16_t]\nlib.ggml_fp16_to_fp32.restype = ctypes.c_float\n# GGML_API ggml_fp16_t ggml_fp32_to_fp16(float x);\ndef ggml_fp32_to_fp16(x: ctypes.c_float) -> int:\n    return lib.ggml_fp32_to_fp16(x)\nlib.ggml_fp32_to_fp16.argtypes = [ctypes.c_float]\nlib.ggml_fp32_to_fp16.restype = ggml_fp16_t\n# GGML_API void ggml_fp16_to_fp32_row(const ggml_fp16_t * x, float * y, size_t n);\ndef ggml_fp16_to_fp32_row(\n    x: CFP16Array,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_fp16_to_fp32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_fp16_to_fp32.restype = ctypes.c_float\n# GGML_API ggml_fp16_t ggml_fp32_to_fp16(float x);\ndef ggml_fp32_to_fp16(x: ctypes.c_float) -> int:\n    return lib.ggml_fp32_to_fp16(x)\nlib.ggml_fp32_to_fp16.argtypes = [ctypes.c_float]\nlib.ggml_fp32_to_fp16.restype = ggml_fp16_t\n# GGML_API void ggml_fp16_to_fp32_row(const ggml_fp16_t * x, float * y, size_t n);\ndef ggml_fp16_to_fp32_row(\n    x: CFP16Array,\n    y: CFloatArray,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_fp32_to_fp16.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_fp32_to_fp16.argtypes = [ctypes.c_float]\nlib.ggml_fp32_to_fp16.restype = ggml_fp16_t\n# GGML_API void ggml_fp16_to_fp32_row(const ggml_fp16_t * x, float * y, size_t n);\ndef ggml_fp16_to_fp32_row(\n    x: CFP16Array,\n    y: CFloatArray,\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_fp16_to_fp32_row(x, y, n)\nlib.ggml_fp16_to_fp32_row.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_fp32_to_fp16.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_fp32_to_fp16.restype = ggml_fp16_t\n# GGML_API void ggml_fp16_to_fp32_row(const ggml_fp16_t * x, float * y, size_t n);\ndef ggml_fp16_to_fp32_row(\n    x: CFP16Array,\n    y: CFloatArray,\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_fp16_to_fp32_row(x, y, n)\nlib.ggml_fp16_to_fp32_row.argtypes = [\n    ctypes.POINTER(ggml_fp16_t),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_fp16_to_fp32_row.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_fp16_to_fp32_row.argtypes = [\n    ctypes.POINTER(ggml_fp16_t),\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_int,\n]\nlib.ggml_fp16_to_fp32_row.restype = None\n# GGML_API void ggml_fp32_to_fp16_row(const float * x, ggml_fp16_t * y, size_t n);\ndef ggml_fp32_to_fp16_row(\n    x: CFloatArray,\n    y: CFP16Array,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_fp16_to_fp32_row.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_fp16_to_fp32_row.restype = None\n# GGML_API void ggml_fp32_to_fp16_row(const float * x, ggml_fp16_t * y, size_t n);\ndef ggml_fp32_to_fp16_row(\n    x: CFloatArray,\n    y: CFP16Array,\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_fp32_to_fp16_row(x, y, n)\nlib.ggml_fp32_to_fp16_row.argtypes = [\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_fp32_to_fp16_row.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_fp32_to_fp16_row.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ggml_fp16_t),\n    ctypes.c_int,\n]\nlib.ggml_fp32_to_fp16_row.restype = None\n# struct ggml_context;\nggml_context_p = ctypes.c_void_p\n\"\"\"Opaque pointer to a ggml_context.\nggml_context structs are not accessed directly instead they must be created using [ggml_init](ggml.ggml_init) and freed using [ggml_free](ggml.ggml_free).\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_fp32_to_fp16_row.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_fp32_to_fp16_row.restype = None\n# struct ggml_context;\nggml_context_p = ctypes.c_void_p\n\"\"\"Opaque pointer to a ggml_context.\nggml_context structs are not accessed directly instead they must be created using [ggml_init](ggml.ggml_init) and freed using [ggml_free](ggml.ggml_free).\"\"\"\n# enum ggml_type {\n#     GGML_TYPE_F32  = 0,\n#     GGML_TYPE_F16  = 1,\n#     GGML_TYPE_Q4_0 = 2,\n#     GGML_TYPE_Q4_1 = 3,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_context_p",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_context_p = ctypes.c_void_p\n\"\"\"Opaque pointer to a ggml_context.\nggml_context structs are not accessed directly instead they must be created using [ggml_init](ggml.ggml_init) and freed using [ggml_free](ggml.ggml_free).\"\"\"\n# enum ggml_type {\n#     GGML_TYPE_F32  = 0,\n#     GGML_TYPE_F16  = 1,\n#     GGML_TYPE_Q4_0 = 2,\n#     GGML_TYPE_Q4_1 = 3,\n#     // GGML_TYPE_Q4_2 = 4, support has been removed\n#     // GGML_TYPE_Q4_3 (5) support has been removed",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_F32",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_F32 = 0\nGGML_TYPE_F16 = 1\nGGML_TYPE_Q4_0 = 2\nGGML_TYPE_Q4_1 = 3\nGGML_TYPE_Q5_0 = 6\nGGML_TYPE_Q5_1 = 7\nGGML_TYPE_Q8_0 = 8\nGGML_TYPE_Q8_1 = 9\nGGML_TYPE_Q2_K = 10\nGGML_TYPE_Q3_K = 11",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_F16",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_F16 = 1\nGGML_TYPE_Q4_0 = 2\nGGML_TYPE_Q4_1 = 3\nGGML_TYPE_Q5_0 = 6\nGGML_TYPE_Q5_1 = 7\nGGML_TYPE_Q8_0 = 8\nGGML_TYPE_Q8_1 = 9\nGGML_TYPE_Q2_K = 10\nGGML_TYPE_Q3_K = 11\nGGML_TYPE_Q4_K = 12",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q4_0",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q4_0 = 2\nGGML_TYPE_Q4_1 = 3\nGGML_TYPE_Q5_0 = 6\nGGML_TYPE_Q5_1 = 7\nGGML_TYPE_Q8_0 = 8\nGGML_TYPE_Q8_1 = 9\nGGML_TYPE_Q2_K = 10\nGGML_TYPE_Q3_K = 11\nGGML_TYPE_Q4_K = 12\nGGML_TYPE_Q5_K = 13",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q4_1",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q4_1 = 3\nGGML_TYPE_Q5_0 = 6\nGGML_TYPE_Q5_1 = 7\nGGML_TYPE_Q8_0 = 8\nGGML_TYPE_Q8_1 = 9\nGGML_TYPE_Q2_K = 10\nGGML_TYPE_Q3_K = 11\nGGML_TYPE_Q4_K = 12\nGGML_TYPE_Q5_K = 13\nGGML_TYPE_Q6_K = 14",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q5_0",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q5_0 = 6\nGGML_TYPE_Q5_1 = 7\nGGML_TYPE_Q8_0 = 8\nGGML_TYPE_Q8_1 = 9\nGGML_TYPE_Q2_K = 10\nGGML_TYPE_Q3_K = 11\nGGML_TYPE_Q4_K = 12\nGGML_TYPE_Q5_K = 13\nGGML_TYPE_Q6_K = 14\nGGML_TYPE_Q8_K = 15",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q5_1",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q5_1 = 7\nGGML_TYPE_Q8_0 = 8\nGGML_TYPE_Q8_1 = 9\nGGML_TYPE_Q2_K = 10\nGGML_TYPE_Q3_K = 11\nGGML_TYPE_Q4_K = 12\nGGML_TYPE_Q5_K = 13\nGGML_TYPE_Q6_K = 14\nGGML_TYPE_Q8_K = 15\nGGML_TYPE_I8 = 16",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q8_0",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q8_0 = 8\nGGML_TYPE_Q8_1 = 9\nGGML_TYPE_Q2_K = 10\nGGML_TYPE_Q3_K = 11\nGGML_TYPE_Q4_K = 12\nGGML_TYPE_Q5_K = 13\nGGML_TYPE_Q6_K = 14\nGGML_TYPE_Q8_K = 15\nGGML_TYPE_I8 = 16\nGGML_TYPE_I16 = 17",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q8_1",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q8_1 = 9\nGGML_TYPE_Q2_K = 10\nGGML_TYPE_Q3_K = 11\nGGML_TYPE_Q4_K = 12\nGGML_TYPE_Q5_K = 13\nGGML_TYPE_Q6_K = 14\nGGML_TYPE_Q8_K = 15\nGGML_TYPE_I8 = 16\nGGML_TYPE_I16 = 17\nGGML_TYPE_I32 = 18",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q2_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q2_K = 10\nGGML_TYPE_Q3_K = 11\nGGML_TYPE_Q4_K = 12\nGGML_TYPE_Q5_K = 13\nGGML_TYPE_Q6_K = 14\nGGML_TYPE_Q8_K = 15\nGGML_TYPE_I8 = 16\nGGML_TYPE_I16 = 17\nGGML_TYPE_I32 = 18\nGGML_TYPE_COUNT = 19",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q3_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q3_K = 11\nGGML_TYPE_Q4_K = 12\nGGML_TYPE_Q5_K = 13\nGGML_TYPE_Q6_K = 14\nGGML_TYPE_Q8_K = 15\nGGML_TYPE_I8 = 16\nGGML_TYPE_I16 = 17\nGGML_TYPE_I32 = 18\nGGML_TYPE_COUNT = 19\n# enum ggml_backend_type {",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q4_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q4_K = 12\nGGML_TYPE_Q5_K = 13\nGGML_TYPE_Q6_K = 14\nGGML_TYPE_Q8_K = 15\nGGML_TYPE_I8 = 16\nGGML_TYPE_I16 = 17\nGGML_TYPE_I32 = 18\nGGML_TYPE_COUNT = 19\n# enum ggml_backend_type {\n#     GGML_BACKEND_CPU = 0,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q5_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q5_K = 13\nGGML_TYPE_Q6_K = 14\nGGML_TYPE_Q8_K = 15\nGGML_TYPE_I8 = 16\nGGML_TYPE_I16 = 17\nGGML_TYPE_I32 = 18\nGGML_TYPE_COUNT = 19\n# enum ggml_backend_type {\n#     GGML_BACKEND_CPU = 0,\n#     GGML_BACKEND_GPU = 10,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q6_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q6_K = 14\nGGML_TYPE_Q8_K = 15\nGGML_TYPE_I8 = 16\nGGML_TYPE_I16 = 17\nGGML_TYPE_I32 = 18\nGGML_TYPE_COUNT = 19\n# enum ggml_backend_type {\n#     GGML_BACKEND_CPU = 0,\n#     GGML_BACKEND_GPU = 10,\n#     GGML_BACKEND_GPU_SPLIT = 20,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_Q8_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_Q8_K = 15\nGGML_TYPE_I8 = 16\nGGML_TYPE_I16 = 17\nGGML_TYPE_I32 = 18\nGGML_TYPE_COUNT = 19\n# enum ggml_backend_type {\n#     GGML_BACKEND_CPU = 0,\n#     GGML_BACKEND_GPU = 10,\n#     GGML_BACKEND_GPU_SPLIT = 20,\n# };",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_I8",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_I8 = 16\nGGML_TYPE_I16 = 17\nGGML_TYPE_I32 = 18\nGGML_TYPE_COUNT = 19\n# enum ggml_backend_type {\n#     GGML_BACKEND_CPU = 0,\n#     GGML_BACKEND_GPU = 10,\n#     GGML_BACKEND_GPU_SPLIT = 20,\n# };\nGGML_BACKEND_CPU = 0",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_I16",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_I16 = 17\nGGML_TYPE_I32 = 18\nGGML_TYPE_COUNT = 19\n# enum ggml_backend_type {\n#     GGML_BACKEND_CPU = 0,\n#     GGML_BACKEND_GPU = 10,\n#     GGML_BACKEND_GPU_SPLIT = 20,\n# };\nGGML_BACKEND_CPU = 0\nGGML_BACKEND_GPU = 10",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_I32",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_I32 = 18\nGGML_TYPE_COUNT = 19\n# enum ggml_backend_type {\n#     GGML_BACKEND_CPU = 0,\n#     GGML_BACKEND_GPU = 10,\n#     GGML_BACKEND_GPU_SPLIT = 20,\n# };\nGGML_BACKEND_CPU = 0\nGGML_BACKEND_GPU = 10\nGGML_BACKEND_GPU_SPLIT = 20",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TYPE_COUNT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TYPE_COUNT = 19\n# enum ggml_backend_type {\n#     GGML_BACKEND_CPU = 0,\n#     GGML_BACKEND_GPU = 10,\n#     GGML_BACKEND_GPU_SPLIT = 20,\n# };\nGGML_BACKEND_CPU = 0\nGGML_BACKEND_GPU = 10\nGGML_BACKEND_GPU_SPLIT = 20\n# // model file types",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_BACKEND_CPU",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_BACKEND_CPU = 0\nGGML_BACKEND_GPU = 10\nGGML_BACKEND_GPU_SPLIT = 20\n# // model file types\n# enum ggml_ftype {\n#     GGML_FTYPE_UNKNOWN     = -1,\n#     GGML_FTYPE_ALL_F32     = 0,\n#     GGML_FTYPE_MOSTLY_F16  = 1,  // except 1d tensors\n#     GGML_FTYPE_MOSTLY_Q4_0 = 2,  // except 1d tensors\n#     GGML_FTYPE_MOSTLY_Q4_1 = 3,  // except 1d tensors",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_BACKEND_GPU",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_BACKEND_GPU = 10\nGGML_BACKEND_GPU_SPLIT = 20\n# // model file types\n# enum ggml_ftype {\n#     GGML_FTYPE_UNKNOWN     = -1,\n#     GGML_FTYPE_ALL_F32     = 0,\n#     GGML_FTYPE_MOSTLY_F16  = 1,  // except 1d tensors\n#     GGML_FTYPE_MOSTLY_Q4_0 = 2,  // except 1d tensors\n#     GGML_FTYPE_MOSTLY_Q4_1 = 3,  // except 1d tensors\n#     GGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4, // tok_embeddings.weight and output.weight are F16",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_BACKEND_GPU_SPLIT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_BACKEND_GPU_SPLIT = 20\n# // model file types\n# enum ggml_ftype {\n#     GGML_FTYPE_UNKNOWN     = -1,\n#     GGML_FTYPE_ALL_F32     = 0,\n#     GGML_FTYPE_MOSTLY_F16  = 1,  // except 1d tensors\n#     GGML_FTYPE_MOSTLY_Q4_0 = 2,  // except 1d tensors\n#     GGML_FTYPE_MOSTLY_Q4_1 = 3,  // except 1d tensors\n#     GGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4, // tok_embeddings.weight and output.weight are F16\n#     GGML_FTYPE_MOSTLY_Q8_0 = 7,  // except 1d tensors",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_UNKNOWN",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_UNKNOWN = -1\nGGML_FTYPE_ALL_F32 = 0\nGGML_FTYPE_MOSTLY_F16 = 1\nGGML_FTYPE_MOSTLY_Q4_0 = 2\nGGML_FTYPE_MOSTLY_Q4_1 = 3\nGGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4\nGGML_FTYPE_MOSTLY_Q8_0 = 7\nGGML_FTYPE_MOSTLY_Q5_0 = 8\nGGML_FTYPE_MOSTLY_Q5_1 = 9\nGGML_FTYPE_MOSTLY_Q2_K = 10",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_ALL_F32",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_ALL_F32 = 0\nGGML_FTYPE_MOSTLY_F16 = 1\nGGML_FTYPE_MOSTLY_Q4_0 = 2\nGGML_FTYPE_MOSTLY_Q4_1 = 3\nGGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4\nGGML_FTYPE_MOSTLY_Q8_0 = 7\nGGML_FTYPE_MOSTLY_Q5_0 = 8\nGGML_FTYPE_MOSTLY_Q5_1 = 9\nGGML_FTYPE_MOSTLY_Q2_K = 10\nGGML_FTYPE_MOSTLY_Q3_K = 11",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_F16",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_F16 = 1\nGGML_FTYPE_MOSTLY_Q4_0 = 2\nGGML_FTYPE_MOSTLY_Q4_1 = 3\nGGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4\nGGML_FTYPE_MOSTLY_Q8_0 = 7\nGGML_FTYPE_MOSTLY_Q5_0 = 8\nGGML_FTYPE_MOSTLY_Q5_1 = 9\nGGML_FTYPE_MOSTLY_Q2_K = 10\nGGML_FTYPE_MOSTLY_Q3_K = 11\nGGML_FTYPE_MOSTLY_Q4_K = 12",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q4_0",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q4_0 = 2\nGGML_FTYPE_MOSTLY_Q4_1 = 3\nGGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4\nGGML_FTYPE_MOSTLY_Q8_0 = 7\nGGML_FTYPE_MOSTLY_Q5_0 = 8\nGGML_FTYPE_MOSTLY_Q5_1 = 9\nGGML_FTYPE_MOSTLY_Q2_K = 10\nGGML_FTYPE_MOSTLY_Q3_K = 11\nGGML_FTYPE_MOSTLY_Q4_K = 12\nGGML_FTYPE_MOSTLY_Q5_K = 13",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q4_1",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q4_1 = 3\nGGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4\nGGML_FTYPE_MOSTLY_Q8_0 = 7\nGGML_FTYPE_MOSTLY_Q5_0 = 8\nGGML_FTYPE_MOSTLY_Q5_1 = 9\nGGML_FTYPE_MOSTLY_Q2_K = 10\nGGML_FTYPE_MOSTLY_Q3_K = 11\nGGML_FTYPE_MOSTLY_Q4_K = 12\nGGML_FTYPE_MOSTLY_Q5_K = 13\nGGML_FTYPE_MOSTLY_Q6_K = 14",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q4_1_SOME_F16",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4\nGGML_FTYPE_MOSTLY_Q8_0 = 7\nGGML_FTYPE_MOSTLY_Q5_0 = 8\nGGML_FTYPE_MOSTLY_Q5_1 = 9\nGGML_FTYPE_MOSTLY_Q2_K = 10\nGGML_FTYPE_MOSTLY_Q3_K = 11\nGGML_FTYPE_MOSTLY_Q4_K = 12\nGGML_FTYPE_MOSTLY_Q5_K = 13\nGGML_FTYPE_MOSTLY_Q6_K = 14\n# // available tensor operations:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q8_0",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q8_0 = 7\nGGML_FTYPE_MOSTLY_Q5_0 = 8\nGGML_FTYPE_MOSTLY_Q5_1 = 9\nGGML_FTYPE_MOSTLY_Q2_K = 10\nGGML_FTYPE_MOSTLY_Q3_K = 11\nGGML_FTYPE_MOSTLY_Q4_K = 12\nGGML_FTYPE_MOSTLY_Q5_K = 13\nGGML_FTYPE_MOSTLY_Q6_K = 14\n# // available tensor operations:\n# enum ggml_op {",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q5_0",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q5_0 = 8\nGGML_FTYPE_MOSTLY_Q5_1 = 9\nGGML_FTYPE_MOSTLY_Q2_K = 10\nGGML_FTYPE_MOSTLY_Q3_K = 11\nGGML_FTYPE_MOSTLY_Q4_K = 12\nGGML_FTYPE_MOSTLY_Q5_K = 13\nGGML_FTYPE_MOSTLY_Q6_K = 14\n# // available tensor operations:\n# enum ggml_op {\n#     GGML_OP_NONE = 0,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q5_1",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q5_1 = 9\nGGML_FTYPE_MOSTLY_Q2_K = 10\nGGML_FTYPE_MOSTLY_Q3_K = 11\nGGML_FTYPE_MOSTLY_Q4_K = 12\nGGML_FTYPE_MOSTLY_Q5_K = 13\nGGML_FTYPE_MOSTLY_Q6_K = 14\n# // available tensor operations:\n# enum ggml_op {\n#     GGML_OP_NONE = 0,\n#     GGML_OP_DUP,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q2_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q2_K = 10\nGGML_FTYPE_MOSTLY_Q3_K = 11\nGGML_FTYPE_MOSTLY_Q4_K = 12\nGGML_FTYPE_MOSTLY_Q5_K = 13\nGGML_FTYPE_MOSTLY_Q6_K = 14\n# // available tensor operations:\n# enum ggml_op {\n#     GGML_OP_NONE = 0,\n#     GGML_OP_DUP,\n#     GGML_OP_ADD,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q3_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q3_K = 11\nGGML_FTYPE_MOSTLY_Q4_K = 12\nGGML_FTYPE_MOSTLY_Q5_K = 13\nGGML_FTYPE_MOSTLY_Q6_K = 14\n# // available tensor operations:\n# enum ggml_op {\n#     GGML_OP_NONE = 0,\n#     GGML_OP_DUP,\n#     GGML_OP_ADD,\n#     GGML_OP_ADD1,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q4_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q4_K = 12\nGGML_FTYPE_MOSTLY_Q5_K = 13\nGGML_FTYPE_MOSTLY_Q6_K = 14\n# // available tensor operations:\n# enum ggml_op {\n#     GGML_OP_NONE = 0,\n#     GGML_OP_DUP,\n#     GGML_OP_ADD,\n#     GGML_OP_ADD1,\n#     GGML_OP_ACC,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q5_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q5_K = 13\nGGML_FTYPE_MOSTLY_Q6_K = 14\n# // available tensor operations:\n# enum ggml_op {\n#     GGML_OP_NONE = 0,\n#     GGML_OP_DUP,\n#     GGML_OP_ADD,\n#     GGML_OP_ADD1,\n#     GGML_OP_ACC,\n#     GGML_OP_SUB,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_FTYPE_MOSTLY_Q6_K",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_FTYPE_MOSTLY_Q6_K = 14\n# // available tensor operations:\n# enum ggml_op {\n#     GGML_OP_NONE = 0,\n#     GGML_OP_DUP,\n#     GGML_OP_ADD,\n#     GGML_OP_ADD1,\n#     GGML_OP_ACC,\n#     GGML_OP_SUB,\n#     GGML_OP_MUL,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_NONE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_NONE = 0\nGGML_OP_DUP = 1\nGGML_OP_ADD = 2\nGGML_OP_ADD1 = 3\nGGML_OP_ACC = 4\nGGML_OP_SUB = 5\nGGML_OP_MUL = 6\nGGML_OP_DIV = 7\nGGML_OP_SQR = 8\nGGML_OP_SQRT = 9",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_DUP",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_DUP = 1\nGGML_OP_ADD = 2\nGGML_OP_ADD1 = 3\nGGML_OP_ACC = 4\nGGML_OP_SUB = 5\nGGML_OP_MUL = 6\nGGML_OP_DIV = 7\nGGML_OP_SQR = 8\nGGML_OP_SQRT = 9\nGGML_OP_LOG = 10",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_ADD",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_ADD = 2\nGGML_OP_ADD1 = 3\nGGML_OP_ACC = 4\nGGML_OP_SUB = 5\nGGML_OP_MUL = 6\nGGML_OP_DIV = 7\nGGML_OP_SQR = 8\nGGML_OP_SQRT = 9\nGGML_OP_LOG = 10\nGGML_OP_SUM = 11",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_ADD1",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_ADD1 = 3\nGGML_OP_ACC = 4\nGGML_OP_SUB = 5\nGGML_OP_MUL = 6\nGGML_OP_DIV = 7\nGGML_OP_SQR = 8\nGGML_OP_SQRT = 9\nGGML_OP_LOG = 10\nGGML_OP_SUM = 11\nGGML_OP_SUM_ROWS = 12",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_ACC",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_ACC = 4\nGGML_OP_SUB = 5\nGGML_OP_MUL = 6\nGGML_OP_DIV = 7\nGGML_OP_SQR = 8\nGGML_OP_SQRT = 9\nGGML_OP_LOG = 10\nGGML_OP_SUM = 11\nGGML_OP_SUM_ROWS = 12\nGGML_OP_MEAN = 13",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SUB",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SUB = 5\nGGML_OP_MUL = 6\nGGML_OP_DIV = 7\nGGML_OP_SQR = 8\nGGML_OP_SQRT = 9\nGGML_OP_LOG = 10\nGGML_OP_SUM = 11\nGGML_OP_SUM_ROWS = 12\nGGML_OP_MEAN = 13\nGGML_OP_ARGMAX = 14",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MUL",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MUL = 6\nGGML_OP_DIV = 7\nGGML_OP_SQR = 8\nGGML_OP_SQRT = 9\nGGML_OP_LOG = 10\nGGML_OP_SUM = 11\nGGML_OP_SUM_ROWS = 12\nGGML_OP_MEAN = 13\nGGML_OP_ARGMAX = 14\nGGML_OP_REPEAT = 15",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_DIV",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_DIV = 7\nGGML_OP_SQR = 8\nGGML_OP_SQRT = 9\nGGML_OP_LOG = 10\nGGML_OP_SUM = 11\nGGML_OP_SUM_ROWS = 12\nGGML_OP_MEAN = 13\nGGML_OP_ARGMAX = 14\nGGML_OP_REPEAT = 15\nGGML_OP_REPEAT_BACK = 16",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SQR",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SQR = 8\nGGML_OP_SQRT = 9\nGGML_OP_LOG = 10\nGGML_OP_SUM = 11\nGGML_OP_SUM_ROWS = 12\nGGML_OP_MEAN = 13\nGGML_OP_ARGMAX = 14\nGGML_OP_REPEAT = 15\nGGML_OP_REPEAT_BACK = 16\nGGML_OP_CONCAT = 17",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SQRT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SQRT = 9\nGGML_OP_LOG = 10\nGGML_OP_SUM = 11\nGGML_OP_SUM_ROWS = 12\nGGML_OP_MEAN = 13\nGGML_OP_ARGMAX = 14\nGGML_OP_REPEAT = 15\nGGML_OP_REPEAT_BACK = 16\nGGML_OP_CONCAT = 17\nGGML_OP_SILU_BACK = 18",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_LOG",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_LOG = 10\nGGML_OP_SUM = 11\nGGML_OP_SUM_ROWS = 12\nGGML_OP_MEAN = 13\nGGML_OP_ARGMAX = 14\nGGML_OP_REPEAT = 15\nGGML_OP_REPEAT_BACK = 16\nGGML_OP_CONCAT = 17\nGGML_OP_SILU_BACK = 18\nGGML_OP_NORM = 19",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SUM",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SUM = 11\nGGML_OP_SUM_ROWS = 12\nGGML_OP_MEAN = 13\nGGML_OP_ARGMAX = 14\nGGML_OP_REPEAT = 15\nGGML_OP_REPEAT_BACK = 16\nGGML_OP_CONCAT = 17\nGGML_OP_SILU_BACK = 18\nGGML_OP_NORM = 19\nGGML_OP_RMS_NORM = 20",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SUM_ROWS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SUM_ROWS = 12\nGGML_OP_MEAN = 13\nGGML_OP_ARGMAX = 14\nGGML_OP_REPEAT = 15\nGGML_OP_REPEAT_BACK = 16\nGGML_OP_CONCAT = 17\nGGML_OP_SILU_BACK = 18\nGGML_OP_NORM = 19\nGGML_OP_RMS_NORM = 20\nGGML_OP_RMS_NORM_BACK = 21",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MEAN",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MEAN = 13\nGGML_OP_ARGMAX = 14\nGGML_OP_REPEAT = 15\nGGML_OP_REPEAT_BACK = 16\nGGML_OP_CONCAT = 17\nGGML_OP_SILU_BACK = 18\nGGML_OP_NORM = 19\nGGML_OP_RMS_NORM = 20\nGGML_OP_RMS_NORM_BACK = 21\nGGML_OP_GROUP_NORM = 22",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_ARGMAX",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_ARGMAX = 14\nGGML_OP_REPEAT = 15\nGGML_OP_REPEAT_BACK = 16\nGGML_OP_CONCAT = 17\nGGML_OP_SILU_BACK = 18\nGGML_OP_NORM = 19\nGGML_OP_RMS_NORM = 20\nGGML_OP_RMS_NORM_BACK = 21\nGGML_OP_GROUP_NORM = 22\nGGML_OP_MUL_MAT = 23",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_REPEAT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_REPEAT = 15\nGGML_OP_REPEAT_BACK = 16\nGGML_OP_CONCAT = 17\nGGML_OP_SILU_BACK = 18\nGGML_OP_NORM = 19\nGGML_OP_RMS_NORM = 20\nGGML_OP_RMS_NORM_BACK = 21\nGGML_OP_GROUP_NORM = 22\nGGML_OP_MUL_MAT = 23\nGGML_OP_MUL_MAT_ID = 24",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_REPEAT_BACK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_REPEAT_BACK = 16\nGGML_OP_CONCAT = 17\nGGML_OP_SILU_BACK = 18\nGGML_OP_NORM = 19\nGGML_OP_RMS_NORM = 20\nGGML_OP_RMS_NORM_BACK = 21\nGGML_OP_GROUP_NORM = 22\nGGML_OP_MUL_MAT = 23\nGGML_OP_MUL_MAT_ID = 24\nGGML_OP_OUT_PROD = 25",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_CONCAT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_CONCAT = 17\nGGML_OP_SILU_BACK = 18\nGGML_OP_NORM = 19\nGGML_OP_RMS_NORM = 20\nGGML_OP_RMS_NORM_BACK = 21\nGGML_OP_GROUP_NORM = 22\nGGML_OP_MUL_MAT = 23\nGGML_OP_MUL_MAT_ID = 24\nGGML_OP_OUT_PROD = 25\nGGML_OP_SCALE = 26",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SILU_BACK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SILU_BACK = 18\nGGML_OP_NORM = 19\nGGML_OP_RMS_NORM = 20\nGGML_OP_RMS_NORM_BACK = 21\nGGML_OP_GROUP_NORM = 22\nGGML_OP_MUL_MAT = 23\nGGML_OP_MUL_MAT_ID = 24\nGGML_OP_OUT_PROD = 25\nGGML_OP_SCALE = 26\nGGML_OP_SET = 27",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_NORM",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_NORM = 19\nGGML_OP_RMS_NORM = 20\nGGML_OP_RMS_NORM_BACK = 21\nGGML_OP_GROUP_NORM = 22\nGGML_OP_MUL_MAT = 23\nGGML_OP_MUL_MAT_ID = 24\nGGML_OP_OUT_PROD = 25\nGGML_OP_SCALE = 26\nGGML_OP_SET = 27\nGGML_OP_CPY = 28",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_RMS_NORM",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_RMS_NORM = 20\nGGML_OP_RMS_NORM_BACK = 21\nGGML_OP_GROUP_NORM = 22\nGGML_OP_MUL_MAT = 23\nGGML_OP_MUL_MAT_ID = 24\nGGML_OP_OUT_PROD = 25\nGGML_OP_SCALE = 26\nGGML_OP_SET = 27\nGGML_OP_CPY = 28\nGGML_OP_CONT = 29",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_RMS_NORM_BACK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_RMS_NORM_BACK = 21\nGGML_OP_GROUP_NORM = 22\nGGML_OP_MUL_MAT = 23\nGGML_OP_MUL_MAT_ID = 24\nGGML_OP_OUT_PROD = 25\nGGML_OP_SCALE = 26\nGGML_OP_SET = 27\nGGML_OP_CPY = 28\nGGML_OP_CONT = 29\nGGML_OP_RESHAPE = 30",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_GROUP_NORM",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_GROUP_NORM = 22\nGGML_OP_MUL_MAT = 23\nGGML_OP_MUL_MAT_ID = 24\nGGML_OP_OUT_PROD = 25\nGGML_OP_SCALE = 26\nGGML_OP_SET = 27\nGGML_OP_CPY = 28\nGGML_OP_CONT = 29\nGGML_OP_RESHAPE = 30\nGGML_OP_VIEW = 31",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MUL_MAT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MUL_MAT = 23\nGGML_OP_MUL_MAT_ID = 24\nGGML_OP_OUT_PROD = 25\nGGML_OP_SCALE = 26\nGGML_OP_SET = 27\nGGML_OP_CPY = 28\nGGML_OP_CONT = 29\nGGML_OP_RESHAPE = 30\nGGML_OP_VIEW = 31\nGGML_OP_PERMUTE = 32",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MUL_MAT_ID",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MUL_MAT_ID = 24\nGGML_OP_OUT_PROD = 25\nGGML_OP_SCALE = 26\nGGML_OP_SET = 27\nGGML_OP_CPY = 28\nGGML_OP_CONT = 29\nGGML_OP_RESHAPE = 30\nGGML_OP_VIEW = 31\nGGML_OP_PERMUTE = 32\nGGML_OP_TRANSPOSE = 33",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_OUT_PROD",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_OUT_PROD = 25\nGGML_OP_SCALE = 26\nGGML_OP_SET = 27\nGGML_OP_CPY = 28\nGGML_OP_CONT = 29\nGGML_OP_RESHAPE = 30\nGGML_OP_VIEW = 31\nGGML_OP_PERMUTE = 32\nGGML_OP_TRANSPOSE = 33\nGGML_OP_GET_ROWS = 34",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SCALE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SCALE = 26\nGGML_OP_SET = 27\nGGML_OP_CPY = 28\nGGML_OP_CONT = 29\nGGML_OP_RESHAPE = 30\nGGML_OP_VIEW = 31\nGGML_OP_PERMUTE = 32\nGGML_OP_TRANSPOSE = 33\nGGML_OP_GET_ROWS = 34\nGGML_OP_GET_ROWS_BACK = 35",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SET",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SET = 27\nGGML_OP_CPY = 28\nGGML_OP_CONT = 29\nGGML_OP_RESHAPE = 30\nGGML_OP_VIEW = 31\nGGML_OP_PERMUTE = 32\nGGML_OP_TRANSPOSE = 33\nGGML_OP_GET_ROWS = 34\nGGML_OP_GET_ROWS_BACK = 35\nGGML_OP_DIAG = 36",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_CPY",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_CPY = 28\nGGML_OP_CONT = 29\nGGML_OP_RESHAPE = 30\nGGML_OP_VIEW = 31\nGGML_OP_PERMUTE = 32\nGGML_OP_TRANSPOSE = 33\nGGML_OP_GET_ROWS = 34\nGGML_OP_GET_ROWS_BACK = 35\nGGML_OP_DIAG = 36\nGGML_OP_DIAG_MASK_INF = 37",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_CONT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_CONT = 29\nGGML_OP_RESHAPE = 30\nGGML_OP_VIEW = 31\nGGML_OP_PERMUTE = 32\nGGML_OP_TRANSPOSE = 33\nGGML_OP_GET_ROWS = 34\nGGML_OP_GET_ROWS_BACK = 35\nGGML_OP_DIAG = 36\nGGML_OP_DIAG_MASK_INF = 37\nGGML_OP_DIAG_MASK_ZERO = 38",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_RESHAPE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_RESHAPE = 30\nGGML_OP_VIEW = 31\nGGML_OP_PERMUTE = 32\nGGML_OP_TRANSPOSE = 33\nGGML_OP_GET_ROWS = 34\nGGML_OP_GET_ROWS_BACK = 35\nGGML_OP_DIAG = 36\nGGML_OP_DIAG_MASK_INF = 37\nGGML_OP_DIAG_MASK_ZERO = 38\nGGML_OP_SOFT_MAX = 39",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_VIEW",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_VIEW = 31\nGGML_OP_PERMUTE = 32\nGGML_OP_TRANSPOSE = 33\nGGML_OP_GET_ROWS = 34\nGGML_OP_GET_ROWS_BACK = 35\nGGML_OP_DIAG = 36\nGGML_OP_DIAG_MASK_INF = 37\nGGML_OP_DIAG_MASK_ZERO = 38\nGGML_OP_SOFT_MAX = 39\nGGML_OP_SOFT_MAX_BACK = 40",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_PERMUTE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_PERMUTE = 32\nGGML_OP_TRANSPOSE = 33\nGGML_OP_GET_ROWS = 34\nGGML_OP_GET_ROWS_BACK = 35\nGGML_OP_DIAG = 36\nGGML_OP_DIAG_MASK_INF = 37\nGGML_OP_DIAG_MASK_ZERO = 38\nGGML_OP_SOFT_MAX = 39\nGGML_OP_SOFT_MAX_BACK = 40\nGGML_OP_ROPE = 41",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_TRANSPOSE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_TRANSPOSE = 33\nGGML_OP_GET_ROWS = 34\nGGML_OP_GET_ROWS_BACK = 35\nGGML_OP_DIAG = 36\nGGML_OP_DIAG_MASK_INF = 37\nGGML_OP_DIAG_MASK_ZERO = 38\nGGML_OP_SOFT_MAX = 39\nGGML_OP_SOFT_MAX_BACK = 40\nGGML_OP_ROPE = 41\nGGML_OP_ROPE_BACK = 42",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_GET_ROWS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_GET_ROWS = 34\nGGML_OP_GET_ROWS_BACK = 35\nGGML_OP_DIAG = 36\nGGML_OP_DIAG_MASK_INF = 37\nGGML_OP_DIAG_MASK_ZERO = 38\nGGML_OP_SOFT_MAX = 39\nGGML_OP_SOFT_MAX_BACK = 40\nGGML_OP_ROPE = 41\nGGML_OP_ROPE_BACK = 42\nGGML_OP_ALIBI = 43",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_GET_ROWS_BACK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_GET_ROWS_BACK = 35\nGGML_OP_DIAG = 36\nGGML_OP_DIAG_MASK_INF = 37\nGGML_OP_DIAG_MASK_ZERO = 38\nGGML_OP_SOFT_MAX = 39\nGGML_OP_SOFT_MAX_BACK = 40\nGGML_OP_ROPE = 41\nGGML_OP_ROPE_BACK = 42\nGGML_OP_ALIBI = 43\nGGML_OP_CLAMP = 44",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_DIAG",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_DIAG = 36\nGGML_OP_DIAG_MASK_INF = 37\nGGML_OP_DIAG_MASK_ZERO = 38\nGGML_OP_SOFT_MAX = 39\nGGML_OP_SOFT_MAX_BACK = 40\nGGML_OP_ROPE = 41\nGGML_OP_ROPE_BACK = 42\nGGML_OP_ALIBI = 43\nGGML_OP_CLAMP = 44\nGGML_OP_CONV_TRANSPOSE_1D = 45",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_DIAG_MASK_INF",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_DIAG_MASK_INF = 37\nGGML_OP_DIAG_MASK_ZERO = 38\nGGML_OP_SOFT_MAX = 39\nGGML_OP_SOFT_MAX_BACK = 40\nGGML_OP_ROPE = 41\nGGML_OP_ROPE_BACK = 42\nGGML_OP_ALIBI = 43\nGGML_OP_CLAMP = 44\nGGML_OP_CONV_TRANSPOSE_1D = 45\nGGML_OP_IM2COL = 46",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_DIAG_MASK_ZERO",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_DIAG_MASK_ZERO = 38\nGGML_OP_SOFT_MAX = 39\nGGML_OP_SOFT_MAX_BACK = 40\nGGML_OP_ROPE = 41\nGGML_OP_ROPE_BACK = 42\nGGML_OP_ALIBI = 43\nGGML_OP_CLAMP = 44\nGGML_OP_CONV_TRANSPOSE_1D = 45\nGGML_OP_IM2COL = 46\nGGML_OP_CONV_TRANSPOSE_2D = 47",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SOFT_MAX",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SOFT_MAX = 39\nGGML_OP_SOFT_MAX_BACK = 40\nGGML_OP_ROPE = 41\nGGML_OP_ROPE_BACK = 42\nGGML_OP_ALIBI = 43\nGGML_OP_CLAMP = 44\nGGML_OP_CONV_TRANSPOSE_1D = 45\nGGML_OP_IM2COL = 46\nGGML_OP_CONV_TRANSPOSE_2D = 47\nGGML_OP_POOL_1D = 48",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_SOFT_MAX_BACK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_SOFT_MAX_BACK = 40\nGGML_OP_ROPE = 41\nGGML_OP_ROPE_BACK = 42\nGGML_OP_ALIBI = 43\nGGML_OP_CLAMP = 44\nGGML_OP_CONV_TRANSPOSE_1D = 45\nGGML_OP_IM2COL = 46\nGGML_OP_CONV_TRANSPOSE_2D = 47\nGGML_OP_POOL_1D = 48\nGGML_OP_POOL_2D = 49",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_ROPE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_ROPE = 41\nGGML_OP_ROPE_BACK = 42\nGGML_OP_ALIBI = 43\nGGML_OP_CLAMP = 44\nGGML_OP_CONV_TRANSPOSE_1D = 45\nGGML_OP_IM2COL = 46\nGGML_OP_CONV_TRANSPOSE_2D = 47\nGGML_OP_POOL_1D = 48\nGGML_OP_POOL_2D = 49\nGGML_OP_UPSCALE = 50",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_ROPE_BACK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_ROPE_BACK = 42\nGGML_OP_ALIBI = 43\nGGML_OP_CLAMP = 44\nGGML_OP_CONV_TRANSPOSE_1D = 45\nGGML_OP_IM2COL = 46\nGGML_OP_CONV_TRANSPOSE_2D = 47\nGGML_OP_POOL_1D = 48\nGGML_OP_POOL_2D = 49\nGGML_OP_UPSCALE = 50\nGGML_OP_PAD = 51",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_ALIBI",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_ALIBI = 43\nGGML_OP_CLAMP = 44\nGGML_OP_CONV_TRANSPOSE_1D = 45\nGGML_OP_IM2COL = 46\nGGML_OP_CONV_TRANSPOSE_2D = 47\nGGML_OP_POOL_1D = 48\nGGML_OP_POOL_2D = 49\nGGML_OP_UPSCALE = 50\nGGML_OP_PAD = 51\nGGML_OP_ARGSORT = 52",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_CLAMP",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_CLAMP = 44\nGGML_OP_CONV_TRANSPOSE_1D = 45\nGGML_OP_IM2COL = 46\nGGML_OP_CONV_TRANSPOSE_2D = 47\nGGML_OP_POOL_1D = 48\nGGML_OP_POOL_2D = 49\nGGML_OP_UPSCALE = 50\nGGML_OP_PAD = 51\nGGML_OP_ARGSORT = 52\nGGML_OP_LEAKY_RELU = 53",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_CONV_TRANSPOSE_1D",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_CONV_TRANSPOSE_1D = 45\nGGML_OP_IM2COL = 46\nGGML_OP_CONV_TRANSPOSE_2D = 47\nGGML_OP_POOL_1D = 48\nGGML_OP_POOL_2D = 49\nGGML_OP_UPSCALE = 50\nGGML_OP_PAD = 51\nGGML_OP_ARGSORT = 52\nGGML_OP_LEAKY_RELU = 53\nGGML_OP_FLASH_ATTN = 54",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_IM2COL",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_IM2COL = 46\nGGML_OP_CONV_TRANSPOSE_2D = 47\nGGML_OP_POOL_1D = 48\nGGML_OP_POOL_2D = 49\nGGML_OP_UPSCALE = 50\nGGML_OP_PAD = 51\nGGML_OP_ARGSORT = 52\nGGML_OP_LEAKY_RELU = 53\nGGML_OP_FLASH_ATTN = 54\nGGML_OP_FLASH_FF = 55",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_CONV_TRANSPOSE_2D",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_CONV_TRANSPOSE_2D = 47\nGGML_OP_POOL_1D = 48\nGGML_OP_POOL_2D = 49\nGGML_OP_UPSCALE = 50\nGGML_OP_PAD = 51\nGGML_OP_ARGSORT = 52\nGGML_OP_LEAKY_RELU = 53\nGGML_OP_FLASH_ATTN = 54\nGGML_OP_FLASH_FF = 55\nGGML_OP_FLASH_ATTN_BACK = 56",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_POOL_1D",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_POOL_1D = 48\nGGML_OP_POOL_2D = 49\nGGML_OP_UPSCALE = 50\nGGML_OP_PAD = 51\nGGML_OP_ARGSORT = 52\nGGML_OP_LEAKY_RELU = 53\nGGML_OP_FLASH_ATTN = 54\nGGML_OP_FLASH_FF = 55\nGGML_OP_FLASH_ATTN_BACK = 56\nGGML_OP_WIN_PART = 57",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_POOL_2D",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_POOL_2D = 49\nGGML_OP_UPSCALE = 50\nGGML_OP_PAD = 51\nGGML_OP_ARGSORT = 52\nGGML_OP_LEAKY_RELU = 53\nGGML_OP_FLASH_ATTN = 54\nGGML_OP_FLASH_FF = 55\nGGML_OP_FLASH_ATTN_BACK = 56\nGGML_OP_WIN_PART = 57\nGGML_OP_WIN_UNPART = 58",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_UPSCALE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_UPSCALE = 50\nGGML_OP_PAD = 51\nGGML_OP_ARGSORT = 52\nGGML_OP_LEAKY_RELU = 53\nGGML_OP_FLASH_ATTN = 54\nGGML_OP_FLASH_FF = 55\nGGML_OP_FLASH_ATTN_BACK = 56\nGGML_OP_WIN_PART = 57\nGGML_OP_WIN_UNPART = 58\nGGML_OP_GET_REL_POS = 59",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_PAD",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_PAD = 51\nGGML_OP_ARGSORT = 52\nGGML_OP_LEAKY_RELU = 53\nGGML_OP_FLASH_ATTN = 54\nGGML_OP_FLASH_FF = 55\nGGML_OP_FLASH_ATTN_BACK = 56\nGGML_OP_WIN_PART = 57\nGGML_OP_WIN_UNPART = 58\nGGML_OP_GET_REL_POS = 59\nGGML_OP_ADD_REL_POS = 60",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_ARGSORT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_ARGSORT = 52\nGGML_OP_LEAKY_RELU = 53\nGGML_OP_FLASH_ATTN = 54\nGGML_OP_FLASH_FF = 55\nGGML_OP_FLASH_ATTN_BACK = 56\nGGML_OP_WIN_PART = 57\nGGML_OP_WIN_UNPART = 58\nGGML_OP_GET_REL_POS = 59\nGGML_OP_ADD_REL_POS = 60\nGGML_OP_UNARY = 61",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_LEAKY_RELU",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_LEAKY_RELU = 53\nGGML_OP_FLASH_ATTN = 54\nGGML_OP_FLASH_FF = 55\nGGML_OP_FLASH_ATTN_BACK = 56\nGGML_OP_WIN_PART = 57\nGGML_OP_WIN_UNPART = 58\nGGML_OP_GET_REL_POS = 59\nGGML_OP_ADD_REL_POS = 60\nGGML_OP_UNARY = 61\nGGML_OP_MAP_UNARY = 62",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_FLASH_ATTN",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_FLASH_ATTN = 54\nGGML_OP_FLASH_FF = 55\nGGML_OP_FLASH_ATTN_BACK = 56\nGGML_OP_WIN_PART = 57\nGGML_OP_WIN_UNPART = 58\nGGML_OP_GET_REL_POS = 59\nGGML_OP_ADD_REL_POS = 60\nGGML_OP_UNARY = 61\nGGML_OP_MAP_UNARY = 62\nGGML_OP_MAP_BINARY = 63",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_FLASH_FF",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_FLASH_FF = 55\nGGML_OP_FLASH_ATTN_BACK = 56\nGGML_OP_WIN_PART = 57\nGGML_OP_WIN_UNPART = 58\nGGML_OP_GET_REL_POS = 59\nGGML_OP_ADD_REL_POS = 60\nGGML_OP_UNARY = 61\nGGML_OP_MAP_UNARY = 62\nGGML_OP_MAP_BINARY = 63\nGGML_OP_MAP_CUSTOM1_F32 = 64",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_FLASH_ATTN_BACK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_FLASH_ATTN_BACK = 56\nGGML_OP_WIN_PART = 57\nGGML_OP_WIN_UNPART = 58\nGGML_OP_GET_REL_POS = 59\nGGML_OP_ADD_REL_POS = 60\nGGML_OP_UNARY = 61\nGGML_OP_MAP_UNARY = 62\nGGML_OP_MAP_BINARY = 63\nGGML_OP_MAP_CUSTOM1_F32 = 64\nGGML_OP_MAP_CUSTOM2_F32 = 65",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_WIN_PART",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_WIN_PART = 57\nGGML_OP_WIN_UNPART = 58\nGGML_OP_GET_REL_POS = 59\nGGML_OP_ADD_REL_POS = 60\nGGML_OP_UNARY = 61\nGGML_OP_MAP_UNARY = 62\nGGML_OP_MAP_BINARY = 63\nGGML_OP_MAP_CUSTOM1_F32 = 64\nGGML_OP_MAP_CUSTOM2_F32 = 65\nGGML_OP_MAP_CUSTOM3_F32 = 66",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_WIN_UNPART",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_WIN_UNPART = 58\nGGML_OP_GET_REL_POS = 59\nGGML_OP_ADD_REL_POS = 60\nGGML_OP_UNARY = 61\nGGML_OP_MAP_UNARY = 62\nGGML_OP_MAP_BINARY = 63\nGGML_OP_MAP_CUSTOM1_F32 = 64\nGGML_OP_MAP_CUSTOM2_F32 = 65\nGGML_OP_MAP_CUSTOM3_F32 = 66\nGGML_OP_MAP_CUSTOM1 = 67",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_GET_REL_POS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_GET_REL_POS = 59\nGGML_OP_ADD_REL_POS = 60\nGGML_OP_UNARY = 61\nGGML_OP_MAP_UNARY = 62\nGGML_OP_MAP_BINARY = 63\nGGML_OP_MAP_CUSTOM1_F32 = 64\nGGML_OP_MAP_CUSTOM2_F32 = 65\nGGML_OP_MAP_CUSTOM3_F32 = 66\nGGML_OP_MAP_CUSTOM1 = 67\nGGML_OP_MAP_CUSTOM2 = 68",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_ADD_REL_POS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_ADD_REL_POS = 60\nGGML_OP_UNARY = 61\nGGML_OP_MAP_UNARY = 62\nGGML_OP_MAP_BINARY = 63\nGGML_OP_MAP_CUSTOM1_F32 = 64\nGGML_OP_MAP_CUSTOM2_F32 = 65\nGGML_OP_MAP_CUSTOM3_F32 = 66\nGGML_OP_MAP_CUSTOM1 = 67\nGGML_OP_MAP_CUSTOM2 = 68\nGGML_OP_MAP_CUSTOM3 = 69",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_UNARY",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_UNARY = 61\nGGML_OP_MAP_UNARY = 62\nGGML_OP_MAP_BINARY = 63\nGGML_OP_MAP_CUSTOM1_F32 = 64\nGGML_OP_MAP_CUSTOM2_F32 = 65\nGGML_OP_MAP_CUSTOM3_F32 = 66\nGGML_OP_MAP_CUSTOM1 = 67\nGGML_OP_MAP_CUSTOM2 = 68\nGGML_OP_MAP_CUSTOM3 = 69\nGGML_OP_CROSS_ENTROPY_LOSS = 70",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MAP_UNARY",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MAP_UNARY = 62\nGGML_OP_MAP_BINARY = 63\nGGML_OP_MAP_CUSTOM1_F32 = 64\nGGML_OP_MAP_CUSTOM2_F32 = 65\nGGML_OP_MAP_CUSTOM3_F32 = 66\nGGML_OP_MAP_CUSTOM1 = 67\nGGML_OP_MAP_CUSTOM2 = 68\nGGML_OP_MAP_CUSTOM3 = 69\nGGML_OP_CROSS_ENTROPY_LOSS = 70\nGGML_OP_CROSS_ENTROPY_LOSS_BACK = 71",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MAP_BINARY",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MAP_BINARY = 63\nGGML_OP_MAP_CUSTOM1_F32 = 64\nGGML_OP_MAP_CUSTOM2_F32 = 65\nGGML_OP_MAP_CUSTOM3_F32 = 66\nGGML_OP_MAP_CUSTOM1 = 67\nGGML_OP_MAP_CUSTOM2 = 68\nGGML_OP_MAP_CUSTOM3 = 69\nGGML_OP_CROSS_ENTROPY_LOSS = 70\nGGML_OP_CROSS_ENTROPY_LOSS_BACK = 71\nGGML_OP_COUNT = 72",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MAP_CUSTOM1_F32",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MAP_CUSTOM1_F32 = 64\nGGML_OP_MAP_CUSTOM2_F32 = 65\nGGML_OP_MAP_CUSTOM3_F32 = 66\nGGML_OP_MAP_CUSTOM1 = 67\nGGML_OP_MAP_CUSTOM2 = 68\nGGML_OP_MAP_CUSTOM3 = 69\nGGML_OP_CROSS_ENTROPY_LOSS = 70\nGGML_OP_CROSS_ENTROPY_LOSS_BACK = 71\nGGML_OP_COUNT = 72\n# enum ggml_unary_op {",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MAP_CUSTOM2_F32",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MAP_CUSTOM2_F32 = 65\nGGML_OP_MAP_CUSTOM3_F32 = 66\nGGML_OP_MAP_CUSTOM1 = 67\nGGML_OP_MAP_CUSTOM2 = 68\nGGML_OP_MAP_CUSTOM3 = 69\nGGML_OP_CROSS_ENTROPY_LOSS = 70\nGGML_OP_CROSS_ENTROPY_LOSS_BACK = 71\nGGML_OP_COUNT = 72\n# enum ggml_unary_op {\n#     GGML_UNARY_OP_ABS,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MAP_CUSTOM3_F32",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MAP_CUSTOM3_F32 = 66\nGGML_OP_MAP_CUSTOM1 = 67\nGGML_OP_MAP_CUSTOM2 = 68\nGGML_OP_MAP_CUSTOM3 = 69\nGGML_OP_CROSS_ENTROPY_LOSS = 70\nGGML_OP_CROSS_ENTROPY_LOSS_BACK = 71\nGGML_OP_COUNT = 72\n# enum ggml_unary_op {\n#     GGML_UNARY_OP_ABS,\n#     GGML_UNARY_OP_SGN,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MAP_CUSTOM1",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MAP_CUSTOM1 = 67\nGGML_OP_MAP_CUSTOM2 = 68\nGGML_OP_MAP_CUSTOM3 = 69\nGGML_OP_CROSS_ENTROPY_LOSS = 70\nGGML_OP_CROSS_ENTROPY_LOSS_BACK = 71\nGGML_OP_COUNT = 72\n# enum ggml_unary_op {\n#     GGML_UNARY_OP_ABS,\n#     GGML_UNARY_OP_SGN,\n#     GGML_UNARY_OP_NEG,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MAP_CUSTOM2",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MAP_CUSTOM2 = 68\nGGML_OP_MAP_CUSTOM3 = 69\nGGML_OP_CROSS_ENTROPY_LOSS = 70\nGGML_OP_CROSS_ENTROPY_LOSS_BACK = 71\nGGML_OP_COUNT = 72\n# enum ggml_unary_op {\n#     GGML_UNARY_OP_ABS,\n#     GGML_UNARY_OP_SGN,\n#     GGML_UNARY_OP_NEG,\n#     GGML_UNARY_OP_STEP,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_MAP_CUSTOM3",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_MAP_CUSTOM3 = 69\nGGML_OP_CROSS_ENTROPY_LOSS = 70\nGGML_OP_CROSS_ENTROPY_LOSS_BACK = 71\nGGML_OP_COUNT = 72\n# enum ggml_unary_op {\n#     GGML_UNARY_OP_ABS,\n#     GGML_UNARY_OP_SGN,\n#     GGML_UNARY_OP_NEG,\n#     GGML_UNARY_OP_STEP,\n#     GGML_UNARY_OP_TANH,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_CROSS_ENTROPY_LOSS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_CROSS_ENTROPY_LOSS = 70\nGGML_OP_CROSS_ENTROPY_LOSS_BACK = 71\nGGML_OP_COUNT = 72\n# enum ggml_unary_op {\n#     GGML_UNARY_OP_ABS,\n#     GGML_UNARY_OP_SGN,\n#     GGML_UNARY_OP_NEG,\n#     GGML_UNARY_OP_STEP,\n#     GGML_UNARY_OP_TANH,\n#     GGML_UNARY_OP_ELU,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_CROSS_ENTROPY_LOSS_BACK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_CROSS_ENTROPY_LOSS_BACK = 71\nGGML_OP_COUNT = 72\n# enum ggml_unary_op {\n#     GGML_UNARY_OP_ABS,\n#     GGML_UNARY_OP_SGN,\n#     GGML_UNARY_OP_NEG,\n#     GGML_UNARY_OP_STEP,\n#     GGML_UNARY_OP_TANH,\n#     GGML_UNARY_OP_ELU,\n#     GGML_UNARY_OP_RELU,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_COUNT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_COUNT = 72\n# enum ggml_unary_op {\n#     GGML_UNARY_OP_ABS,\n#     GGML_UNARY_OP_SGN,\n#     GGML_UNARY_OP_NEG,\n#     GGML_UNARY_OP_STEP,\n#     GGML_UNARY_OP_TANH,\n#     GGML_UNARY_OP_ELU,\n#     GGML_UNARY_OP_RELU,\n#     GGML_UNARY_OP_GELU,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_ABS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_ABS = 0\nGGML_UNARY_OP_SGN = 1\nGGML_UNARY_OP_NEG = 2\nGGML_UNARY_OP_STEP = 3\nGGML_UNARY_OP_TANH = 4\nGGML_UNARY_OP_ELU = 5\nGGML_UNARY_OP_RELU = 6\nGGML_UNARY_OP_GELU = 7\nGGML_UNARY_OP_GELU_QUICK = 8\nGGML_UNARY_OP_SILU = 9",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_SGN",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_SGN = 1\nGGML_UNARY_OP_NEG = 2\nGGML_UNARY_OP_STEP = 3\nGGML_UNARY_OP_TANH = 4\nGGML_UNARY_OP_ELU = 5\nGGML_UNARY_OP_RELU = 6\nGGML_UNARY_OP_GELU = 7\nGGML_UNARY_OP_GELU_QUICK = 8\nGGML_UNARY_OP_SILU = 9\nGGML_UNARY_OP_LEAKY = 10",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_NEG",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_NEG = 2\nGGML_UNARY_OP_STEP = 3\nGGML_UNARY_OP_TANH = 4\nGGML_UNARY_OP_ELU = 5\nGGML_UNARY_OP_RELU = 6\nGGML_UNARY_OP_GELU = 7\nGGML_UNARY_OP_GELU_QUICK = 8\nGGML_UNARY_OP_SILU = 9\nGGML_UNARY_OP_LEAKY = 10\nGGML_UNARY_OP_COUNT = 11",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_STEP",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_STEP = 3\nGGML_UNARY_OP_TANH = 4\nGGML_UNARY_OP_ELU = 5\nGGML_UNARY_OP_RELU = 6\nGGML_UNARY_OP_GELU = 7\nGGML_UNARY_OP_GELU_QUICK = 8\nGGML_UNARY_OP_SILU = 9\nGGML_UNARY_OP_LEAKY = 10\nGGML_UNARY_OP_COUNT = 11\n# enum ggml_object_type {",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_TANH",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_TANH = 4\nGGML_UNARY_OP_ELU = 5\nGGML_UNARY_OP_RELU = 6\nGGML_UNARY_OP_GELU = 7\nGGML_UNARY_OP_GELU_QUICK = 8\nGGML_UNARY_OP_SILU = 9\nGGML_UNARY_OP_LEAKY = 10\nGGML_UNARY_OP_COUNT = 11\n# enum ggml_object_type {\n#     GGML_OBJECT_TENSOR,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_ELU",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_ELU = 5\nGGML_UNARY_OP_RELU = 6\nGGML_UNARY_OP_GELU = 7\nGGML_UNARY_OP_GELU_QUICK = 8\nGGML_UNARY_OP_SILU = 9\nGGML_UNARY_OP_LEAKY = 10\nGGML_UNARY_OP_COUNT = 11\n# enum ggml_object_type {\n#     GGML_OBJECT_TENSOR,\n#     GGML_OBJECT_GRAPH,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_RELU",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_RELU = 6\nGGML_UNARY_OP_GELU = 7\nGGML_UNARY_OP_GELU_QUICK = 8\nGGML_UNARY_OP_SILU = 9\nGGML_UNARY_OP_LEAKY = 10\nGGML_UNARY_OP_COUNT = 11\n# enum ggml_object_type {\n#     GGML_OBJECT_TENSOR,\n#     GGML_OBJECT_GRAPH,\n#     GGML_OBJECT_WORK_BUFFER",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_GELU",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_GELU = 7\nGGML_UNARY_OP_GELU_QUICK = 8\nGGML_UNARY_OP_SILU = 9\nGGML_UNARY_OP_LEAKY = 10\nGGML_UNARY_OP_COUNT = 11\n# enum ggml_object_type {\n#     GGML_OBJECT_TENSOR,\n#     GGML_OBJECT_GRAPH,\n#     GGML_OBJECT_WORK_BUFFER\n# };",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_GELU_QUICK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_GELU_QUICK = 8\nGGML_UNARY_OP_SILU = 9\nGGML_UNARY_OP_LEAKY = 10\nGGML_UNARY_OP_COUNT = 11\n# enum ggml_object_type {\n#     GGML_OBJECT_TENSOR,\n#     GGML_OBJECT_GRAPH,\n#     GGML_OBJECT_WORK_BUFFER\n# };\nGGML_OBJECT_TENSOR = 0",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_SILU",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_SILU = 9\nGGML_UNARY_OP_LEAKY = 10\nGGML_UNARY_OP_COUNT = 11\n# enum ggml_object_type {\n#     GGML_OBJECT_TENSOR,\n#     GGML_OBJECT_GRAPH,\n#     GGML_OBJECT_WORK_BUFFER\n# };\nGGML_OBJECT_TENSOR = 0\nGGML_OBJECT_GRAPH = 1",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_LEAKY",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_LEAKY = 10\nGGML_UNARY_OP_COUNT = 11\n# enum ggml_object_type {\n#     GGML_OBJECT_TENSOR,\n#     GGML_OBJECT_GRAPH,\n#     GGML_OBJECT_WORK_BUFFER\n# };\nGGML_OBJECT_TENSOR = 0\nGGML_OBJECT_GRAPH = 1\nGGML_OBJECT_WORK_BUFFER = 2",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_UNARY_OP_COUNT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_UNARY_OP_COUNT = 11\n# enum ggml_object_type {\n#     GGML_OBJECT_TENSOR,\n#     GGML_OBJECT_GRAPH,\n#     GGML_OBJECT_WORK_BUFFER\n# };\nGGML_OBJECT_TENSOR = 0\nGGML_OBJECT_GRAPH = 1\nGGML_OBJECT_WORK_BUFFER = 2\n# enum ggml_log_level {",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OBJECT_TENSOR",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OBJECT_TENSOR = 0\nGGML_OBJECT_GRAPH = 1\nGGML_OBJECT_WORK_BUFFER = 2\n# enum ggml_log_level {\n#     GGML_LOG_LEVEL_ERROR = 2,\n#     GGML_LOG_LEVEL_WARN = 3,\n#     GGML_LOG_LEVEL_INFO = 4\n# };\nGGML_LOG_LEVEL_ERROR = 2\nGGML_LOG_LEVEL_WARN = 3",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OBJECT_GRAPH",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OBJECT_GRAPH = 1\nGGML_OBJECT_WORK_BUFFER = 2\n# enum ggml_log_level {\n#     GGML_LOG_LEVEL_ERROR = 2,\n#     GGML_LOG_LEVEL_WARN = 3,\n#     GGML_LOG_LEVEL_INFO = 4\n# };\nGGML_LOG_LEVEL_ERROR = 2\nGGML_LOG_LEVEL_WARN = 3\nGGML_LOG_LEVEL_INFO = 4",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OBJECT_WORK_BUFFER",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OBJECT_WORK_BUFFER = 2\n# enum ggml_log_level {\n#     GGML_LOG_LEVEL_ERROR = 2,\n#     GGML_LOG_LEVEL_WARN = 3,\n#     GGML_LOG_LEVEL_INFO = 4\n# };\nGGML_LOG_LEVEL_ERROR = 2\nGGML_LOG_LEVEL_WARN = 3\nGGML_LOG_LEVEL_INFO = 4\n# // ggml object",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LOG_LEVEL_ERROR",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LOG_LEVEL_ERROR = 2\nGGML_LOG_LEVEL_WARN = 3\nGGML_LOG_LEVEL_INFO = 4\n# // ggml object\n# struct ggml_object {\n#     size_t offs;\n#     size_t size;\n#     struct ggml_object * next;\n#     enum ggml_object_type type;\n#     char padding[4];",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LOG_LEVEL_WARN",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LOG_LEVEL_WARN = 3\nGGML_LOG_LEVEL_INFO = 4\n# // ggml object\n# struct ggml_object {\n#     size_t offs;\n#     size_t size;\n#     struct ggml_object * next;\n#     enum ggml_object_type type;\n#     char padding[4];\n# };",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LOG_LEVEL_INFO",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LOG_LEVEL_INFO = 4\n# // ggml object\n# struct ggml_object {\n#     size_t offs;\n#     size_t size;\n#     struct ggml_object * next;\n#     enum ggml_object_type type;\n#     char padding[4];\n# };\nclass ggml_object(ctypes.Structure):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_object._fields_",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_object._fields_ = [\n    (\"offs\", ctypes.c_size_t),\n    (\"size\", ctypes.c_size_t),\n    (\"next\", ctypes.POINTER(ggml_object)),\n    (\"type\", ctypes.c_int),\n    (\"padding\", ctypes.c_char * 4),\n]\nggml_object_p: TypeAlias = \"ctypes._Pointer[ggml_object]\"  # type: ignore\nGGML_OBJECT_SIZE = ctypes.sizeof(ggml_object)\n# // n-dimensional tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OBJECT_SIZE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OBJECT_SIZE = ctypes.sizeof(ggml_object)\n# // n-dimensional tensor\n# struct ggml_tensor {\n#     enum ggml_type         type;\n#     enum ggml_backend_type backend;\n#     struct ggml_backend_buffer * buffer;\n#     int     n_dims;\n#     int64_t ne[GGML_MAX_DIMS]; // number of elements\n#     size_t  nb[GGML_MAX_DIMS]; // stride in bytes:\n#                                // nb[0] = ggml_type_size(type)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tensor._fields_",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_tensor._fields_ = [\n    (\"type\", ctypes.c_int),\n    (\"backend\", ctypes.c_int),\n    (\"buffer\", ctypes.c_void_p),\n    (\"n_dims\", ctypes.c_int),\n    (\"ne\", ctypes.c_int64 * GGML_MAX_DIMS),\n    (\"nb\", ctypes.c_size_t * GGML_MAX_DIMS),\n    (\"op\", ctypes.c_int),\n    (\n        \"op_params\",",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TENSOR_SIZE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TENSOR_SIZE = ctypes.sizeof(ggml_tensor)\nggml_tensor_p: TypeAlias = \"ctypes._Pointer[ggml_tensor]\"  # type: ignore\n\"\"\"ctypes pointer to a [ggml_tensor][ggml.ggml_tensor]\nCan be dereferenced to a [ggml_tensor][ggml.ggml_tensor] object using\nthe `.contents` attribute.\"\"\"\nabort_callback_t = ctypes.CFUNCTYPE(ctypes.c_bool, ctypes.c_void_p)\n# // the compute plan that needs to be prepared for ggml_graph_compute()\n# // since https://github.com/ggerganov/ggml/issues/287\n# struct ggml_cplan {\n#     size_t    work_size; // size of work buffer, calculated by `ggml_graph_plan()`",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "abort_callback_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "abort_callback_t = ctypes.CFUNCTYPE(ctypes.c_bool, ctypes.c_void_p)\n# // the compute plan that needs to be prepared for ggml_graph_compute()\n# // since https://github.com/ggerganov/ggml/issues/287\n# struct ggml_cplan {\n#     size_t    work_size; // size of work buffer, calculated by `ggml_graph_plan()`\n#     uint8_t * work_data; // work buffer, to be allocated by caller before calling to `ggml_graph_compute()`\n#     int n_threads;\n#     // abort ggml_graph_compute when true\n#     bool (*abort_callback)(void * data);\n#     void * abort_callback_data;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_CPLAN_SIZE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_CPLAN_SIZE = ctypes.sizeof(ggml_cplan)\nggml_cplan_p: TypeAlias = \"ctypes._Pointer[ggml_cplan]\"  # type: ignore\n\"\"\"ctypes pointer to a [ggml_cplan][ggml.ggml_cplan]\nCan be dereferenced to a [ggml_cplan][ggml.ggml_cplan] object using\nthe `.contents` attribute.\"\"\"\n# enum ggml_cgraph_eval_order {\n#     GGML_CGRAPH_EVAL_ORDER_LEFT_TO_RIGHT = 0,\n#     GGML_CGRAPH_EVAL_ORDER_RIGHT_TO_LEFT,\n#     GGML_CGRAPH_EVAL_ORDER_COUNT\n# };",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_CGRAPH_EVAL_ORDER_LEFT_TO_RIGHT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_CGRAPH_EVAL_ORDER_LEFT_TO_RIGHT = 0\nGGML_CGRAPH_EVAL_ORDER_RIGHT_TO_LEFT = 1\nGGML_CGRAPH_EVAL_ORDER_COUNT = 2\n# struct ggml_hash_set {\n#     size_t size;\n#     struct ggml_tensor ** keys;\n# };\nclass ggml_hash_set(ctypes.Structure):\n    _fields_ = [\n        (\"size\", ctypes.c_size_t),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_CGRAPH_EVAL_ORDER_RIGHT_TO_LEFT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_CGRAPH_EVAL_ORDER_RIGHT_TO_LEFT = 1\nGGML_CGRAPH_EVAL_ORDER_COUNT = 2\n# struct ggml_hash_set {\n#     size_t size;\n#     struct ggml_tensor ** keys;\n# };\nclass ggml_hash_set(ctypes.Structure):\n    _fields_ = [\n        (\"size\", ctypes.c_size_t),\n        (\"keys\", ctypes.POINTER(ctypes.POINTER(ggml_tensor))),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_CGRAPH_EVAL_ORDER_COUNT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_CGRAPH_EVAL_ORDER_COUNT = 2\n# struct ggml_hash_set {\n#     size_t size;\n#     struct ggml_tensor ** keys;\n# };\nclass ggml_hash_set(ctypes.Structure):\n    _fields_ = [\n        (\"size\", ctypes.c_size_t),\n        (\"keys\", ctypes.POINTER(ctypes.POINTER(ggml_tensor))),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TASK_INIT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TASK_INIT = 0\nGGML_TASK_COMPUTE = 1\nGGML_TASK_FINALIZE = 2\n# struct ggml_compute_params {\n#     enum ggml_task_type type;\n#     // ith = thread index, nth = number of threads\n#     int ith, nth;\n#     // work buffer for all threads\n#     size_t wsize;\n#     void * wdata;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TASK_COMPUTE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TASK_COMPUTE = 1\nGGML_TASK_FINALIZE = 2\n# struct ggml_compute_params {\n#     enum ggml_task_type type;\n#     // ith = thread index, nth = number of threads\n#     int ith, nth;\n#     // work buffer for all threads\n#     size_t wsize;\n#     void * wdata;\n# };",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_TASK_FINALIZE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_TASK_FINALIZE = 2\n# struct ggml_compute_params {\n#     enum ggml_task_type type;\n#     // ith = thread index, nth = number of threads\n#     int ith, nth;\n#     // work buffer for all threads\n#     size_t wsize;\n#     void * wdata;\n# };\nclass ggml_compute_params(ctypes.Structure):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_time_init.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_time_init.argtypes = []\nlib.ggml_time_init.restype = None\n# GGML_API int64_t ggml_time_ms(void);\ndef ggml_time_ms() -> int:\n    return lib.ggml_time_ms()\nlib.ggml_time_ms.argtypes = []\nlib.ggml_time_ms.restype = ctypes.c_int64\n# GGML_API int64_t ggml_time_us(void);\ndef ggml_time_us() -> int:\n    return lib.ggml_time_us()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_time_init.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_time_init.restype = None\n# GGML_API int64_t ggml_time_ms(void);\ndef ggml_time_ms() -> int:\n    return lib.ggml_time_ms()\nlib.ggml_time_ms.argtypes = []\nlib.ggml_time_ms.restype = ctypes.c_int64\n# GGML_API int64_t ggml_time_us(void);\ndef ggml_time_us() -> int:\n    return lib.ggml_time_us()\nlib.ggml_time_us.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_time_ms.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_time_ms.argtypes = []\nlib.ggml_time_ms.restype = ctypes.c_int64\n# GGML_API int64_t ggml_time_us(void);\ndef ggml_time_us() -> int:\n    return lib.ggml_time_us()\nlib.ggml_time_us.argtypes = []\nlib.ggml_time_us.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles(void);\ndef ggml_cycles() -> int:\n    return lib.ggml_cycles()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_time_ms.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_time_ms.restype = ctypes.c_int64\n# GGML_API int64_t ggml_time_us(void);\ndef ggml_time_us() -> int:\n    return lib.ggml_time_us()\nlib.ggml_time_us.argtypes = []\nlib.ggml_time_us.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles(void);\ndef ggml_cycles() -> int:\n    return lib.ggml_cycles()\nlib.ggml_cycles.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_time_us.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_time_us.argtypes = []\nlib.ggml_time_us.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles(void);\ndef ggml_cycles() -> int:\n    return lib.ggml_cycles()\nlib.ggml_cycles.argtypes = []\nlib.ggml_cycles.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles_per_ms(void);\ndef ggml_cycles_per_ms() -> int:\n    return lib.ggml_cycles_per_ms()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_time_us.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_time_us.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles(void);\ndef ggml_cycles() -> int:\n    return lib.ggml_cycles()\nlib.ggml_cycles.argtypes = []\nlib.ggml_cycles.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles_per_ms(void);\ndef ggml_cycles_per_ms() -> int:\n    return lib.ggml_cycles_per_ms()\nlib.ggml_cycles_per_ms.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cycles.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cycles.argtypes = []\nlib.ggml_cycles.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles_per_ms(void);\ndef ggml_cycles_per_ms() -> int:\n    return lib.ggml_cycles_per_ms()\nlib.ggml_cycles_per_ms.argtypes = []\nlib.ggml_cycles_per_ms.restype = ctypes.c_int64\n# GGML_API void    ggml_print_backtrace(void);\ndef ggml_print_backtrace():\n    return lib.ggml_print_backtrace()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cycles.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cycles.restype = ctypes.c_int64\n# GGML_API int64_t ggml_cycles_per_ms(void);\ndef ggml_cycles_per_ms() -> int:\n    return lib.ggml_cycles_per_ms()\nlib.ggml_cycles_per_ms.argtypes = []\nlib.ggml_cycles_per_ms.restype = ctypes.c_int64\n# GGML_API void    ggml_print_backtrace(void);\ndef ggml_print_backtrace():\n    return lib.ggml_print_backtrace()\nlib.ggml_print_backtrace.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cycles_per_ms.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cycles_per_ms.argtypes = []\nlib.ggml_cycles_per_ms.restype = ctypes.c_int64\n# GGML_API void    ggml_print_backtrace(void);\ndef ggml_print_backtrace():\n    return lib.ggml_print_backtrace()\nlib.ggml_print_backtrace.argtypes = []\nlib.ggml_print_backtrace.restype = None\n# GGML_API void    ggml_numa_init(void); // call once for better performance on NUMA systems\ndef ggml_numa_init():\n    return lib.ggml_numa_init()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cycles_per_ms.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cycles_per_ms.restype = ctypes.c_int64\n# GGML_API void    ggml_print_backtrace(void);\ndef ggml_print_backtrace():\n    return lib.ggml_print_backtrace()\nlib.ggml_print_backtrace.argtypes = []\nlib.ggml_print_backtrace.restype = None\n# GGML_API void    ggml_numa_init(void); // call once for better performance on NUMA systems\ndef ggml_numa_init():\n    return lib.ggml_numa_init()\nlib.ggml_numa_init.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_print_backtrace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_print_backtrace.argtypes = []\nlib.ggml_print_backtrace.restype = None\n# GGML_API void    ggml_numa_init(void); // call once for better performance on NUMA systems\ndef ggml_numa_init():\n    return lib.ggml_numa_init()\nlib.ggml_numa_init.argtypes = []\nlib.ggml_numa_init.restype = None\n# GGML_API bool    ggml_is_numa(void); // true if init detected that system has >1 NUMA node\ndef ggml_is_numa() -> bool:\n    return lib.ggml_is_numa()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_print_backtrace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_print_backtrace.restype = None\n# GGML_API void    ggml_numa_init(void); // call once for better performance on NUMA systems\ndef ggml_numa_init():\n    return lib.ggml_numa_init()\nlib.ggml_numa_init.argtypes = []\nlib.ggml_numa_init.restype = None\n# GGML_API bool    ggml_is_numa(void); // true if init detected that system has >1 NUMA node\ndef ggml_is_numa() -> bool:\n    return lib.ggml_is_numa()\nlib.ggml_is_numa.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_numa_init.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_numa_init.argtypes = []\nlib.ggml_numa_init.restype = None\n# GGML_API bool    ggml_is_numa(void); // true if init detected that system has >1 NUMA node\ndef ggml_is_numa() -> bool:\n    return lib.ggml_is_numa()\nlib.ggml_is_numa.argtypes = []\nlib.ggml_is_numa.restype = ctypes.c_bool\n# GGML_API void    ggml_print_object (const struct ggml_object * obj);\ndef ggml_print_object(obj: ggml_object_p):\n    return lib.ggml_print_object(obj)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_numa_init.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_numa_init.restype = None\n# GGML_API bool    ggml_is_numa(void); // true if init detected that system has >1 NUMA node\ndef ggml_is_numa() -> bool:\n    return lib.ggml_is_numa()\nlib.ggml_is_numa.argtypes = []\nlib.ggml_is_numa.restype = ctypes.c_bool\n# GGML_API void    ggml_print_object (const struct ggml_object * obj);\ndef ggml_print_object(obj: ggml_object_p):\n    return lib.ggml_print_object(obj)\nlib.ggml_print_object.argtypes = [ctypes.POINTER(ggml_object)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_numa.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_numa.argtypes = []\nlib.ggml_is_numa.restype = ctypes.c_bool\n# GGML_API void    ggml_print_object (const struct ggml_object * obj);\ndef ggml_print_object(obj: ggml_object_p):\n    return lib.ggml_print_object(obj)\nlib.ggml_print_object.argtypes = [ctypes.POINTER(ggml_object)]\nlib.ggml_print_object.restype = None\n# GGML_API void    ggml_print_objects(const struct ggml_context * ctx);\ndef ggml_print_objects(ctx: ggml_context_p):\n    return lib.ggml_print_objects(ctx)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_numa.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_numa.restype = ctypes.c_bool\n# GGML_API void    ggml_print_object (const struct ggml_object * obj);\ndef ggml_print_object(obj: ggml_object_p):\n    return lib.ggml_print_object(obj)\nlib.ggml_print_object.argtypes = [ctypes.POINTER(ggml_object)]\nlib.ggml_print_object.restype = None\n# GGML_API void    ggml_print_objects(const struct ggml_context * ctx);\ndef ggml_print_objects(ctx: ggml_context_p):\n    return lib.ggml_print_objects(ctx)\nlib.ggml_print_objects.argtypes = [ggml_context_p]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_print_object.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_print_object.argtypes = [ctypes.POINTER(ggml_object)]\nlib.ggml_print_object.restype = None\n# GGML_API void    ggml_print_objects(const struct ggml_context * ctx);\ndef ggml_print_objects(ctx: ggml_context_p):\n    return lib.ggml_print_objects(ctx)\nlib.ggml_print_objects.argtypes = [ggml_context_p]\nlib.ggml_print_objects.restype = None\n# GGML_API int64_t ggml_nelements   (const struct ggml_tensor * tensor);\ndef ggml_nelements(\n    tensor: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_print_object.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_print_object.restype = None\n# GGML_API void    ggml_print_objects(const struct ggml_context * ctx);\ndef ggml_print_objects(ctx: ggml_context_p):\n    return lib.ggml_print_objects(ctx)\nlib.ggml_print_objects.argtypes = [ggml_context_p]\nlib.ggml_print_objects.restype = None\n# GGML_API int64_t ggml_nelements   (const struct ggml_tensor * tensor);\ndef ggml_nelements(\n    tensor: ggml_tensor_p,\n) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_print_objects.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_print_objects.argtypes = [ggml_context_p]\nlib.ggml_print_objects.restype = None\n# GGML_API int64_t ggml_nelements   (const struct ggml_tensor * tensor);\ndef ggml_nelements(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of elements in a tensor\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_print_objects.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_print_objects.restype = None\n# GGML_API int64_t ggml_nelements   (const struct ggml_tensor * tensor);\ndef ggml_nelements(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of elements in a tensor\n    Parameters:\n        tensor: tensor\n    Returns:\n        number of elements\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nelements.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nelements.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_nelements.restype = ctypes.c_int64\n# GGML_API int64_t ggml_nrows       (const struct ggml_tensor * tensor);\ndef ggml_nrows(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of rows in a tensor\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nelements.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nelements.restype = ctypes.c_int64\n# GGML_API int64_t ggml_nrows       (const struct ggml_tensor * tensor);\ndef ggml_nrows(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of rows in a tensor\n    Parameters:\n        tensor: tensor\n    Returns:\n        number of rows\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nrows.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nrows.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_nrows.restype = ctypes.c_int64\n# GGML_API size_t  ggml_nbytes      (const struct ggml_tensor * tensor);\ndef ggml_nbytes(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of bytes required to store tensor data\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nrows.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nrows.restype = ctypes.c_int64\n# GGML_API size_t  ggml_nbytes      (const struct ggml_tensor * tensor);\ndef ggml_nbytes(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of bytes required to store tensor data\n    Parameters:\n        tensor: tensor\n    Returns:\n        number of bytes\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nbytes.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nbytes.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_nbytes.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_nbytes_pad  (const struct ggml_tensor * tensor); // same as ggml_nbytes() but padded to GGML_MEM_ALIGN\ndef ggml_nbytes_pad(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of bytes required to store tensor data, padded to GGML_MEM_ALIGN\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nbytes.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nbytes.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_nbytes_pad  (const struct ggml_tensor * tensor); // same as ggml_nbytes() but padded to GGML_MEM_ALIGN\ndef ggml_nbytes_pad(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the number of bytes required to store tensor data, padded to GGML_MEM_ALIGN\n    Parameters:\n        tensor: tensor\n    Returns:\n        number of bytes\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nbytes_pad.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nbytes_pad.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_nbytes_pad.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_nbytes_split(const struct ggml_tensor * tensor, int nrows_split);\ndef ggml_nbytes_split(\n    tensor: ggml_tensor_p,\n    nrows_split: Union[ctypes.c_int, int],\n) -> int:\n    return lib.ggml_nbytes_split(tensor, nrows_split)\nlib.ggml_nbytes_split.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_int]\nlib.ggml_nbytes_split.restype = ctypes.c_size_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nbytes_pad.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nbytes_pad.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_nbytes_split(const struct ggml_tensor * tensor, int nrows_split);\ndef ggml_nbytes_split(\n    tensor: ggml_tensor_p,\n    nrows_split: Union[ctypes.c_int, int],\n) -> int:\n    return lib.ggml_nbytes_split(tensor, nrows_split)\nlib.ggml_nbytes_split.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_int]\nlib.ggml_nbytes_split.restype = ctypes.c_size_t\n# GGML_API int     ggml_blck_size (enum ggml_type type);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nbytes_split.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nbytes_split.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_int]\nlib.ggml_nbytes_split.restype = ctypes.c_size_t\n# GGML_API int     ggml_blck_size (enum ggml_type type);\ndef ggml_blck_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_blck_size(type)\nlib.ggml_blck_size.argtypes = [ctypes.c_int]\nlib.ggml_blck_size.restype = ctypes.c_int\n# GGML_API size_t  ggml_type_size (enum ggml_type type); // size in bytes for all elements in a block\ndef ggml_type_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_type_size(type)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_nbytes_split.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_nbytes_split.restype = ctypes.c_size_t\n# GGML_API int     ggml_blck_size (enum ggml_type type);\ndef ggml_blck_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_blck_size(type)\nlib.ggml_blck_size.argtypes = [ctypes.c_int]\nlib.ggml_blck_size.restype = ctypes.c_int\n# GGML_API size_t  ggml_type_size (enum ggml_type type); // size in bytes for all elements in a block\ndef ggml_type_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_type_size(type)\nlib.ggml_type_size.argtypes = [ctypes.c_int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_blck_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_blck_size.argtypes = [ctypes.c_int]\nlib.ggml_blck_size.restype = ctypes.c_int\n# GGML_API size_t  ggml_type_size (enum ggml_type type); // size in bytes for all elements in a block\ndef ggml_type_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_type_size(type)\nlib.ggml_type_size.argtypes = [ctypes.c_int]\nlib.ggml_type_size.restype = ctypes.c_size_t\n# GGML_API float   ggml_type_sizef(enum ggml_type type); // ggml_type_size()/ggml_blck_size() as float\ndef ggml_type_sizef(type: Union[ctypes.c_int, int]) -> float:\n    return lib.ggml_type_sizef(type)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_blck_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_blck_size.restype = ctypes.c_int\n# GGML_API size_t  ggml_type_size (enum ggml_type type); // size in bytes for all elements in a block\ndef ggml_type_size(type: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_type_size(type)\nlib.ggml_type_size.argtypes = [ctypes.c_int]\nlib.ggml_type_size.restype = ctypes.c_size_t\n# GGML_API float   ggml_type_sizef(enum ggml_type type); // ggml_type_size()/ggml_blck_size() as float\ndef ggml_type_sizef(type: Union[ctypes.c_int, int]) -> float:\n    return lib.ggml_type_sizef(type)\nlib.ggml_type_sizef.argtypes = [ctypes.c_int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_type_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_type_size.argtypes = [ctypes.c_int]\nlib.ggml_type_size.restype = ctypes.c_size_t\n# GGML_API float   ggml_type_sizef(enum ggml_type type); // ggml_type_size()/ggml_blck_size() as float\ndef ggml_type_sizef(type: Union[ctypes.c_int, int]) -> float:\n    return lib.ggml_type_sizef(type)\nlib.ggml_type_sizef.argtypes = [ctypes.c_int]\nlib.ggml_type_sizef.restype = ctypes.c_float\n# GGML_API const char * ggml_type_name(enum ggml_type type);\ndef ggml_type_name(type: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_type_name(type)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_type_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_type_size.restype = ctypes.c_size_t\n# GGML_API float   ggml_type_sizef(enum ggml_type type); // ggml_type_size()/ggml_blck_size() as float\ndef ggml_type_sizef(type: Union[ctypes.c_int, int]) -> float:\n    return lib.ggml_type_sizef(type)\nlib.ggml_type_sizef.argtypes = [ctypes.c_int]\nlib.ggml_type_sizef.restype = ctypes.c_float\n# GGML_API const char * ggml_type_name(enum ggml_type type);\ndef ggml_type_name(type: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_type_name(type)\nlib.ggml_type_name.argtypes = [ctypes.c_int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_type_sizef.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_type_sizef.argtypes = [ctypes.c_int]\nlib.ggml_type_sizef.restype = ctypes.c_float\n# GGML_API const char * ggml_type_name(enum ggml_type type);\ndef ggml_type_name(type: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_type_name(type)\nlib.ggml_type_name.argtypes = [ctypes.c_int]\nlib.ggml_type_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_name  (enum ggml_op   op);\ndef ggml_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_name(op)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_type_sizef.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_type_sizef.restype = ctypes.c_float\n# GGML_API const char * ggml_type_name(enum ggml_type type);\ndef ggml_type_name(type: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_type_name(type)\nlib.ggml_type_name.argtypes = [ctypes.c_int]\nlib.ggml_type_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_name  (enum ggml_op   op);\ndef ggml_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_name(op)\nlib.ggml_op_name.argtypes = [ctypes.c_int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_type_name.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_type_name.argtypes = [ctypes.c_int]\nlib.ggml_type_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_name  (enum ggml_op   op);\ndef ggml_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_name(op)\nlib.ggml_op_name.argtypes = [ctypes.c_int]\nlib.ggml_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_symbol(enum ggml_op   op);\ndef ggml_op_symbol(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_symbol(op)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_type_name.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_type_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_name  (enum ggml_op   op);\ndef ggml_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_name(op)\nlib.ggml_op_name.argtypes = [ctypes.c_int]\nlib.ggml_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_symbol(enum ggml_op   op);\ndef ggml_op_symbol(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_symbol(op)\nlib.ggml_op_symbol.argtypes = [ctypes.c_int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_op_name.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_op_name.argtypes = [ctypes.c_int]\nlib.ggml_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_symbol(enum ggml_op   op);\ndef ggml_op_symbol(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_symbol(op)\nlib.ggml_op_symbol.argtypes = [ctypes.c_int]\nlib.ggml_op_symbol.restype = ctypes.c_char_p\n# GGML_API const char * ggml_unary_op_name(enum ggml_unary_op op);\ndef ggml_unary_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_unary_op_name(op)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_op_name.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_symbol(enum ggml_op   op);\ndef ggml_op_symbol(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_op_symbol(op)\nlib.ggml_op_symbol.argtypes = [ctypes.c_int]\nlib.ggml_op_symbol.restype = ctypes.c_char_p\n# GGML_API const char * ggml_unary_op_name(enum ggml_unary_op op);\ndef ggml_unary_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_unary_op_name(op)\nlib.ggml_unary_op_name.argtypes = [ctypes.c_int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_op_symbol.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_op_symbol.argtypes = [ctypes.c_int]\nlib.ggml_op_symbol.restype = ctypes.c_char_p\n# GGML_API const char * ggml_unary_op_name(enum ggml_unary_op op);\ndef ggml_unary_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_unary_op_name(op)\nlib.ggml_unary_op_name.argtypes = [ctypes.c_int]\nlib.ggml_unary_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_desc(const struct ggml_tensor * t); // unary or op name\ndef ggml_op_desc(\n    t: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_op_symbol.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_op_symbol.restype = ctypes.c_char_p\n# GGML_API const char * ggml_unary_op_name(enum ggml_unary_op op);\ndef ggml_unary_op_name(op: Union[ctypes.c_int, int]) -> bytes:\n    return lib.ggml_unary_op_name(op)\nlib.ggml_unary_op_name.argtypes = [ctypes.c_int]\nlib.ggml_unary_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_desc(const struct ggml_tensor * t); // unary or op name\ndef ggml_op_desc(\n    t: ggml_tensor_p,\n) -> bytes:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_unary_op_name.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_unary_op_name.argtypes = [ctypes.c_int]\nlib.ggml_unary_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_desc(const struct ggml_tensor * t); // unary or op name\ndef ggml_op_desc(\n    t: ggml_tensor_p,\n) -> bytes:\n    return lib.ggml_op_desc(t)\nlib.ggml_op_desc.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_op_desc.restype = ctypes.c_char_p\n# GGML_API size_t  ggml_element_size(const struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_unary_op_name.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_unary_op_name.restype = ctypes.c_char_p\n# GGML_API const char * ggml_op_desc(const struct ggml_tensor * t); // unary or op name\ndef ggml_op_desc(\n    t: ggml_tensor_p,\n) -> bytes:\n    return lib.ggml_op_desc(t)\nlib.ggml_op_desc.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_op_desc.restype = ctypes.c_char_p\n# GGML_API size_t  ggml_element_size(const struct ggml_tensor * tensor);\ndef ggml_element_size(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_op_desc.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_op_desc.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_op_desc.restype = ctypes.c_char_p\n# GGML_API size_t  ggml_element_size(const struct ggml_tensor * tensor);\ndef ggml_element_size(\n    tensor: ggml_tensor_p,\n) -> int:\n    return lib.ggml_element_size(tensor)\nlib.ggml_element_size.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_element_size.restype = ctypes.c_size_t\n# GGML_API bool    ggml_is_quantized(enum ggml_type type);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_op_desc.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_op_desc.restype = ctypes.c_char_p\n# GGML_API size_t  ggml_element_size(const struct ggml_tensor * tensor);\ndef ggml_element_size(\n    tensor: ggml_tensor_p,\n) -> int:\n    return lib.ggml_element_size(tensor)\nlib.ggml_element_size.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_element_size.restype = ctypes.c_size_t\n# GGML_API bool    ggml_is_quantized(enum ggml_type type);\ndef ggml_is_quantized(type: Union[ctypes.c_int, int]) -> bool:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_element_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_element_size.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_element_size.restype = ctypes.c_size_t\n# GGML_API bool    ggml_is_quantized(enum ggml_type type);\ndef ggml_is_quantized(type: Union[ctypes.c_int, int]) -> bool:\n    return lib.ggml_is_quantized(type)\nlib.ggml_is_quantized.argtypes = [ctypes.c_int]\nlib.ggml_is_quantized.restype = ctypes.c_bool\n# // TODO: temporary until model loading of ggml examples is refactored\n# GGML_API enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype);\ndef ggml_ftype_to_ggml_type(ftype: Union[ctypes.c_int, int]) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_element_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_element_size.restype = ctypes.c_size_t\n# GGML_API bool    ggml_is_quantized(enum ggml_type type);\ndef ggml_is_quantized(type: Union[ctypes.c_int, int]) -> bool:\n    return lib.ggml_is_quantized(type)\nlib.ggml_is_quantized.argtypes = [ctypes.c_int]\nlib.ggml_is_quantized.restype = ctypes.c_bool\n# // TODO: temporary until model loading of ggml examples is refactored\n# GGML_API enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype);\ndef ggml_ftype_to_ggml_type(ftype: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_ftype_to_ggml_type(ftype)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_quantized.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_quantized.argtypes = [ctypes.c_int]\nlib.ggml_is_quantized.restype = ctypes.c_bool\n# // TODO: temporary until model loading of ggml examples is refactored\n# GGML_API enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype);\ndef ggml_ftype_to_ggml_type(ftype: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_ftype_to_ggml_type(ftype)\nlib.ggml_ftype_to_ggml_type.argtypes = [ctypes.c_int]\nlib.ggml_ftype_to_ggml_type.restype = ctypes.c_int\n# GGML_API bool ggml_is_transposed(const struct ggml_tensor * tensor);\ndef ggml_is_transposed(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_quantized.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_quantized.restype = ctypes.c_bool\n# // TODO: temporary until model loading of ggml examples is refactored\n# GGML_API enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype);\ndef ggml_ftype_to_ggml_type(ftype: Union[ctypes.c_int, int]) -> int:\n    return lib.ggml_ftype_to_ggml_type(ftype)\nlib.ggml_ftype_to_ggml_type.argtypes = [ctypes.c_int]\nlib.ggml_ftype_to_ggml_type.restype = ctypes.c_int\n# GGML_API bool ggml_is_transposed(const struct ggml_tensor * tensor);\ndef ggml_is_transposed(\n    tensor: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_ftype_to_ggml_type.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_ftype_to_ggml_type.argtypes = [ctypes.c_int]\nlib.ggml_ftype_to_ggml_type.restype = ctypes.c_int\n# GGML_API bool ggml_is_transposed(const struct ggml_tensor * tensor);\ndef ggml_is_transposed(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is transposed\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_ftype_to_ggml_type.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_ftype_to_ggml_type.restype = ctypes.c_int\n# GGML_API bool ggml_is_transposed(const struct ggml_tensor * tensor);\ndef ggml_is_transposed(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is transposed\n    Parameters:\n        tensor: tensor\n    Returns:\n        True if tensor is transposed else False\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_transposed.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_transposed.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_is_transposed.restype = ctypes.c_bool\n# GGML_API bool ggml_is_contiguous(const struct ggml_tensor * tensor);\ndef ggml_is_contiguous(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is contiguous\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_transposed.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_transposed.restype = ctypes.c_bool\n# GGML_API bool ggml_is_contiguous(const struct ggml_tensor * tensor);\ndef ggml_is_contiguous(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is contiguous\n    Parameters:\n        tensor: tensor\n    Returns:\n        True if tensor is contiguous else False\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_contiguous.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_contiguous.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_is_contiguous.restype = ctypes.c_bool\n# GGML_API bool ggml_is_permuted  (const struct ggml_tensor * tensor);\ndef ggml_is_permuted(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is permuted\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_contiguous.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_contiguous.restype = ctypes.c_bool\n# GGML_API bool ggml_is_permuted  (const struct ggml_tensor * tensor);\ndef ggml_is_permuted(\n    tensor: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if a tensor is permuted\n    Parameters:\n        tensor: tensor\n    Returns:\n        True if tensor is permuted else False\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_permuted.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_permuted.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_is_permuted.restype = ctypes.c_bool\n# GGML_API bool ggml_are_same_shape(const struct ggml_tensor * t0, const struct ggml_tensor * t1);\ndef ggml_are_same_shape(\n    t0: ggml_tensor_p,\n    t1: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if two tensors have the same shape\n    Parameters:\n        t0: tensor 0",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_is_permuted.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_is_permuted.restype = ctypes.c_bool\n# GGML_API bool ggml_are_same_shape(const struct ggml_tensor * t0, const struct ggml_tensor * t1);\ndef ggml_are_same_shape(\n    t0: ggml_tensor_p,\n    t1: ggml_tensor_p,\n) -> bool:\n    \"\"\"Check if two tensors have the same shape\n    Parameters:\n        t0: tensor 0\n        t1: tensor 1",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_are_same_shape.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_are_same_shape.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_are_same_shape.restype = ctypes.c_bool\n# // use this to compute the memory overhead of a tensor\n# GGML_API size_t ggml_tensor_overhead(void);\ndef ggml_tensor_overhead() -> int:\n    \"\"\"Overhead required for a tensor struct in bytes\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_are_same_shape.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_are_same_shape.restype = ctypes.c_bool\n# // use this to compute the memory overhead of a tensor\n# GGML_API size_t ggml_tensor_overhead(void);\ndef ggml_tensor_overhead() -> int:\n    \"\"\"Overhead required for a tensor struct in bytes\n    Returns:\n        size of tensor struct in bytes\"\"\"\n    return lib.ggml_tensor_overhead()\nlib.ggml_tensor_overhead.argtypes = []\nlib.ggml_tensor_overhead.restype = ctypes.c_size_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tensor_overhead.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tensor_overhead.argtypes = []\nlib.ggml_tensor_overhead.restype = ctypes.c_size_t\n# // main\n# GGML_API struct ggml_context * ggml_init(struct ggml_init_params params);\ndef ggml_init(\n    params: ggml_init_params,\n) -> ggml_context_p:\n    \"\"\"Instantiate a new ggml context with params.\n    You must call `ggml_free()` to free the context.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tensor_overhead.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tensor_overhead.restype = ctypes.c_size_t\n# // main\n# GGML_API struct ggml_context * ggml_init(struct ggml_init_params params);\ndef ggml_init(\n    params: ggml_init_params,\n) -> ggml_context_p:\n    \"\"\"Instantiate a new ggml context with params.\n    You must call `ggml_free()` to free the context.\n    Parameters:\n        params: ggml init params",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_init.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_init.argtypes = [ggml_init_params]\nlib.ggml_init.restype = ggml_context_p\n# GGML_API void                  ggml_free(struct ggml_context * ctx);\ndef ggml_free(ctx: ggml_context_p):\n    \"\"\"Free the ggml context.\n    Parameters:\n        ctx: ggml context\"\"\"\n    return lib.ggml_free(ctx)\nlib.ggml_free.argtypes = [ggml_context_p]\nlib.ggml_free.restype = None",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_init.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_init.restype = ggml_context_p\n# GGML_API void                  ggml_free(struct ggml_context * ctx);\ndef ggml_free(ctx: ggml_context_p):\n    \"\"\"Free the ggml context.\n    Parameters:\n        ctx: ggml context\"\"\"\n    return lib.ggml_free(ctx)\nlib.ggml_free.argtypes = [ggml_context_p]\nlib.ggml_free.restype = None\n# GGML_API size_t  ggml_used_mem(const struct ggml_context * ctx);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_free.argtypes = [ggml_context_p]\nlib.ggml_free.restype = None\n# GGML_API size_t  ggml_used_mem(const struct ggml_context * ctx);\ndef ggml_used_mem(ctx: ggml_context_p) -> int:\n    \"\"\"Return the amount of memory used by the ggml context in bytes.\n    Parameters:\n        ctx: ggml context\n    Returns:\n        amount of memory used in bytes\"\"\"\n    return lib.ggml_used_mem(ctx)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_free.restype = None\n# GGML_API size_t  ggml_used_mem(const struct ggml_context * ctx);\ndef ggml_used_mem(ctx: ggml_context_p) -> int:\n    \"\"\"Return the amount of memory used by the ggml context in bytes.\n    Parameters:\n        ctx: ggml context\n    Returns:\n        amount of memory used in bytes\"\"\"\n    return lib.ggml_used_mem(ctx)\nlib.ggml_used_mem.argtypes = [ggml_context_p]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_used_mem.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_used_mem.argtypes = [ggml_context_p]\nlib.ggml_used_mem.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_set_scratch(struct ggml_context * ctx, struct ggml_scratch scratch);\ndef ggml_set_scratch(ctx: ggml_context_p, scratch: ggml_scratch) -> int:\n    \"\"\"Set the scratch buffer for the ggml context.\"\"\"\n    return lib.ggml_set_scratch(ctx, scratch)\nlib.ggml_set_scratch.argtypes = [ggml_context_p, ggml_scratch]\nlib.ggml_set_scratch.restype = ctypes.c_size_t\n# GGML_API bool    ggml_get_no_alloc(struct ggml_context * ctx);\ndef ggml_get_no_alloc(ctx: ggml_context_p) -> bool:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_used_mem.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_used_mem.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_set_scratch(struct ggml_context * ctx, struct ggml_scratch scratch);\ndef ggml_set_scratch(ctx: ggml_context_p, scratch: ggml_scratch) -> int:\n    \"\"\"Set the scratch buffer for the ggml context.\"\"\"\n    return lib.ggml_set_scratch(ctx, scratch)\nlib.ggml_set_scratch.argtypes = [ggml_context_p, ggml_scratch]\nlib.ggml_set_scratch.restype = ctypes.c_size_t\n# GGML_API bool    ggml_get_no_alloc(struct ggml_context * ctx);\ndef ggml_get_no_alloc(ctx: ggml_context_p) -> bool:\n    \"\"\"Return the no_alloc flag for the ggml context.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_scratch.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_scratch.argtypes = [ggml_context_p, ggml_scratch]\nlib.ggml_set_scratch.restype = ctypes.c_size_t\n# GGML_API bool    ggml_get_no_alloc(struct ggml_context * ctx);\ndef ggml_get_no_alloc(ctx: ggml_context_p) -> bool:\n    \"\"\"Return the no_alloc flag for the ggml context.\"\"\"\n    return lib.ggml_get_no_alloc(ctx)\nlib.ggml_get_no_alloc.argtypes = [ggml_context_p]\nlib.ggml_get_no_alloc.restype = ctypes.c_bool\n# GGML_API void    ggml_set_no_alloc(struct ggml_context * ctx, bool no_alloc);\ndef ggml_set_no_alloc(ctx: ggml_context_p, no_alloc: Union[ctypes.c_bool, bool]):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_scratch.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_scratch.restype = ctypes.c_size_t\n# GGML_API bool    ggml_get_no_alloc(struct ggml_context * ctx);\ndef ggml_get_no_alloc(ctx: ggml_context_p) -> bool:\n    \"\"\"Return the no_alloc flag for the ggml context.\"\"\"\n    return lib.ggml_get_no_alloc(ctx)\nlib.ggml_get_no_alloc.argtypes = [ggml_context_p]\nlib.ggml_get_no_alloc.restype = ctypes.c_bool\n# GGML_API void    ggml_set_no_alloc(struct ggml_context * ctx, bool no_alloc);\ndef ggml_set_no_alloc(ctx: ggml_context_p, no_alloc: Union[ctypes.c_bool, bool]):\n    \"\"\"Set the no_alloc flag for the ggml context.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_no_alloc.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_no_alloc.argtypes = [ggml_context_p]\nlib.ggml_get_no_alloc.restype = ctypes.c_bool\n# GGML_API void    ggml_set_no_alloc(struct ggml_context * ctx, bool no_alloc);\ndef ggml_set_no_alloc(ctx: ggml_context_p, no_alloc: Union[ctypes.c_bool, bool]):\n    \"\"\"Set the no_alloc flag for the ggml context.\"\"\"\n    return lib.ggml_set_no_alloc(ctx, no_alloc)\nlib.ggml_set_no_alloc.argtypes = [ggml_context_p, ctypes.c_bool]\nlib.ggml_set_no_alloc.restype = None\n# GGML_API void *  ggml_get_mem_buffer     (struct ggml_context * ctx);\ndef ggml_get_mem_buffer(ctx: ggml_context_p) -> Optional[ctypes.c_void_p]:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_no_alloc.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_no_alloc.restype = ctypes.c_bool\n# GGML_API void    ggml_set_no_alloc(struct ggml_context * ctx, bool no_alloc);\ndef ggml_set_no_alloc(ctx: ggml_context_p, no_alloc: Union[ctypes.c_bool, bool]):\n    \"\"\"Set the no_alloc flag for the ggml context.\"\"\"\n    return lib.ggml_set_no_alloc(ctx, no_alloc)\nlib.ggml_set_no_alloc.argtypes = [ggml_context_p, ctypes.c_bool]\nlib.ggml_set_no_alloc.restype = None\n# GGML_API void *  ggml_get_mem_buffer     (struct ggml_context * ctx);\ndef ggml_get_mem_buffer(ctx: ggml_context_p) -> Optional[ctypes.c_void_p]:\n    \"\"\"Return the memory buffer for the ggml context.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_no_alloc.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_no_alloc.argtypes = [ggml_context_p, ctypes.c_bool]\nlib.ggml_set_no_alloc.restype = None\n# GGML_API void *  ggml_get_mem_buffer     (struct ggml_context * ctx);\ndef ggml_get_mem_buffer(ctx: ggml_context_p) -> Optional[ctypes.c_void_p]:\n    \"\"\"Return the memory buffer for the ggml context.\"\"\"\n    return lib.ggml_get_mem_buffer(ctx)\nlib.ggml_get_mem_buffer.argtypes = [ggml_context_p]\nlib.ggml_get_mem_buffer.restype = ctypes.c_void_p\n# GGML_API size_t  ggml_get_mem_size       (struct ggml_context * ctx);\ndef ggml_get_mem_size(ctx: ggml_context_p) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_no_alloc.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_no_alloc.restype = None\n# GGML_API void *  ggml_get_mem_buffer     (struct ggml_context * ctx);\ndef ggml_get_mem_buffer(ctx: ggml_context_p) -> Optional[ctypes.c_void_p]:\n    \"\"\"Return the memory buffer for the ggml context.\"\"\"\n    return lib.ggml_get_mem_buffer(ctx)\nlib.ggml_get_mem_buffer.argtypes = [ggml_context_p]\nlib.ggml_get_mem_buffer.restype = ctypes.c_void_p\n# GGML_API size_t  ggml_get_mem_size       (struct ggml_context * ctx);\ndef ggml_get_mem_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the size of the memory buffer for the ggml context in bytes.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_mem_buffer.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_mem_buffer.argtypes = [ggml_context_p]\nlib.ggml_get_mem_buffer.restype = ctypes.c_void_p\n# GGML_API size_t  ggml_get_mem_size       (struct ggml_context * ctx);\ndef ggml_get_mem_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the size of the memory buffer for the ggml context in bytes.\"\"\"\n    return lib.ggml_get_mem_size(ctx)\nlib.ggml_get_mem_size.argtypes = [ggml_context_p]\nlib.ggml_get_mem_size.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_get_max_tensor_size(const struct ggml_context * ctx);\ndef ggml_get_max_tensor_size(ctx: ggml_context_p) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_mem_buffer.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_mem_buffer.restype = ctypes.c_void_p\n# GGML_API size_t  ggml_get_mem_size       (struct ggml_context * ctx);\ndef ggml_get_mem_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the size of the memory buffer for the ggml context in bytes.\"\"\"\n    return lib.ggml_get_mem_size(ctx)\nlib.ggml_get_mem_size.argtypes = [ggml_context_p]\nlib.ggml_get_mem_size.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_get_max_tensor_size(const struct ggml_context * ctx);\ndef ggml_get_max_tensor_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the maximum size of a tensor in bytes.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_mem_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_mem_size.argtypes = [ggml_context_p]\nlib.ggml_get_mem_size.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_get_max_tensor_size(const struct ggml_context * ctx);\ndef ggml_get_max_tensor_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the maximum size of a tensor in bytes.\"\"\"\n    return lib.ggml_get_max_tensor_size(ctx)\nlib.ggml_get_max_tensor_size.argtypes = [ggml_context_p]\nlib.ggml_get_max_tensor_size.restype = ctypes.c_size_t\n# GGML_API struct ggml_tensor * ggml_new_tensor(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_mem_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_mem_size.restype = ctypes.c_size_t\n# GGML_API size_t  ggml_get_max_tensor_size(const struct ggml_context * ctx);\ndef ggml_get_max_tensor_size(ctx: ggml_context_p) -> int:\n    \"\"\"Return the maximum size of a tensor in bytes.\"\"\"\n    return lib.ggml_get_max_tensor_size(ctx)\nlib.ggml_get_max_tensor_size.argtypes = [ggml_context_p]\nlib.ggml_get_max_tensor_size.restype = ctypes.c_size_t\n# GGML_API struct ggml_tensor * ggml_new_tensor(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_max_tensor_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_max_tensor_size.argtypes = [ggml_context_p]\nlib.ggml_get_max_tensor_size.restype = ctypes.c_size_t\n# GGML_API struct ggml_tensor * ggml_new_tensor(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,\n#         int    n_dims,\n#         const int64_t *ne);\ndef ggml_new_tensor(\n    ctx: ggml_context_p,\n    type: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_max_tensor_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_max_tensor_size.restype = ctypes.c_size_t\n# GGML_API struct ggml_tensor * ggml_new_tensor(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,\n#         int    n_dims,\n#         const int64_t *ne);\ndef ggml_new_tensor(\n    ctx: ggml_context_p,\n    type: Union[ctypes.c_int, int],\n    n_dims: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor.argtypes = [\n    ggml_context_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_new_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_tensor_1d(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_tensor_1d(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,\n#         int64_t ne0);\ndef ggml_new_tensor_1d(\n    ctx: ggml_context_p, type: Union[ctypes.c_int, int], ne0: Union[ctypes.c_int64, int]\n) -> ggml_tensor_p:\n    \"\"\"Create a new 1-dimensional tensor with the given type and number of elements.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor_1d.argtypes = [ggml_context_p, ctypes.c_int, ctypes.c_int64]\nlib.ggml_new_tensor_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_tensor_2d(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,\n#         int64_t ne0,\n#         int64_t ne1);\ndef ggml_new_tensor_2d(\n    ctx: ggml_context_p,\n    type: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_tensor_2d(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,\n#         int64_t ne0,\n#         int64_t ne1);\ndef ggml_new_tensor_2d(\n    ctx: ggml_context_p,\n    type: Union[ctypes.c_int, int],\n    ne0: Union[ctypes.c_int64, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor_2d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor_2d.argtypes = [\n    ggml_context_p,\n    ctypes.c_int,\n    ctypes.c_int64,\n    ctypes.c_int64,\n]\nlib.ggml_new_tensor_2d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_tensor_3d(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor_2d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor_2d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_tensor_3d(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,\n#         int64_t ne0,\n#         int64_t ne1,\n#         int64_t ne2);\ndef ggml_new_tensor_3d(\n    ctx: ggml_context_p,\n    type: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor_3d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor_3d.argtypes = [\n    ggml_context_p,\n    ctypes.c_int,\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n]\nlib.ggml_new_tensor_3d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_tensor_4d(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor_3d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor_3d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_tensor_4d(\n#         struct ggml_context * ctx,\n#         enum   ggml_type type,\n#         int64_t ne0,\n#         int64_t ne1,\n#         int64_t ne2,\n#         int64_t ne3);\ndef ggml_new_tensor_4d(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor_4d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor_4d.argtypes = [\n    ggml_context_p,\n    ctypes.c_int,\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n]\nlib.ggml_new_tensor_4d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_i32(struct ggml_context * ctx, int32_t value);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_tensor_4d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_tensor_4d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_i32(struct ggml_context * ctx, int32_t value);\ndef ggml_new_i32(\n    ctx: ggml_context_p, value: Union[ctypes.c_int32, int]\n) -> ggml_tensor_p:\n    \"\"\"Create a 1 element tensor with the given integer value.\n    Parameters:\n        ctx: ggml context\n        value: integer value\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_i32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_i32.argtypes = [ggml_context_p, ctypes.c_int32]\nlib.ggml_new_i32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_f32(struct ggml_context * ctx, float value);\ndef ggml_new_f32(\n    ctx: ggml_context_p,\n    value: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Create a 1 element tensor with the given float value.\n    Parameters:\n        ctx: ggml context",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_i32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_i32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_new_f32(struct ggml_context * ctx, float value);\ndef ggml_new_f32(\n    ctx: ggml_context_p,\n    value: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Create a 1 element tensor with the given float value.\n    Parameters:\n        ctx: ggml context\n        value: float value",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_f32.argtypes = [ggml_context_p, ctypes.c_float]\nlib.ggml_new_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_dup_tensor (struct ggml_context * ctx, const struct ggml_tensor * src);\ndef ggml_dup_tensor(ctx: ggml_context_p, src: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Create a new tensor with the same type and dimensions as the source tensor.\n    Parameters:\n        ctx: ggml context\n        src: source tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_dup_tensor (struct ggml_context * ctx, const struct ggml_tensor * src);\ndef ggml_dup_tensor(ctx: ggml_context_p, src: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Create a new tensor with the same type and dimensions as the source tensor.\n    Parameters:\n        ctx: ggml context\n        src: source tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_dup_tensor(ctx, src)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_dup_tensor.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_dup_tensor.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_dup_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_view_tensor(struct ggml_context * ctx, struct ggml_tensor * src);\ndef ggml_view_tensor(ctx: ggml_context_p, src: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Create a new tensor with the same type, dimensions and data as the source tensor.\n    Parameters:\n        ctx: ggml context\n        src: source tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_dup_tensor.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_dup_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_view_tensor(struct ggml_context * ctx, struct ggml_tensor * src);\ndef ggml_view_tensor(ctx: ggml_context_p, src: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Create a new tensor with the same type, dimensions and data as the source tensor.\n    Parameters:\n        ctx: ggml context\n        src: source tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_view_tensor(ctx, src)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_tensor.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_tensor.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_view_tensor.restype = ctypes.POINTER(ggml_tensor)\n# // Context tensor enumeration and lookup\n# GGML_API struct ggml_tensor * ggml_get_first_tensor(struct ggml_context * ctx);\ndef ggml_get_first_tensor(ctx: ggml_context_p) -> ggml_tensor_p:\n    \"\"\"Get the first tensor from the ggml context.\n    Parameters:\n        ctx: ggml context\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_tensor.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_tensor.restype = ctypes.POINTER(ggml_tensor)\n# // Context tensor enumeration and lookup\n# GGML_API struct ggml_tensor * ggml_get_first_tensor(struct ggml_context * ctx);\ndef ggml_get_first_tensor(ctx: ggml_context_p) -> ggml_tensor_p:\n    \"\"\"Get the first tensor from the ggml context.\n    Parameters:\n        ctx: ggml context\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_get_first_tensor(ctx)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_first_tensor.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_first_tensor.argtypes = [ggml_context_p]\nlib.ggml_get_first_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_get_next_tensor (struct ggml_context * ctx, struct ggml_tensor * tensor);\ndef ggml_get_next_tensor(ctx: ggml_context_p, tensor: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Get the next tensor from the ggml context.\n    Parameters:\n        ctx: ggml context\n        tensor: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_first_tensor.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_first_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_get_next_tensor (struct ggml_context * ctx, struct ggml_tensor * tensor);\ndef ggml_get_next_tensor(ctx: ggml_context_p, tensor: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Get the next tensor from the ggml context.\n    Parameters:\n        ctx: ggml context\n        tensor: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_get_next_tensor(ctx, tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_next_tensor.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_next_tensor.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_get_next_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_get_tensor(struct ggml_context * ctx, const char * name);\ndef ggml_get_tensor(ctx: ggml_context_p, name: bytes) -> ggml_tensor_p:\n    \"\"\"Get a tensor from the ggml context by name.\n    Parameters:\n        ctx: ggml context\n        name: name of tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_next_tensor.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_next_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_get_tensor(struct ggml_context * ctx, const char * name);\ndef ggml_get_tensor(ctx: ggml_context_p, name: bytes) -> ggml_tensor_p:\n    \"\"\"Get a tensor from the ggml context by name.\n    Parameters:\n        ctx: ggml context\n        name: name of tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"\n    return lib.ggml_get_tensor(ctx, name)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_tensor.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_tensor.argtypes = [ggml_context_p, ctypes.c_char_p]\nlib.ggml_get_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_set_zero(struct ggml_tensor * tensor);\ndef ggml_set_zero(\n    tensor: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Zero all elements in a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_tensor.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_set_zero(struct ggml_tensor * tensor);\ndef ggml_set_zero(\n    tensor: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Zero all elements in a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:\n        Pointer to ggml_tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_zero.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_zero.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_set_zero.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_set_i32 (struct ggml_tensor * tensor, int32_t value);\ndef ggml_set_i32(\n    tensor: ggml_tensor_p,\n    value: Union[ctypes.c_int32, int],\n) -> ggml_tensor_p:\n    \"\"\"Set all elements in a tensor to the given integer value.\n    Parameters:\n        tensor: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_zero.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_zero.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_set_i32 (struct ggml_tensor * tensor, int32_t value);\ndef ggml_set_i32(\n    tensor: ggml_tensor_p,\n    value: Union[ctypes.c_int32, int],\n) -> ggml_tensor_p:\n    \"\"\"Set all elements in a tensor to the given integer value.\n    Parameters:\n        tensor: tensor\n        value: integer value",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_i32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_i32.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_int32]\nlib.ggml_set_i32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_set_f32 (struct ggml_tensor * tensor, float value);\ndef ggml_set_f32(\n    tensor: ggml_tensor_p,\n    value: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Set all elements in a tensor to the given float value.\n    Parameters:\n        tensor: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_i32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_i32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_set_f32 (struct ggml_tensor * tensor, float value);\ndef ggml_set_f32(\n    tensor: ggml_tensor_p,\n    value: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:\n    \"\"\"Set all elements in a tensor to the given float value.\n    Parameters:\n        tensor: tensor\n        value: float value",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_f32.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_float]\nlib.ggml_set_f32.restype = ctypes.POINTER(ggml_tensor)\n# // Converts a flat index into coordinates\n# GGML_API void    ggml_unravel_index(const struct ggml_tensor * tensor, int64_t i, int64_t * i0, int64_t * i1, int64_t * i2, int64_t * i3);\ndef ggml_unravel_index(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int64, int],\n    i0,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore\n    i1,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore\n    i2,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_f32.restype = ctypes.POINTER(ggml_tensor)\n# // Converts a flat index into coordinates\n# GGML_API void    ggml_unravel_index(const struct ggml_tensor * tensor, int64_t i, int64_t * i0, int64_t * i1, int64_t * i2, int64_t * i3);\ndef ggml_unravel_index(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int64, int],\n    i0,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore\n    i1,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore\n    i2,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore\n    i3,  # type: \"ctypes._Pointer(ctypes.c_int64)\" # type: ignore",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_unravel_index.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_unravel_index.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.POINTER(ctypes.c_int64),\n    ctypes.POINTER(ctypes.c_int64),\n    ctypes.POINTER(ctypes.c_int64),\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_unravel_index.restype = None\n# GGML_API int32_t ggml_get_i32_1d(const struct ggml_tensor * tensor, int i);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_unravel_index.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_unravel_index.restype = None\n# GGML_API int32_t ggml_get_i32_1d(const struct ggml_tensor * tensor, int i);\ndef ggml_get_i32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n) -> int:\n    \"\"\"Get the integer value of the i-th element in a 1-dimensional tensor.\n    Parameters:\n        tensor: tensor\n        i: index of element",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_i32_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_i32_1d.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_int]\nlib.ggml_get_i32_1d.restype = ctypes.c_int32\n# GGML_API void    ggml_set_i32_1d(const struct ggml_tensor * tensor, int i, int32_t value);\ndef ggml_set_i32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_int32, int],\n):\n    \"\"\"Set the integer value of the i-th element in a 1-dimensional tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_i32_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_i32_1d.restype = ctypes.c_int32\n# GGML_API void    ggml_set_i32_1d(const struct ggml_tensor * tensor, int i, int32_t value);\ndef ggml_set_i32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_int32, int],\n):\n    \"\"\"Set the integer value of the i-th element in a 1-dimensional tensor.\n    Parameters:\n        tensor: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_i32_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_i32_1d.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int32,\n]\nlib.ggml_set_i32_1d.restype = None\n# GGML_API int32_t ggml_get_i32_nd(const struct ggml_tensor * tensor, int i0, int i1, int i2, int i3);\ndef ggml_get_i32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_i32_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_i32_1d.restype = None\n# GGML_API int32_t ggml_get_i32_nd(const struct ggml_tensor * tensor, int i0, int i1, int i2, int i3);\ndef ggml_get_i32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n    i2: Union[ctypes.c_int, int],\n    i3: Union[ctypes.c_int, int],\n) -> int:\n    \"\"\"Get the integer value of the element at the given coordinates in a 4-dimensional tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_i32_nd.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_i32_nd.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_get_i32_nd.restype = ctypes.c_int32\n# GGML_API void    ggml_set_i32_nd(const struct ggml_tensor * tensor, int i0, int i1, int i2, int i3, int32_t value);\ndef ggml_set_i32_nd(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_i32_nd.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_i32_nd.restype = ctypes.c_int32\n# GGML_API void    ggml_set_i32_nd(const struct ggml_tensor * tensor, int i0, int i1, int i2, int i3, int32_t value);\ndef ggml_set_i32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n    i2: Union[ctypes.c_int, int],\n    i3: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_int32, int],\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_i32_nd.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_i32_nd.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int32,\n]\nlib.ggml_set_i32_nd.restype = None\n# GGML_API float   ggml_get_f32_1d(const struct ggml_tensor * tensor, int i);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_i32_nd.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_i32_nd.restype = None\n# GGML_API float   ggml_get_f32_1d(const struct ggml_tensor * tensor, int i);\ndef ggml_get_f32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n) -> float:\n    \"\"\"Get the float value of the i-th element in a 1-dimensional tensor.\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_f32_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_f32_1d.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_int]\nlib.ggml_get_f32_1d.restype = ctypes.c_float\n# GGML_API void    ggml_set_f32_1d(const struct ggml_tensor * tensor, int i, float value);\ndef ggml_set_f32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_float, float],\n):\n    \"\"\"Set the float value of the i-th element in a 1-dimensional tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_f32_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_f32_1d.restype = ctypes.c_float\n# GGML_API void    ggml_set_f32_1d(const struct ggml_tensor * tensor, int i, float value);\ndef ggml_set_f32_1d(\n    tensor: ggml_tensor_p,\n    i: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_float, float],\n):\n    \"\"\"Set the float value of the i-th element in a 1-dimensional tensor.\n    Parameters:\n        tensor: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_f32_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_f32_1d.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_float,\n]\nlib.ggml_set_f32_1d.restype = None\n# GGML_API float   ggml_get_f32_nd(const struct ggml_tensor * tensor, int i0, int i1, int i2, int i3);\ndef ggml_get_f32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_f32_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_f32_1d.restype = None\n# GGML_API float   ggml_get_f32_nd(const struct ggml_tensor * tensor, int i0, int i1, int i2, int i3);\ndef ggml_get_f32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n    i2: Union[ctypes.c_int, int],\n    i3: Union[ctypes.c_int, int],\n) -> float:\n    \"\"\"Get the float value of the element at the given coordinates in a 4-dimensional tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_f32_nd.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_f32_nd.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_get_f32_nd.restype = ctypes.c_float\n# GGML_API void    ggml_set_f32_nd(const struct ggml_tensor * tensor, int i0, int i1, int i2, int i3, float value);\ndef ggml_set_f32_nd(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_f32_nd.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_f32_nd.restype = ctypes.c_float\n# GGML_API void    ggml_set_f32_nd(const struct ggml_tensor * tensor, int i0, int i1, int i2, int i3, float value);\ndef ggml_set_f32_nd(\n    tensor: ggml_tensor_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n    i2: Union[ctypes.c_int, int],\n    i3: Union[ctypes.c_int, int],\n    value: Union[ctypes.c_float, float],\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_f32_nd.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_f32_nd.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_float,\n]\nlib.ggml_set_f32_nd.restype = None\n# GGML_API void *  ggml_get_data    (const struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_f32_nd.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_f32_nd.restype = None\n# GGML_API void *  ggml_get_data    (const struct ggml_tensor * tensor);\ndef ggml_get_data(\n    tensor: ggml_tensor_p,\n) -> Optional[ctypes.c_void_p]:\n    \"\"\"Get the data pointer of a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:\n        Pointer to data, or None if tensor has no data\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_data.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_data.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_get_data.restype = ctypes.c_void_p\n# GGML_API float * ggml_get_data_f32(const struct ggml_tensor * tensor);\ndef ggml_get_data_f32(\n    tensor: ggml_tensor_p,\n) -> Optional[CFloatArray]:\n    \"\"\"Get the data pointer of a tensor as a float array.\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_data.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_data.restype = ctypes.c_void_p\n# GGML_API float * ggml_get_data_f32(const struct ggml_tensor * tensor);\ndef ggml_get_data_f32(\n    tensor: ggml_tensor_p,\n) -> Optional[CFloatArray]:\n    \"\"\"Get the data pointer of a tensor as a float array.\n    Parameters:\n        tensor: tensor\n    Returns:\n        (Optional[ctypes.Array[ctypes.c_float]]): array of float to data, or None if tensor has no data",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_data_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_data_f32.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_get_data_f32.restype = ctypes.POINTER(ctypes.c_float)\n# GGML_API enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor * tensor);\ndef ggml_get_unary_op(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the unary operation of a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_data_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_data_f32.restype = ctypes.POINTER(ctypes.c_float)\n# GGML_API enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor * tensor);\ndef ggml_get_unary_op(\n    tensor: ggml_tensor_p,\n) -> int:\n    \"\"\"Get the unary operation of a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:\n        unary operation\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_unary_op.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_unary_op.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_get_unary_op.restype = ctypes.c_int\n# GGML_API const char *         ggml_get_name(const struct ggml_tensor * tensor);\ndef ggml_get_name(\n    tensor: ggml_tensor_p,\n) -> bytes:\n    \"\"\"Get the name of a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_unary_op.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_unary_op.restype = ctypes.c_int\n# GGML_API const char *         ggml_get_name(const struct ggml_tensor * tensor);\ndef ggml_get_name(\n    tensor: ggml_tensor_p,\n) -> bytes:\n    \"\"\"Get the name of a tensor.\n    Parameters:\n        tensor: tensor\n    Returns:\n        name of tensor\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_name.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_name.argtypes = [ctypes.POINTER(ggml_tensor)]\nlib.ggml_get_name.restype = ctypes.c_char_p\n# GGML_API struct ggml_tensor * ggml_set_name(struct ggml_tensor * tensor, const char * name);\ndef ggml_set_name(\n    tensor: ggml_tensor_p,\n    name: bytes,\n) -> ggml_tensor_p:\n    \"\"\"Set the name of a tensor.\n    Parameters:\n        tensor: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_name.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_name.restype = ctypes.c_char_p\n# GGML_API struct ggml_tensor * ggml_set_name(struct ggml_tensor * tensor, const char * name);\ndef ggml_set_name(\n    tensor: ggml_tensor_p,\n    name: bytes,\n) -> ggml_tensor_p:\n    \"\"\"Set the name of a tensor.\n    Parameters:\n        tensor: tensor\n        name: name to set tensor to",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_name.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_name.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_char_p]\nlib.ggml_set_name.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_format_name(struct ggml_tensor * tensor, const char * fmt, ...);\ndef ggml_format_name(\n    tensor: ggml_tensor_p,\n    fmt: bytes,\n    *args: Sequence[Union[bool, int, float, str]],\n) -> ggml_tensor_p:\n    \"\"\"Format the name of a tensor using the given format c string and arguments.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_name.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_name.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_format_name(struct ggml_tensor * tensor, const char * fmt, ...);\ndef ggml_format_name(\n    tensor: ggml_tensor_p,\n    fmt: bytes,\n    *args: Sequence[Union[bool, int, float, str]],\n) -> ggml_tensor_p:\n    \"\"\"Format the name of a tensor using the given format c string and arguments.\n    Parameters:\n        tensor: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_format_name.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_format_name.argtypes = [ctypes.POINTER(ggml_tensor), ctypes.c_char_p]\nlib.ggml_format_name.restype = ctypes.POINTER(ggml_tensor)\n# //\n# // operations on tensors with backpropagation\n# //\n# GGML_API struct ggml_tensor * ggml_dup(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_dup(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_dup(ctx, a)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_format_name.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_format_name.restype = ctypes.POINTER(ggml_tensor)\n# //\n# // operations on tensors with backpropagation\n# //\n# GGML_API struct ggml_tensor * ggml_dup(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_dup(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_dup(ctx, a)\nlib.ggml_dup.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_dup.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_dup.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_dup.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_dup_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_dup_inplace(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_dup_inplace(ctx, a)\nlib.ggml_dup_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_dup_inplace.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_dup.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_dup.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_dup_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_dup_inplace(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_dup_inplace(ctx, a)\nlib.ggml_dup_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_dup_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_dup_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_dup_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_dup_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_add(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_dup_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_dup_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_add(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_add.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_add_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_add_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add_cast(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add_cast(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         enum   ggml_type      type);\ndef ggml_add_cast(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add_cast.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add_cast.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_add_cast.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add1(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add_cast.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add_cast.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add1(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_add1(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add1.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add1.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_add1.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add1_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add1.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add1.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add1_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_add1_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add1_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add1_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_add1_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // dst = a\n# // view(dst, nb1, nb2, nb3, offset) += b\n# // return dst\n# GGML_API struct ggml_tensor * ggml_acc(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add1_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add1_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // dst = a\n# // view(dst, nb1, nb2, nb3, offset) += b\n# // return dst\n# GGML_API struct ggml_tensor * ggml_acc(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         size_t                nb1,\n#         size_t                nb2,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_acc.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_acc.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_acc.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_acc.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_acc.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_acc_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         size_t                nb1,\n#         size_t                nb2,\n#         size_t                nb3,\n#         size_t                offset);\ndef ggml_acc_inplace(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_acc_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_acc_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_acc_inplace.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_acc_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_acc_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sub(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_sub(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sub.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sub.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_sub.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sub_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sub.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sub.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sub_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_sub_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sub_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sub_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_sub_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_mul(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sub_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sub_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_mul(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_mul(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mul.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mul.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_mul.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_mul_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mul.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mul.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_mul_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_mul_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mul_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mul_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_mul_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_div(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mul_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mul_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_div(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_div(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_div.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_div.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_div.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_div_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_div.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_div.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_div_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_div_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_div_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_div_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_div_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sqr(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sqr(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_div_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_div_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sqr(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sqr(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square all elements in a tensor and return the result.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sqr.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sqr.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sqr.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sqr_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sqr_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sqr.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sqr.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sqr_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sqr_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sqr_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sqr_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sqr_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sqrt(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sqrt(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square root all elements in a tensor and return the result.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sqr_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sqr_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sqrt(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sqrt(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square root all elements in a tensor and return the result.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sqrt.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sqrt.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sqrt.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sqrt_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sqrt_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square root all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sqrt.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sqrt.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sqrt_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sqrt_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Square root all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sqrt_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sqrt_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sqrt_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_log(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_log(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the natural logarithm of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sqrt_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sqrt_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_log(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_log(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the natural logarithm of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_log.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_log.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_log.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_log_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_log_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Take the natural logarithm of all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_log.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_log.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_log_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_log_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Take the natural logarithm of all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_log_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_log_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_log_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // return scalar\n# GGML_API struct ggml_tensor * ggml_sum(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sum(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Sum all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_log_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_log_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // return scalar\n# GGML_API struct ggml_tensor * ggml_sum(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sum(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Sum all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sum.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sum.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sum.restype = ctypes.POINTER(ggml_tensor)\n# // sums along rows, with input shape [a,b,c,d] return shape [1,b,c,d]\n# GGML_API struct ggml_tensor * ggml_sum_rows(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sum_rows(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Sum all elements in a tensor along the first axis and return the result.\n    sums along rows, with input shape [a,b,c,d] return shape [1,b,c,d]\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sum.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sum.restype = ctypes.POINTER(ggml_tensor)\n# // sums along rows, with input shape [a,b,c,d] return shape [1,b,c,d]\n# GGML_API struct ggml_tensor * ggml_sum_rows(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sum_rows(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Sum all elements in a tensor along the first axis and return the result.\n    sums along rows, with input shape [a,b,c,d] return shape [1,b,c,d]\n    Parameters:\n        ctx: ggml context",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sum_rows.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sum_rows.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sum_rows.restype = ctypes.POINTER(ggml_tensor)\n# // mean along rows\n# GGML_API struct ggml_tensor * ggml_mean(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_mean(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the mean of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sum_rows.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sum_rows.restype = ctypes.POINTER(ggml_tensor)\n# // mean along rows\n# GGML_API struct ggml_tensor * ggml_mean(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_mean(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the mean of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mean.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mean.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_mean.restype = ctypes.POINTER(ggml_tensor)\n# // argmax along rows\n# GGML_API struct ggml_tensor * ggml_argmax(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_argmax(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the argmax of all elements in a tensor and return the result.\n    argmax along rows\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mean.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mean.restype = ctypes.POINTER(ggml_tensor)\n# // argmax along rows\n# GGML_API struct ggml_tensor * ggml_argmax(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_argmax(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the argmax of all elements in a tensor and return the result.\n    argmax along rows\n    Parameters:\n        ctx: ggml context",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_argmax.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_argmax.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_argmax.restype = ctypes.POINTER(ggml_tensor)\n# // if a is the same shape as b, and a is not parameter, return a\n# // otherwise, return a new tensor: repeat(a) to fit in b\n# GGML_API struct ggml_tensor * ggml_repeat(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_repeat(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_argmax.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_argmax.restype = ctypes.POINTER(ggml_tensor)\n# // if a is the same shape as b, and a is not parameter, return a\n# // otherwise, return a new tensor: repeat(a) to fit in b\n# GGML_API struct ggml_tensor * ggml_repeat(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_repeat(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_repeat.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_repeat.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_repeat.restype = ctypes.POINTER(ggml_tensor)\n# // sums repetitions in a into shape of b\n# GGML_API struct ggml_tensor * ggml_repeat_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_repeat.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_repeat.restype = ctypes.POINTER(ggml_tensor)\n# // sums repetitions in a into shape of b\n# GGML_API struct ggml_tensor * ggml_repeat_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_repeat_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_repeat_back.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_repeat_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_repeat_back.restype = ctypes.POINTER(ggml_tensor)\n# // concat a and b on dim 2\n# // used in stable-diffusion\n# GGML_API struct ggml_tensor * ggml_concat(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_repeat_back.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_repeat_back.restype = ctypes.POINTER(ggml_tensor)\n# // concat a and b on dim 2\n# // used in stable-diffusion\n# GGML_API struct ggml_tensor * ggml_concat(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_concat(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_concat.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_concat.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_concat.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_abs(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_abs(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_concat.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_concat.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_abs(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_abs(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Take the absolute value of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_abs.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_abs.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_abs.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_abs_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_abs_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Take the absolute value of all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_abs.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_abs.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_abs_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_abs_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Take the absolute value of all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_abs_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_abs_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_abs_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sgn(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sgn(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Get the sign of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_abs_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_abs_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sgn(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sgn(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Get the sign of all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sgn.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sgn.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sgn.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sgn_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sgn_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Get the sign of all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sgn.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sgn.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_sgn_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_sgn_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Get the sign of all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sgn_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sgn_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_sgn_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_neg(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_neg(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Negate all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_sgn_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_sgn_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_neg(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_neg(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Negate all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_neg.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_neg.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_neg.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_neg_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_neg_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Negate all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_neg.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_neg.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_neg_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_neg_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Negate all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_neg_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_neg_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_neg_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_step(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_step(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_step(ctx, a)\nlib.ggml_step.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_step.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_tanh(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_neg_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_neg_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_step(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_step(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_step(ctx, a)\nlib.ggml_step.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_step.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_tanh(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_step.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_step.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_step.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_tanh(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_tanh(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the tanh activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_step.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_step.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_tanh(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_tanh(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the tanh activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tanh.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tanh.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_tanh.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_tanh_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_tanh_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the tanh activation function to all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tanh.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tanh.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_tanh_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_tanh_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the tanh activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tanh_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tanh_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_tanh_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_elu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_elu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the ELU activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tanh_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tanh_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_elu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_elu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the ELU activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_elu.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_elu.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_elu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_elu_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_elu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the ELU activation function to all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_elu.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_elu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_elu_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_elu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the ELU activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_elu_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_elu_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_elu_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_relu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_relu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the ReLU activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_elu_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_elu_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_relu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_relu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the ReLU activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_relu.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_relu.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_relu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_leaky_relu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a, float negative_slope, bool inplace);\ndef ggml_leaky_relu(\n    ctx: ggml_context_p, a: ggml_tensor_p, negative_slope: float, inplace: bool\n) -> ggml_tensor_p:\n    \"\"\"Apply the Leaky ReLU activation function to all elements in a tensor and return the result.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_relu.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_relu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_leaky_relu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a, float negative_slope, bool inplace);\ndef ggml_leaky_relu(\n    ctx: ggml_context_p, a: ggml_tensor_p, negative_slope: float, inplace: bool\n) -> ggml_tensor_p:\n    \"\"\"Apply the Leaky ReLU activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_leaky_relu.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_leaky_relu.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_float,\n    ctypes.c_bool,\n]\nlib.ggml_leaky_relu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_relu_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_leaky_relu.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_leaky_relu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_relu_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_relu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the ReLU activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_relu_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_relu_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_relu_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_gelu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_gelu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_relu_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_relu_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_gelu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_gelu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gelu.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gelu.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_gelu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_gelu_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_gelu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gelu.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gelu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_gelu_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_gelu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gelu_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gelu_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_gelu_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_gelu_quick(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_gelu_quick(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gelu_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gelu_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_gelu_quick(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_gelu_quick(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gelu_quick.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gelu_quick.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_gelu_quick.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_gelu_quick_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_gelu_quick_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gelu_quick.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gelu_quick.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_gelu_quick_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_gelu_quick_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the Gaussian Error Linear Unit activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gelu_quick_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gelu_quick_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_gelu_quick_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_silu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_silu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the Sigmoid Linear Unit activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gelu_quick_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gelu_quick_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_silu(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_silu(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Apply the Sigmoid Linear Unit activation function to all elements in a tensor and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor\n    Returns:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_silu.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_silu.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_silu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_silu_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_silu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the Sigmoid Linear Unit activation function to all elements in a tensor and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_silu.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_silu.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_silu_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_silu_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Apply the Sigmoid Linear Unit activation function to all elements in a tensor and store the result in the first tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_silu_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_silu_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_silu_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // a - x\n# // b - dy\n# GGML_API struct ggml_tensor * ggml_silu_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_silu_back(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_silu_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_silu_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // a - x\n# // b - dy\n# GGML_API struct ggml_tensor * ggml_silu_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_silu_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_silu_back.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_silu_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_silu_back.restype = ctypes.POINTER(ggml_tensor)\n# // normalize along rows\n# GGML_API struct ggml_tensor * ggml_norm(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_silu_back.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_silu_back.restype = ctypes.POINTER(ggml_tensor)\n# // normalize along rows\n# GGML_API struct ggml_tensor * ggml_norm(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a\n#         float                eps);\ndef ggml_norm(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_norm.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_norm.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor), ctypes.c_float]\nlib.ggml_norm.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_norm_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a\n#         float                eps);\ndef ggml_norm_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_norm.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_norm.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_norm_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a\n#         float                eps);\ndef ggml_norm_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_norm_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_norm_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_float,\n]\nlib.ggml_norm_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_rms_norm(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         float                 eps);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_norm_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_norm_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_rms_norm(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         float                 eps);\ndef ggml_rms_norm(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rms_norm.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rms_norm.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_float,\n]\nlib.ggml_rms_norm.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_rms_norm_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         float                 eps);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rms_norm.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rms_norm.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_rms_norm_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         float                 eps);\ndef ggml_rms_norm_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    eps: Union[ctypes.c_float, float],\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rms_norm_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rms_norm_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_float,\n]\nlib.ggml_rms_norm_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // group normalize along ne0*ne1*n_groups\n# // used in stable-diffusion\n# // TODO: eps is hardcoded to 1e-6 for now\n# GGML_API struct ggml_tensor * ggml_group_norm(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rms_norm_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rms_norm_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // group normalize along ne0*ne1*n_groups\n# // used in stable-diffusion\n# // TODO: eps is hardcoded to 1e-6 for now\n# GGML_API struct ggml_tensor * ggml_group_norm(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_groups);\ndef ggml_group_norm(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_group_norm.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_group_norm.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_group_norm.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_group_norm_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_groups);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_group_norm.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_group_norm.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_group_norm_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_groups);\ndef ggml_group_norm_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_groups: int,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_group_norm_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_group_norm_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_group_norm_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // a - x\n# // b - dy\n# GGML_API struct ggml_tensor * ggml_rms_norm_back(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_group_norm_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_group_norm_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // a - x\n# // b - dy\n# GGML_API struct ggml_tensor * ggml_rms_norm_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b\n#         float                 eps);\ndef ggml_rms_norm_back(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rms_norm_back.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rms_norm_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_float,\n]\nlib.ggml_rms_norm_back.restype = ctypes.POINTER(ggml_tensor)\n# // A: k columns, n rows => [ne03, ne02, n, k]\n# // B: k columns, m rows  (i.e. we transpose it internally) => [ne03 * x, ne02 * y, m, k]\n# // result is n columns, m rows => [ne03 * x, ne02 * y, m, n]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rms_norm_back.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rms_norm_back.restype = ctypes.POINTER(ggml_tensor)\n# // A: k columns, n rows => [ne03, ne02, n, k]\n# // B: k columns, m rows  (i.e. we transpose it internally) => [ne03 * x, ne02 * y, m, k]\n# // result is n columns, m rows => [ne03 * x, ne02 * y, m, n]\n# GGML_API struct ggml_tensor * ggml_mul_mat(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_mul_mat(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mul_mat.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mul_mat.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_mul_mat.restype = ctypes.POINTER(ggml_tensor)\n# // indirect matrix multiplication\n# //  ggml_mul_mat_id(ctx, as, ids, id, b) ~= ggml_mul_mat(as[ids[id]], b)\n# GGML_API struct ggml_tensor * ggml_mul_mat_id(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mul_mat.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mul_mat.restype = ctypes.POINTER(ggml_tensor)\n# // indirect matrix multiplication\n# //  ggml_mul_mat_id(ctx, as, ids, id, b) ~= ggml_mul_mat(as[ids[id]], b)\n# GGML_API struct ggml_tensor * ggml_mul_mat_id(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * const as[],\n#         int                   n_as,\n#         struct ggml_tensor  * ids,\n#         int                   id,\n#         struct ggml_tensor  * b);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mul_mat_id.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mul_mat_id.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ctypes.POINTER(ggml_tensor)),\n    ctypes.c_int,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_mul_mat_id.restype = ctypes.POINTER(ggml_tensor)\n# // A: m columns, n rows,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_mul_mat_id.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_mul_mat_id.restype = ctypes.POINTER(ggml_tensor)\n# // A: m columns, n rows,\n# // B: p columns, n rows,\n# // result is m columns, p rows\n# GGML_API struct ggml_tensor * ggml_out_prod(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_out_prod(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_out_prod.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_out_prod.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_out_prod.restype = ctypes.POINTER(ggml_tensor)\n# //\n# // operations on tensors without backpropagation\n# //\n# GGML_API struct ggml_tensor * ggml_scale(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_out_prod.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_out_prod.restype = ctypes.POINTER(ggml_tensor)\n# //\n# // operations on tensors without backpropagation\n# //\n# GGML_API struct ggml_tensor * ggml_scale(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_scale(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_scale.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_scale.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_scale.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_scale_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_scale.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_scale.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_scale_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_scale_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_scale_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_scale_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_scale_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // b -> view(a,offset,nb1,nb2,3), return modified a\n# GGML_API struct ggml_tensor * ggml_set(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_scale_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_scale_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // b -> view(a,offset,nb1,nb2,3), return modified a\n# GGML_API struct ggml_tensor * ggml_set(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         size_t                nb1,\n#         size_t                nb2,\n#         size_t                nb3,\n#         size_t                offset);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_set.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set.restype = ctypes.POINTER(ggml_tensor)\n# // b -> view(a,offset,nb1,nb2,3), return view(a)\n# GGML_API struct ggml_tensor * ggml_set_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         size_t                nb1,\n#         size_t                nb2,\n#         size_t                nb3,\n#         size_t                offset);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_set_inplace.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_set_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         size_t                offset);\ndef ggml_set_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_size_t,\n]\nlib.ggml_set_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_set_1d_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_set_1d_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         size_t                offset);\ndef ggml_set_1d_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_1d_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_1d_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_size_t,\n]\nlib.ggml_set_1d_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // b -> view(a,offset,nb1,nb2,3), return modified a\n# GGML_API struct ggml_tensor * ggml_set_2d(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_1d_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_1d_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // b -> view(a,offset,nb1,nb2,3), return modified a\n# GGML_API struct ggml_tensor * ggml_set_2d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         size_t                nb1,\n#         size_t                offset);\ndef ggml_set_2d(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_2d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_2d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_set_2d.restype = ctypes.POINTER(ggml_tensor)\n# // b -> view(a,offset,nb1,nb2,3), return view(a)\n# GGML_API struct ggml_tensor * ggml_set_2d_inplace(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_2d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_2d.restype = ctypes.POINTER(ggml_tensor)\n# // b -> view(a,offset,nb1,nb2,3), return view(a)\n# GGML_API struct ggml_tensor * ggml_set_2d_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         size_t                nb1,\n#         size_t                offset);\ndef ggml_set_2d_inplace(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_2d_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_2d_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_set_2d_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // a -> b, return view(b)\n# GGML_API struct ggml_tensor * ggml_cpy(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_2d_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_2d_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // a -> b, return view(b)\n# GGML_API struct ggml_tensor * ggml_cpy(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_cpy(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpy.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpy.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_cpy.restype = ctypes.POINTER(ggml_tensor)\n# // a -> b, in-place, return view(b)\n# GGML_API struct ggml_tensor * ggml_cpy_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpy.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpy.restype = ctypes.POINTER(ggml_tensor)\n# // a -> b, in-place, return view(b)\n# GGML_API struct ggml_tensor * ggml_cpy_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_cpy_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpy_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpy_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_cpy_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // make contiguous\n# GGML_API struct ggml_tensor * ggml_cont(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpy_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpy_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // make contiguous\n# GGML_API struct ggml_tensor * ggml_cont(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_cont(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Make a tensor contiguous and return the result.\n    Parameters:\n        ctx: ggml context\n        a: tensor",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_cont.restype = ctypes.POINTER(ggml_tensor)\n# // make contiguous, in-place\n# GGML_API struct ggml_tensor * ggml_cont_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_cont_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont.restype = ctypes.POINTER(ggml_tensor)\n# // make contiguous, in-place\n# GGML_API struct ggml_tensor * ggml_cont_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_cont_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n) -> ggml_tensor_p:\n    \"\"\"Make a tensor contiguous and store the result in the first tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_cont_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // make contiguous, with new shape\n# GGML_API struct ggml_tensor * ggml_cont_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0);\ndef ggml_cont_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // make contiguous, with new shape\n# GGML_API struct ggml_tensor * ggml_cont_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0);\ndef ggml_cont_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n]\nlib.ggml_cont_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_cont_2d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_cont_2d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         int64_t               ne1);\ndef ggml_cont_2d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_2d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_2d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_int64,\n]\nlib.ggml_cont_2d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_cont_3d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_2d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_2d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_cont_3d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         int64_t               ne1,\n#         int64_t               ne2);\ndef ggml_cont_3d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_3d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_3d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n]\nlib.ggml_cont_3d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_cont_4d(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_3d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_3d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_cont_4d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         int64_t               ne1,\n#         int64_t               ne2,\n#         int64_t               ne3);\ndef ggml_cont_4d(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_4d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_4d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n]\nlib.ggml_cont_4d.restype = ctypes.POINTER(ggml_tensor)\n# // return view(a), b specifies the new shape",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cont_4d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cont_4d.restype = ctypes.POINTER(ggml_tensor)\n# // return view(a), b specifies the new shape\n# // TODO: when we start computing gradient, make a copy instead of view\n# GGML_API struct ggml_tensor * ggml_reshape(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_reshape(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_reshape.restype = ctypes.POINTER(ggml_tensor)\n# // return view(a)\n# // TODO: when we start computing gradient, make a copy instead of view\n# GGML_API struct ggml_tensor * ggml_reshape_1d(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape.restype = ctypes.POINTER(ggml_tensor)\n# // return view(a)\n# // TODO: when we start computing gradient, make a copy instead of view\n# GGML_API struct ggml_tensor * ggml_reshape_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0);\ndef ggml_reshape_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n]\nlib.ggml_reshape_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_reshape_2d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_reshape_2d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         int64_t               ne1);\ndef ggml_reshape_2d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    ne0: Union[ctypes.c_int64, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape_2d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape_2d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_int64,\n]\nlib.ggml_reshape_2d.restype = ctypes.POINTER(ggml_tensor)\n# // return view(a)\n# // TODO: when we start computing gradient, make a copy instead of view\n# GGML_API struct ggml_tensor * ggml_reshape_3d(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape_2d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape_2d.restype = ctypes.POINTER(ggml_tensor)\n# // return view(a)\n# // TODO: when we start computing gradient, make a copy instead of view\n# GGML_API struct ggml_tensor * ggml_reshape_3d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         int64_t               ne1,\n#         int64_t               ne2);\ndef ggml_reshape_3d(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape_3d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape_3d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n]\nlib.ggml_reshape_3d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_reshape_4d(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape_3d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape_3d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_reshape_4d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         int64_t               ne1,\n#         int64_t               ne2,\n#         int64_t               ne3);\ndef ggml_reshape_4d(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape_4d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape_4d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n]\nlib.ggml_reshape_4d.restype = ctypes.POINTER(ggml_tensor)\n# // offset in bytes",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_reshape_4d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_reshape_4d.restype = ctypes.POINTER(ggml_tensor)\n# // offset in bytes\n# GGML_API struct ggml_tensor * ggml_view_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         size_t                offset);\ndef ggml_view_1d(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_size_t,\n]\nlib.ggml_view_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_view_2d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_view_2d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         int64_t               ne1,\n#         size_t                nb1, // row stride in bytes\n#         size_t                offset);\ndef ggml_view_2d(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_2d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_2d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_view_2d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_view_3d(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_2d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_2d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_view_3d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         int64_t               ne1,\n#         int64_t               ne2,\n#         size_t                nb1, // row   stride in bytes\n#         size_t                nb2, // slice stride in bytes\n#         size_t                offset);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_3d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_3d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_3d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_3d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_view_4d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int64_t               ne0,\n#         int64_t               ne1,\n#         int64_t               ne2,\n#         int64_t               ne3,\n#         size_t                nb1, // row   stride in bytes\n#         size_t                nb2, // slice stride in bytes",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_4d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_4d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_int64,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_size_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_view_4d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_view_4d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_permute(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   axis0,\n#         int                   axis1,\n#         int                   axis2,\n#         int                   axis3);\ndef ggml_permute(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_permute.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_permute.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_permute.restype = ctypes.POINTER(ggml_tensor)\n# // alias for ggml_permute(ctx, a, 1, 0, 2, 3)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_permute.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_permute.restype = ctypes.POINTER(ggml_tensor)\n# // alias for ggml_permute(ctx, a, 1, 0, 2, 3)\n# GGML_API struct ggml_tensor * ggml_transpose(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_transpose(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    \"\"\"Transpose *the first two dimensions* of a tensor and return the result.\n    alias for `ggml_permute(ctx, a, 1, 0, 2, 3)`\n    Parameters:\n        ctx: ggml context",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_transpose.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_transpose.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_transpose.restype = ctypes.POINTER(ggml_tensor)\n# // supports 3D: a->ne[2] == b->ne[1]\n# GGML_API struct ggml_tensor * ggml_get_rows(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_get_rows(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_transpose.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_transpose.restype = ctypes.POINTER(ggml_tensor)\n# // supports 3D: a->ne[2] == b->ne[1]\n# GGML_API struct ggml_tensor * ggml_get_rows(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_get_rows(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_rows.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_rows.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_get_rows.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_get_rows_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_rows.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_rows.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_get_rows_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         struct ggml_tensor  * c);\ndef ggml_get_rows_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_rows_back.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_rows_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_get_rows_back.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_diag(\n#     struct ggml_context     * ctx,\n#     struct ggml_tensor      * a);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_rows_back.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_rows_back.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_diag(\n#     struct ggml_context     * ctx,\n#     struct ggml_tensor      * a);\ndef ggml_diag(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_diag(ctx, a)\nlib.ggml_diag.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_diag.restype = ctypes.POINTER(ggml_tensor)\n# // set elements above the diagonal to -INF\n# GGML_API struct ggml_tensor * ggml_diag_mask_inf(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_diag.restype = ctypes.POINTER(ggml_tensor)\n# // set elements above the diagonal to -INF\n# GGML_API struct ggml_tensor * ggml_diag_mask_inf(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_past);\ndef ggml_diag_mask_inf(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag.restype = ctypes.POINTER(ggml_tensor)\n# // set elements above the diagonal to -INF\n# GGML_API struct ggml_tensor * ggml_diag_mask_inf(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_past);\ndef ggml_diag_mask_inf(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_past: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag_mask_inf.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag_mask_inf.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_diag_mask_inf.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_diag_mask_inf_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag_mask_inf.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag_mask_inf.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_diag_mask_inf_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_past);\ndef ggml_diag_mask_inf_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_past: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag_mask_inf_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag_mask_inf_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_diag_mask_inf_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // set elements above the diagonal to 0\n# GGML_API struct ggml_tensor * ggml_diag_mask_zero(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag_mask_inf_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag_mask_inf_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // set elements above the diagonal to 0\n# GGML_API struct ggml_tensor * ggml_diag_mask_zero(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_past);\ndef ggml_diag_mask_zero(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_past: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag_mask_zero.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag_mask_zero.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_diag_mask_zero.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_diag_mask_zero_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag_mask_zero.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag_mask_zero.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_diag_mask_zero_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_past);\ndef ggml_diag_mask_zero_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    n_past: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag_mask_zero_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag_mask_zero_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_diag_mask_zero_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_soft_max(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_soft_max(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_diag_mask_zero_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_diag_mask_zero_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_soft_max(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_soft_max(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_soft_max(ctx, a)\nlib.ggml_soft_max.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_soft_max.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_soft_max_inplace(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_soft_max.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_soft_max_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_soft_max_inplace(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_soft_max_inplace(ctx, a)\nlib.ggml_soft_max_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_soft_max_inplace.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_soft_max_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a);\ndef ggml_soft_max_inplace(ctx: ggml_context_p, a: ggml_tensor_p) -> ggml_tensor_p:\n    return lib.ggml_soft_max_inplace(ctx, a)\nlib.ggml_soft_max_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_soft_max_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // fused soft_max(a*scale + mask)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max_inplace.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_soft_max_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // fused soft_max(a*scale + mask)\n# // mask is optional\n# GGML_API struct ggml_tensor * ggml_soft_max_ext(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * mask,\n#         float                 scale);\ndef ggml_soft_max_ext(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // fused soft_max(a*scale + mask)\n# // mask is optional\n# GGML_API struct ggml_tensor * ggml_soft_max_ext(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * mask,\n#         float                 scale);\ndef ggml_soft_max_ext(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max_ext.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max_ext.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_float,\n]\nlib.ggml_soft_max_ext.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_soft_max_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max_ext.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max_ext.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_soft_max_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_soft_max_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max_back.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_soft_max_back.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_soft_max_back_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max_back.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max_back.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_soft_max_back_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b);\ndef ggml_soft_max_back_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max_back_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max_back_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_soft_max_back_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // rotary position embedding\n# // if mode & 1 == 1, skip n_past elements (DEPRECATED)\n# // if mode & 2 == 1, GPT-NeoX style\n# // if mode & 4 == 1, ChatGLM style",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_soft_max_back_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_soft_max_back_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // rotary position embedding\n# // if mode & 1 == 1, skip n_past elements (DEPRECATED)\n# // if mode & 2 == 1, GPT-NeoX style\n# // if mode & 4 == 1, ChatGLM style\n# //\n# // b is an int32 vector with size a->ne[2], it contains the positions\n# GGML_API struct ggml_tensor * ggml_rope(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_rope.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_rope_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   n_dims,\n#         int                   mode,\n#         int                   n_ctx);\ndef ggml_rope_inplace(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_rope_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // custom RoPE",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // custom RoPE\n# GGML_API struct ggml_tensor * ggml_rope_custom(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   n_dims,\n#         int                   mode,\n#         int                   n_ctx,\n#         int                   n_orig_ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_custom.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_custom.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_float,\n    ctypes.c_float,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_custom.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_custom.restype = ctypes.POINTER(ggml_tensor)\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_rope_custom_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   n_dims,\n#         int                   mode,\n#         int                   n_ctx,\n#         int                   n_orig_ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_custom_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_custom_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_float,\n    ctypes.c_float,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_custom_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_custom_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // compute correction dims for YaRN RoPE scaling\n# void ggml_rope_yarn_corr_dims(\n#     int n_dims, int n_orig_ctx, float freq_base, float beta_fast, float beta_slow, float dims[2]);\ndef ggml_rope_yarn_corr_dims(\n    n_dims: Union[ctypes.c_int, int],\n    n_orig_ctx: Union[ctypes.c_int, int],\n    freq_base: Union[ctypes.c_float, float],\n    beta_fast: Union[ctypes.c_float, float],\n    beta_slow: Union[ctypes.c_float, float],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_yarn_corr_dims.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_yarn_corr_dims.argtypes = [\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_float,\n    ctypes.c_float,\n    ctypes.c_float,\n    ctypes.POINTER(ctypes.c_float),\n]\nlib.ggml_rope_yarn_corr_dims.restype = None\n# // xPos RoPE, in-place, returns view(a)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_yarn_corr_dims.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_yarn_corr_dims.restype = None\n# // xPos RoPE, in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_rope_xpos_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   n_dims,\n#         float                 base,\n#         bool                  down);\ndef ggml_rope_xpos_inplace(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_xpos_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_xpos_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_float,\n    ctypes.c_bool,\n]\nlib.ggml_rope_xpos_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // rotary position embedding backward, i.e compute dx from dy",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_xpos_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_xpos_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // rotary position embedding backward, i.e compute dx from dy\n# // a - dy\n# GGML_API struct ggml_tensor * ggml_rope_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   n_dims,\n#         int                   mode,\n#         int                   n_ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_back.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_float,\n    ctypes.c_float,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_rope_back.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_rope_back.restype = ctypes.POINTER(ggml_tensor)\n# // alibi position embedding\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_alibi(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   n_past,\n#         int                   n_head,\n#         float                 bias_max);\ndef ggml_alibi(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_alibi.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_alibi.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_float,\n]\nlib.ggml_alibi.restype = ctypes.POINTER(ggml_tensor)\n# // clamp\n# // in-place, returns view(a)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_alibi.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_alibi.restype = ctypes.POINTER(ggml_tensor)\n# // clamp\n# // in-place, returns view(a)\n# GGML_API struct ggml_tensor * ggml_clamp(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         float                 min,\n#         float                 max);\ndef ggml_clamp(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_clamp.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_clamp.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_float,\n    ctypes.c_float,\n]\nlib.ggml_clamp.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_im2col(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_clamp.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_clamp.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_im2col(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                  s0,\n#         int                  s1,\n#         int                  p0,\n#         int                  p1,\n#         int                  d0,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_im2col.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_im2col.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_im2col.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_im2col.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_conv_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   s0,  // stride\n#         int                   p0,  // padding\n#         int                   d0); // dilation\ndef ggml_conv_1d(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_conv_1d.restype = ctypes.POINTER(ggml_tensor)\n# // conv_1d with padding = half",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_1d.restype = ctypes.POINTER(ggml_tensor)\n# // conv_1d with padding = half\n# // alias for ggml_conv_1d(a, b, s, a->ne[0]/2, d)\n# GGML_API struct ggml_tensor* ggml_conv_1d_ph(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   s,\n#         int                   d);\ndef ggml_conv_1d_ph(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_1d_ph.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_1d_ph.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_conv_1d_ph.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_conv_transpose_1d(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_1d_ph.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_1d_ph.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_conv_transpose_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   s0,\n#         int                   p0,\n#         int                   d0);\ndef ggml_conv_transpose_1d(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_transpose_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_transpose_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_conv_transpose_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_conv_2d(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_transpose_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_transpose_1d.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_conv_2d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   s0,\n#         int                   s1,\n#         int                   p0,\n#         int                   p1,\n#         int                   d0,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_2d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_2d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_2d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_2d.restype = ctypes.POINTER(ggml_tensor)\n# // kernel size is a->ne[0] x a->ne[1]\n# // stride is equal to kernel size\n# // padding is zero\n# // example:\n# // a:     16   16    3  768\n# // b:   1024 1024    3    1\n# // res:   64   64  768    1\n# // used in sam\n# GGML_API struct ggml_tensor * ggml_conv_2d_sk_p0(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_2d_sk_p0.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_2d_sk_p0.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_conv_2d_sk_p0.restype = ctypes.POINTER(ggml_tensor)\n# // kernel size is a->ne[0] x a->ne[1]\n# // stride is 1\n# // padding is half\n# // example:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_2d_sk_p0.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_2d_sk_p0.restype = ctypes.POINTER(ggml_tensor)\n# // kernel size is a->ne[0] x a->ne[1]\n# // stride is 1\n# // padding is half\n# // example:\n# // a:      3    3    256  256\n# // b:     64   64    256    1\n# // res:   64   64    256    1\n# // used in sam\n# GGML_API struct ggml_tensor * ggml_conv_2d_s1_ph(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_2d_s1_ph.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_2d_s1_ph.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_conv_2d_s1_ph.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_conv_transpose_2d_p0(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_2d_s1_ph.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_2d_s1_ph.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_conv_transpose_2d_p0(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b,\n#         int                   stride);\ndef ggml_conv_transpose_2d_p0(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_transpose_2d_p0.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_transpose_2d_p0.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_conv_transpose_2d_p0.restype = ctypes.POINTER(ggml_tensor)\n# enum ggml_op_pool {\n#     GGML_OP_POOL_MAX,\n#     GGML_OP_POOL_AVG,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_conv_transpose_2d_p0.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_conv_transpose_2d_p0.restype = ctypes.POINTER(ggml_tensor)\n# enum ggml_op_pool {\n#     GGML_OP_POOL_MAX,\n#     GGML_OP_POOL_AVG,\n#     GGML_OP_POOL_COUNT,\n# };\nGGML_OP_POOL_MAX = 0\nGGML_OP_POOL_AVG = 1\nGGML_OP_POOL_COUNT = 2\n# GGML_API struct ggml_tensor * ggml_pool_1d(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_POOL_MAX",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_POOL_MAX = 0\nGGML_OP_POOL_AVG = 1\nGGML_OP_POOL_COUNT = 2\n# GGML_API struct ggml_tensor * ggml_pool_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         enum ggml_op_pool     op,\n#         int                   k0, // kernel size\n#         int                   s0, // stride\n#         int                   p0); // padding",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_POOL_AVG",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_POOL_AVG = 1\nGGML_OP_POOL_COUNT = 2\n# GGML_API struct ggml_tensor * ggml_pool_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         enum ggml_op_pool     op,\n#         int                   k0, // kernel size\n#         int                   s0, // stride\n#         int                   p0); // padding\ndef ggml_pool_1d(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OP_POOL_COUNT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OP_POOL_COUNT = 2\n# GGML_API struct ggml_tensor * ggml_pool_1d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         enum ggml_op_pool     op,\n#         int                   k0, // kernel size\n#         int                   s0, // stride\n#         int                   p0); // padding\ndef ggml_pool_1d(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_pool_1d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_pool_1d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_pool_1d.restype = ctypes.POINTER(ggml_tensor)\n# // the result will have 2*p0 padding for the first dimension",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_pool_1d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_pool_1d.restype = ctypes.POINTER(ggml_tensor)\n# // the result will have 2*p0 padding for the first dimension\n# // and 2*p1 padding for the second dimension\n# GGML_API struct ggml_tensor * ggml_pool_2d(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         enum ggml_op_pool     op,\n#         int                   k0,\n#         int                   k1,\n#         int                   s0,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_pool_2d.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_pool_2d.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_float,\n    ctypes.c_float,\n]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_pool_2d.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_pool_2d.restype = ctypes.POINTER(ggml_tensor)\n# // nearest interpolate\n# // used in stable-diffusion\n# GGML_API struct ggml_tensor * ggml_upscale(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   scale_factor);\ndef ggml_upscale(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_upscale.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_upscale.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_upscale.restype = ctypes.POINTER(ggml_tensor)\n# // pad each dimension with zeros: [x, ..., x] -> [x, ..., x, 0, ..., 0]\n# GGML_API struct ggml_tensor * ggml_pad(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_upscale.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_upscale.restype = ctypes.POINTER(ggml_tensor)\n# // pad each dimension with zeros: [x, ..., x] -> [x, ..., x, 0, ..., 0]\n# GGML_API struct ggml_tensor * ggml_pad(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                  p0,\n#         int                  p1,\n#         int                  p2,\n#         int                  p3);\ndef ggml_pad(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_pad.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_pad.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_pad.restype = ctypes.POINTER(ggml_tensor)\n# // sort rows",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_pad.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_pad.restype = ctypes.POINTER(ggml_tensor)\n# // sort rows\n# enum ggml_sort_order {\n#     GGML_SORT_ASC,\n#     GGML_SORT_DESC,\n# };\nGGML_SORT_ASC = 0\nGGML_SORT_DESC = 1\n# GGML_API struct ggml_tensor * ggml_argsort(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_SORT_ASC",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_SORT_ASC = 0\nGGML_SORT_DESC = 1\n# GGML_API struct ggml_tensor * ggml_argsort(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         enum ggml_sort_order  order);\ndef ggml_argsort(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    order: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_SORT_DESC",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_SORT_DESC = 1\n# GGML_API struct ggml_tensor * ggml_argsort(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         enum ggml_sort_order  order);\ndef ggml_argsort(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    order: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_argsort.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_argsort.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_argsort.restype = ctypes.POINTER(ggml_tensor)\n# // top k elements per row\n# GGML_API struct ggml_tensor * ggml_top_k(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_argsort.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_argsort.restype = ctypes.POINTER(ggml_tensor)\n# // top k elements per row\n# GGML_API struct ggml_tensor * ggml_top_k(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   k);\ndef ggml_top_k(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    k: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_flash_attn.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_flash_attn.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_bool,\n]\nlib.ggml_flash_attn.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_flash_attn_back(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_flash_attn.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_flash_attn.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_flash_attn_back(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * q,\n#         struct ggml_tensor  * k,\n#         struct ggml_tensor  * v,\n#         struct ggml_tensor  * d,\n#         bool                  masked);\ndef ggml_flash_attn_back(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_flash_attn_back.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_flash_attn_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_bool,\n]\nlib.ggml_flash_attn_back.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_flash_ff(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_flash_attn_back.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_flash_attn_back.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_flash_ff(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * b0,\n#         struct ggml_tensor  * b1,\n#         struct ggml_tensor  * c0,\n#         struct ggml_tensor  * c1);\ndef ggml_flash_ff(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_flash_ff.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_flash_ff.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_flash_ff.restype = ctypes.POINTER(ggml_tensor)\n# // partition into non-overlapping windows with padding if needed",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_flash_ff.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_flash_ff.restype = ctypes.POINTER(ggml_tensor)\n# // partition into non-overlapping windows with padding if needed\n# // example:\n# // a:   768   64   64    1\n# // w:    14\n# // res: 768   14   14    25\n# // used in sam\n# GGML_API struct ggml_tensor * ggml_win_part(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_win_part.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_win_part.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_win_part.restype = ctypes.POINTER(ggml_tensor)\n# // reverse of ggml_win_part\n# // used in sam\n# GGML_API struct ggml_tensor * ggml_win_unpart(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_win_part.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_win_part.restype = ctypes.POINTER(ggml_tensor)\n# // reverse of ggml_win_part\n# // used in sam\n# GGML_API struct ggml_tensor * ggml_win_unpart(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   w0,\n#         int                   h0,\n#         int                   w);\ndef ggml_win_unpart(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_win_unpart.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_win_unpart.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_win_unpart.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_unary(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_win_unpart.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_win_unpart.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_unary(\n#         struct ggml_context * ctx,\n#             struct ggml_tensor * a,\n#             enum ggml_unary_op op);\ndef ggml_unary(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    op: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_unary.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_unary.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_unary.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_unary_inplace(\n#     struct ggml_context * ctx,\n#     struct ggml_tensor  * a,\n#     enum ggml_unary_op op);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_unary.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_unary.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_unary_inplace(\n#     struct ggml_context * ctx,\n#     struct ggml_tensor  * a,\n#     enum ggml_unary_op op);\ndef ggml_unary_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    op: Union[ctypes.c_int, int],\n) -> ggml_tensor_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_unary_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_unary_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n]\nlib.ggml_unary_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // used in sam\n# GGML_API struct ggml_tensor * ggml_get_rel_pos(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_unary_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_unary_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // used in sam\n# GGML_API struct ggml_tensor * ggml_get_rel_pos(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         int                   qh,\n#         int                   kh);\ndef ggml_get_rel_pos(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_rel_pos.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_rel_pos.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n]\nlib.ggml_get_rel_pos.restype = ctypes.POINTER(ggml_tensor)\n# // used in sam\n# GGML_API struct ggml_tensor * ggml_add_rel_pos(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_get_rel_pos.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_get_rel_pos.restype = ctypes.POINTER(ggml_tensor)\n# // used in sam\n# GGML_API struct ggml_tensor * ggml_add_rel_pos(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * pw,\n#         struct ggml_tensor  * ph);\ndef ggml_add_rel_pos(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add_rel_pos.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add_rel_pos.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_add_rel_pos.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add_rel_pos_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add_rel_pos.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add_rel_pos.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_add_rel_pos_inplace(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * a,\n#         struct ggml_tensor  * pw,\n#         struct ggml_tensor  * ph);\ndef ggml_add_rel_pos_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    pw: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add_rel_pos_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add_rel_pos_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_add_rel_pos_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // custom operators (DEPRECATED)\n# typedef void (*ggml_unary_op_f32_t)(const int, float *, const float *);\nggml_unary_op_f32_t = ctypes.CFUNCTYPE(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_add_rel_pos_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_add_rel_pos_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // custom operators (DEPRECATED)\n# typedef void (*ggml_unary_op_f32_t)(const int, float *, const float *);\nggml_unary_op_f32_t = ctypes.CFUNCTYPE(\n    None, ctypes.c_int, ctypes.POINTER(ctypes.c_float), ctypes.POINTER(ctypes.c_float)\n)\n# typedef void (*ggml_binary_op_f32_t)(const int, float *, const float *, const float *);\nggml_binary_op_f32_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_unary_op_f32_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_unary_op_f32_t = ctypes.CFUNCTYPE(\n    None, ctypes.c_int, ctypes.POINTER(ctypes.c_float), ctypes.POINTER(ctypes.c_float)\n)\n# typedef void (*ggml_binary_op_f32_t)(const int, float *, const float *, const float *);\nggml_binary_op_f32_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_binary_op_f32_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_binary_op_f32_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ctypes.c_float),\n)\n# typedef void (*ggml_custom1_op_f32_t)(struct ggml_tensor *, const struct ggml_tensor *);\nggml_custom1_op_f32_t = ctypes.CFUNCTYPE(\n    None, ctypes.POINTER(ggml_tensor), ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_custom1_op_f32_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_custom1_op_f32_t = ctypes.CFUNCTYPE(\n    None, ctypes.POINTER(ggml_tensor), ctypes.POINTER(ggml_tensor)\n)\n\"\"\"Unary operator function type\"\"\"\n# typedef void (*ggml_custom2_op_f32_t)(struct ggml_tensor *, const struct ggml_tensor *, const struct ggml_tensor *);\nggml_custom2_op_f32_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_custom2_op_f32_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_custom2_op_f32_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n)\n\"\"\"Binary operator function type\"\"\"\n# typedef void (*ggml_custom3_op_f32_t)(struct ggml_tensor *, const struct ggml_tensor *, const struct ggml_tensor *, const struct ggml_tensor *);\nggml_custom3_op_f32_t = ctypes.CFUNCTYPE(\n    None,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_custom3_op_f32_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_custom3_op_f32_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n)\n\"\"\"Ternary operator function type\"\"\"\n# GGML_API struct ggml_tensor * ggml_map_unary_f32(\n#         struct ggml_context        * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_unary_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_unary_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ggml_unary_op_f32_t,\n]\nlib.ggml_map_unary_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_unary_inplace_f32(\n#         struct ggml_context        * ctx,\n#         struct ggml_tensor         * a,\n#                 ggml_unary_op_f32_t   fun);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_unary_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_unary_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_unary_inplace_f32(\n#         struct ggml_context        * ctx,\n#         struct ggml_tensor         * a,\n#                 ggml_unary_op_f32_t   fun);\ndef ggml_map_unary_inplace_f32(\n    ctx: ggml_context_p, a: ggml_tensor_p, fun: \"ctypes._FuncPointer\"  # type: ignore\n) -> ggml_tensor_p:\n    return lib.ggml_map_unary_inplace_f32(ctx, a, fun)\nlib.ggml_map_unary_inplace_f32.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_unary_inplace_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_unary_inplace_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ggml_unary_op_f32_t,\n]\nlib.ggml_map_unary_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_binary_f32(\n#         struct ggml_context         * ctx,\n#         struct ggml_tensor          * a,\n#         struct ggml_tensor          * b,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_unary_inplace_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_unary_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_binary_f32(\n#         struct ggml_context         * ctx,\n#         struct ggml_tensor          * a,\n#         struct ggml_tensor          * b,\n#                ggml_binary_op_f32_t   fun);\ndef ggml_map_binary_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_binary_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_binary_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_binary_op_f32_t,\n]\nlib.ggml_map_binary_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_binary_inplace_f32(\n#         struct ggml_context         * ctx,\n#         struct ggml_tensor          * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_binary_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_binary_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_binary_inplace_f32(\n#         struct ggml_context         * ctx,\n#         struct ggml_tensor          * a,\n#         struct ggml_tensor          * b,\n#                 ggml_binary_op_f32_t   fun);\ndef ggml_map_binary_inplace_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_binary_inplace_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_binary_inplace_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_binary_op_f32_t,\n]\nlib.ggml_map_binary_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom1_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_binary_inplace_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_binary_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom1_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,\n#                 ggml_custom1_op_f32_t   fun);\ndef ggml_map_custom1_f32(\n    ctx: ggml_context_p, a: ggml_tensor_p, fun: \"ctypes._FuncPointer\"  # type: ignore\n) -> ggml_tensor_p:\n    \"\"\"Custom unary operator on a tensor.\n    Example:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom1_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom1_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom1_op_f32_t,\n]\nlib.ggml_map_custom1_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom1_inplace_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,\n#                 ggml_custom1_op_f32_t   fun);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom1_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom1_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom1_inplace_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,\n#                 ggml_custom1_op_f32_t   fun);\ndef ggml_map_custom1_inplace_f32(\n    ctx: ggml_context_p, a: ggml_tensor_p, fun: \"ctypes._CFuncPtr\"  # type: ignore\n) -> ggml_tensor_p:\n    \"\"\"Custom unary operator on a tensor inplace.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom1_inplace_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom1_inplace_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom1_op_f32_t,\n]\nlib.ggml_map_custom1_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom2_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,\n#         struct ggml_tensor           * b,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom1_inplace_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom1_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom2_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,\n#         struct ggml_tensor           * b,\n#                 ggml_custom2_op_f32_t   fun);\ndef ggml_map_custom2_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom2_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom2_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom2_op_f32_t,\n]\nlib.ggml_map_custom2_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom2_inplace_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom2_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom2_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom2_inplace_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,\n#         struct ggml_tensor           * b,\n#                 ggml_custom2_op_f32_t   fun);\ndef ggml_map_custom2_inplace_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom2_inplace_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom2_inplace_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom2_op_f32_t,\n]\nlib.ggml_map_custom2_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom3_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom2_inplace_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom2_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom3_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,\n#         struct ggml_tensor           * b,\n#         struct ggml_tensor           * c,\n#                 ggml_custom3_op_f32_t   fun);\ndef ggml_map_custom3_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom3_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom3_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom3_op_f32_t,\n]\nlib.ggml_map_custom3_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom3_inplace_f32(\n#         struct ggml_context          * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom3_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom3_f32.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom3_inplace_f32(\n#         struct ggml_context          * ctx,\n#         struct ggml_tensor           * a,\n#         struct ggml_tensor           * b,\n#         struct ggml_tensor           * c,\n#                 ggml_custom3_op_f32_t   fun);\ndef ggml_map_custom3_inplace_f32(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom3_inplace_f32.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom3_inplace_f32.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom3_op_f32_t,\n]\nlib.ggml_map_custom3_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# // custom operators v2\n# typedef void (*ggml_custom1_op_t)(struct ggml_tensor * dst , const struct ggml_tensor * a, int ith, int nth, void * userdata);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom3_inplace_f32.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom3_inplace_f32.restype = ctypes.POINTER(ggml_tensor)\n# // custom operators v2\n# typedef void (*ggml_custom1_op_t)(struct ggml_tensor * dst , const struct ggml_tensor * a, int ith, int nth, void * userdata);\nggml_custom1_op_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_custom1_op_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_custom1_op_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_void_p,\n)\n\"\"\"Custom unary operator on a tensor.\"\"\"\n# typedef void (*ggml_custom2_op_t)(struct ggml_tensor * dst , const struct ggml_tensor * a, const struct ggml_tensor * b, int ith, int nth, void * userdata);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_custom2_op_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_custom2_op_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_void_p,\n)\n\"\"\"Custom binary operator on two tensors.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_custom3_op_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_custom3_op_t = ctypes.CFUNCTYPE(\n    None,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.c_void_p,\n)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_N_TASKS_MAX",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_N_TASKS_MAX = -1\n# GGML_API struct ggml_tensor * ggml_map_custom1(\n#         struct ggml_context   * ctx,\n#         struct ggml_tensor    * a,\n#         ggml_custom1_op_t       fun,\n#         int                     n_tasks,\n#         void                  * userdata);\ndef ggml_map_custom1(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom1.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom1.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom1_op_t,\n    ctypes.c_int,\n    ctypes.c_void_p,\n]\nlib.ggml_map_custom1.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom1_inplace(\n#         struct ggml_context   * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom1.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom1.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom1_inplace(\n#         struct ggml_context   * ctx,\n#         struct ggml_tensor    * a,\n#         ggml_custom1_op_t       fun,\n#         int                     n_tasks,\n#         void                  * userdata);\ndef ggml_map_custom1_inplace(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom1_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom1_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom1_op_t,\n    ctypes.c_int,\n    ctypes.c_void_p,\n]\nlib.ggml_map_custom1_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom2(\n#         struct ggml_context   * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom1_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom1_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom2(\n#         struct ggml_context   * ctx,\n#         struct ggml_tensor    * a,\n#         struct ggml_tensor    * b,\n#         ggml_custom2_op_t       fun,\n#         int                     n_tasks,\n#         void                  * userdata);\ndef ggml_map_custom2(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom2.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom2.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom2_op_t,\n    ctypes.c_int,\n    ctypes.c_void_p,\n]\nlib.ggml_map_custom2.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom2_inplace(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom2.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom2.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom2_inplace(\n#         struct ggml_context   * ctx,\n#         struct ggml_tensor    * a,\n#         struct ggml_tensor    * b,\n#         ggml_custom2_op_t       fun,\n#         int                     n_tasks,\n#         void                  * userdata);\ndef ggml_map_custom2_inplace(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom2_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom2_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom2_op_t,\n    ctypes.c_int,\n    ctypes.c_void_p,\n]\nlib.ggml_map_custom2_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom3(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom2_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom2_inplace.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom3(\n#         struct ggml_context   * ctx,\n#         struct ggml_tensor    * a,\n#         struct ggml_tensor    * b,\n#         struct ggml_tensor    * c,\n#         ggml_custom3_op_t       fun,\n#         int                     n_tasks,\n#         void                  * userdata);\ndef ggml_map_custom3(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom3.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom3.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom3_op_t,\n    ctypes.c_int,\n    ctypes.c_void_p,\n]\nlib.ggml_map_custom3.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom3.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom3.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_map_custom3_inplace(\n#         struct ggml_context   * ctx,\n#         struct ggml_tensor    * a,\n#         struct ggml_tensor    * b,\n#         struct ggml_tensor    * c,\n#         ggml_custom3_op_t       fun,\n#         int                     n_tasks,\n#         void                  * userdata);\ndef ggml_map_custom3_inplace(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom3_inplace.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom3_inplace.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ggml_custom3_op_t,\n    ctypes.c_int,\n    ctypes.c_void_p,\n]\nlib.ggml_map_custom3_inplace.restype = ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_map_custom3_inplace.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_map_custom3_inplace.restype = ctypes.POINTER(ggml_tensor)\n# // loss function\n# GGML_API struct ggml_tensor * ggml_cross_entropy_loss(\n#         struct ggml_context         * ctx,\n#         struct ggml_tensor          * a,\n#         struct ggml_tensor          * b);\ndef ggml_cross_entropy_loss(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cross_entropy_loss.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cross_entropy_loss.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_cross_entropy_loss.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_cross_entropy_loss_back(\n#         struct ggml_context         * ctx,\n#         struct ggml_tensor          * a,\n#         struct ggml_tensor          * b,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cross_entropy_loss.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cross_entropy_loss.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API struct ggml_tensor * ggml_cross_entropy_loss_back(\n#         struct ggml_context         * ctx,\n#         struct ggml_tensor          * a,\n#         struct ggml_tensor          * b,\n#         struct ggml_tensor          * c);\ndef ggml_cross_entropy_loss_back(\n    ctx: ggml_context_p,\n    a: ggml_tensor_p,\n    b: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cross_entropy_loss_back.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cross_entropy_loss_back.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_cross_entropy_loss_back.restype = ctypes.POINTER(ggml_tensor)\n# //\n# // automatic differentiation\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cross_entropy_loss_back.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cross_entropy_loss_back.restype = ctypes.POINTER(ggml_tensor)\n# //\n# // automatic differentiation\n# //\n# GGML_API void ggml_set_param(\n#         struct ggml_context * ctx,\n#         struct ggml_tensor  * tensor);\ndef ggml_set_param(ctx: ggml_context_p, tensor: ggml_tensor_p):\n    return lib.ggml_set_param(ctx, tensor)\nlib.ggml_set_param.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_param.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_param.argtypes = [ggml_context_p, ctypes.POINTER(ggml_tensor)]\nlib.ggml_set_param.restype = None\n# GGML_API void ggml_build_forward_expand (struct ggml_cgraph * cgraph, struct ggml_tensor * tensor);\ndef ggml_build_forward_expand(\n    cgraph: ggml_cgraph_p,\n    tensor: ggml_tensor_p,\n):\n    \"\"\"Add a tensor to the forward computation graph. This is used to\n    compute and save the value of the tensor.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_set_param.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_set_param.restype = None\n# GGML_API void ggml_build_forward_expand (struct ggml_cgraph * cgraph, struct ggml_tensor * tensor);\ndef ggml_build_forward_expand(\n    cgraph: ggml_cgraph_p,\n    tensor: ggml_tensor_p,\n):\n    \"\"\"Add a tensor to the forward computation graph. This is used to\n    compute and save the value of the tensor.\n    Parameters:\n        cgraph: The graph.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_build_forward_expand.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_build_forward_expand.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_build_forward_expand.restype = None\n# GGML_API void ggml_build_backward_expand(struct ggml_context * ctx, struct ggml_cgraph * gf, struct ggml_cgraph * gb, bool keep);\ndef ggml_build_backward_expand(\n    ctx: ggml_context_p,\n    gf: ggml_cgraph_p,\n    gb: ggml_cgraph_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_build_forward_expand.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_build_forward_expand.restype = None\n# GGML_API void ggml_build_backward_expand(struct ggml_context * ctx, struct ggml_cgraph * gf, struct ggml_cgraph * gb, bool keep);\ndef ggml_build_backward_expand(\n    ctx: ggml_context_p,\n    gf: ggml_cgraph_p,\n    gb: ggml_cgraph_p,\n    keep: Union[ctypes.c_bool, bool],\n):\n    \"\"\"Add a tensor to the backward computation graph. This is used to\n    compute the gradient of the tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_build_backward_expand.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_build_backward_expand.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.c_bool,\n]\nlib.ggml_build_backward_expand.restype = None\n# // graph allocation in a context\n# GGML_API struct ggml_cgraph * ggml_new_graph         (struct ggml_context * ctx); // size = GGML_DEFAULT_GRAPH_SIZE, grads = false\ndef ggml_new_graph(ctx: ggml_context_p) -> ggml_cgraph_p:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_build_backward_expand.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_build_backward_expand.restype = None\n# // graph allocation in a context\n# GGML_API struct ggml_cgraph * ggml_new_graph         (struct ggml_context * ctx); // size = GGML_DEFAULT_GRAPH_SIZE, grads = false\ndef ggml_new_graph(ctx: ggml_context_p) -> ggml_cgraph_p:\n    \"\"\"Create a new graph.\n    Parameters:\n        ctx: The context.\n    Returns:\n        The graph.\"\"\"\n    return lib.ggml_new_graph(ctx)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_graph.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_graph.argtypes = [ggml_context_p]\nlib.ggml_new_graph.restype = ctypes.POINTER(ggml_cgraph)\n# GGML_API struct ggml_cgraph * ggml_new_graph_custom  (struct ggml_context * ctx, size_t size, bool grads);\ndef ggml_new_graph_custom(\n    ctx: ggml_context_p,\n    size: Union[ctypes.c_size_t, int],\n    grads: Union[ctypes.c_bool, bool],\n) -> ggml_cgraph_p:\n    \"\"\"Create a new graph with custom size and grads.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_graph.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_graph.restype = ctypes.POINTER(ggml_cgraph)\n# GGML_API struct ggml_cgraph * ggml_new_graph_custom  (struct ggml_context * ctx, size_t size, bool grads);\ndef ggml_new_graph_custom(\n    ctx: ggml_context_p,\n    size: Union[ctypes.c_size_t, int],\n    grads: Union[ctypes.c_bool, bool],\n) -> ggml_cgraph_p:\n    \"\"\"Create a new graph with custom size and grads.\n    Parameters:\n        ctx: The context.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_graph_custom.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_graph_custom.argtypes = [ggml_context_p, ctypes.c_size_t, ctypes.c_bool]\nlib.ggml_new_graph_custom.restype = ctypes.POINTER(ggml_cgraph)\n# GGML_API struct ggml_cgraph * ggml_graph_dup         (struct ggml_context * ctx, struct ggml_cgraph * cgraph);\ndef ggml_graph_dup(\n    ctx: ggml_context_p,\n    cgraph: ggml_cgraph_p,\n) -> ggml_cgraph_p:\n    \"\"\"Duplicate a graph.\n    Parameters:\n        ctx: The context.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_new_graph_custom.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_new_graph_custom.restype = ctypes.POINTER(ggml_cgraph)\n# GGML_API struct ggml_cgraph * ggml_graph_dup         (struct ggml_context * ctx, struct ggml_cgraph * cgraph);\ndef ggml_graph_dup(\n    ctx: ggml_context_p,\n    cgraph: ggml_cgraph_p,\n) -> ggml_cgraph_p:\n    \"\"\"Duplicate a graph.\n    Parameters:\n        ctx: The context.\n        cgraph: The graph.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_dup.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_dup.argtypes = [ggml_context_p, ctypes.POINTER(ggml_cgraph)]\nlib.ggml_graph_dup.restype = ctypes.POINTER(ggml_cgraph)\n# GGML_API struct ggml_cgraph   ggml_graph_view        (struct ggml_cgraph * cgraph, int i0, int i1);\ndef ggml_graph_view(\n    cgraph: ggml_cgraph_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n) -> ggml_cgraph:\n    \"\"\"View a graph.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_dup.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_dup.restype = ctypes.POINTER(ggml_cgraph)\n# GGML_API struct ggml_cgraph   ggml_graph_view        (struct ggml_cgraph * cgraph, int i0, int i1);\ndef ggml_graph_view(\n    cgraph: ggml_cgraph_p,\n    i0: Union[ctypes.c_int, int],\n    i1: Union[ctypes.c_int, int],\n) -> ggml_cgraph:\n    \"\"\"View a graph.\n    Parameters:\n        cgraph: The graph.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_view.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_view.argtypes = [ctypes.POINTER(ggml_cgraph), ctypes.c_int, ctypes.c_int]\nlib.ggml_graph_view.restype = ggml_cgraph\n# GGML_API void                 ggml_graph_cpy         (struct ggml_cgraph * src, struct ggml_cgraph * dst);\ndef ggml_graph_cpy(\n    src: ggml_cgraph_p,\n    dst: ggml_cgraph_p,\n):\n    \"\"\"Copy a graph.\n    Parameters:\n        src: The source graph.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_view.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_view.restype = ggml_cgraph\n# GGML_API void                 ggml_graph_cpy         (struct ggml_cgraph * src, struct ggml_cgraph * dst);\ndef ggml_graph_cpy(\n    src: ggml_cgraph_p,\n    dst: ggml_cgraph_p,\n):\n    \"\"\"Copy a graph.\n    Parameters:\n        src: The source graph.\n        dst: The destination graph.\"\"\"",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_cpy.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_cpy.argtypes = [ctypes.POINTER(ggml_cgraph), ctypes.POINTER(ggml_cgraph)]\nlib.ggml_graph_cpy.restype = None\n# GGML_API void                 ggml_graph_reset       (struct ggml_cgraph * cgraph);  // zero grads\ndef ggml_graph_reset(\n    cgraph: ggml_cgraph_p,\n):\n    \"\"\"Reset a graph.\n    Parameters:\n        cgraph: The graph.\"\"\"\n    return lib.ggml_graph_reset(cgraph)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_cpy.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_cpy.restype = None\n# GGML_API void                 ggml_graph_reset       (struct ggml_cgraph * cgraph);  // zero grads\ndef ggml_graph_reset(\n    cgraph: ggml_cgraph_p,\n):\n    \"\"\"Reset a graph.\n    Parameters:\n        cgraph: The graph.\"\"\"\n    return lib.ggml_graph_reset(cgraph)\nlib.ggml_graph_reset.argtypes = [ctypes.POINTER(ggml_cgraph)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_reset.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_reset.argtypes = [ctypes.POINTER(ggml_cgraph)]\nlib.ggml_graph_reset.restype = None\n# GGML_API void                 ggml_graph_clear       (struct ggml_cgraph * cgraph);\ndef ggml_graph_clear(\n    cgraph: ggml_cgraph_p,\n):\n    \"\"\"Clear a graph.\n    Parameters:\n        cgraph: The graph.\"\"\"\n    return lib.ggml_graph_clear(cgraph)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_reset.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_reset.restype = None\n# GGML_API void                 ggml_graph_clear       (struct ggml_cgraph * cgraph);\ndef ggml_graph_clear(\n    cgraph: ggml_cgraph_p,\n):\n    \"\"\"Clear a graph.\n    Parameters:\n        cgraph: The graph.\"\"\"\n    return lib.ggml_graph_clear(cgraph)\nlib.ggml_graph_clear.argtypes = [ctypes.POINTER(ggml_cgraph)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_clear.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_clear.argtypes = [ctypes.POINTER(ggml_cgraph)]\nlib.ggml_graph_clear.restype = None\n# GGML_API size_t ggml_graph_overhead(void);\ndef ggml_graph_overhead() -> int:\n    \"\"\"Get the overhead of the graph.\"\"\"\n    return lib.ggml_graph_overhead()\nlib.ggml_graph_overhead.argtypes = []\nlib.ggml_graph_overhead.restype = ctypes.c_size_t\n# GGML_API size_t ggml_graph_overhead_custom(size_t size, bool grads);\ndef ggml_graph_overhead_custom(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_clear.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_clear.restype = None\n# GGML_API size_t ggml_graph_overhead(void);\ndef ggml_graph_overhead() -> int:\n    \"\"\"Get the overhead of the graph.\"\"\"\n    return lib.ggml_graph_overhead()\nlib.ggml_graph_overhead.argtypes = []\nlib.ggml_graph_overhead.restype = ctypes.c_size_t\n# GGML_API size_t ggml_graph_overhead_custom(size_t size, bool grads);\ndef ggml_graph_overhead_custom(\n    size: Union[ctypes.c_size_t, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_overhead.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_overhead.argtypes = []\nlib.ggml_graph_overhead.restype = ctypes.c_size_t\n# GGML_API size_t ggml_graph_overhead_custom(size_t size, bool grads);\ndef ggml_graph_overhead_custom(\n    size: Union[ctypes.c_size_t, int],\n    grads: Union[ctypes.c_bool, bool],\n) -> int:\n    return lib.ggml_graph_overhead_custom(size, grads)\nlib.ggml_graph_overhead_custom.argtypes = [ctypes.c_size_t, ctypes.c_bool]\nlib.ggml_graph_overhead_custom.restype = ctypes.c_size_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_overhead.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_overhead.restype = ctypes.c_size_t\n# GGML_API size_t ggml_graph_overhead_custom(size_t size, bool grads);\ndef ggml_graph_overhead_custom(\n    size: Union[ctypes.c_size_t, int],\n    grads: Union[ctypes.c_bool, bool],\n) -> int:\n    return lib.ggml_graph_overhead_custom(size, grads)\nlib.ggml_graph_overhead_custom.argtypes = [ctypes.c_size_t, ctypes.c_bool]\nlib.ggml_graph_overhead_custom.restype = ctypes.c_size_t\n# // ggml_graph_plan() has to be called before ggml_graph_compute()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_overhead_custom.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_overhead_custom.argtypes = [ctypes.c_size_t, ctypes.c_bool]\nlib.ggml_graph_overhead_custom.restype = ctypes.c_size_t\n# // ggml_graph_plan() has to be called before ggml_graph_compute()\n# // when plan.work_size > 0, caller must allocate memory for plan.work_data\n# GGML_API struct ggml_cplan ggml_graph_plan   (struct ggml_cgraph * cgraph, int n_threads /*= GGML_DEFAULT_N_THREADS*/);\ndef ggml_graph_plan(\n    cgraph: ggml_cgraph_p,\n    n_threads: Union[ctypes.c_int, int] = GGML_DEFAULT_N_THREADS,\n) -> ggml_cplan:\n    \"\"\"Plan the computation graph.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_overhead_custom.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_overhead_custom.restype = ctypes.c_size_t\n# // ggml_graph_plan() has to be called before ggml_graph_compute()\n# // when plan.work_size > 0, caller must allocate memory for plan.work_data\n# GGML_API struct ggml_cplan ggml_graph_plan   (struct ggml_cgraph * cgraph, int n_threads /*= GGML_DEFAULT_N_THREADS*/);\ndef ggml_graph_plan(\n    cgraph: ggml_cgraph_p,\n    n_threads: Union[ctypes.c_int, int] = GGML_DEFAULT_N_THREADS,\n) -> ggml_cplan:\n    \"\"\"Plan the computation graph.\n    Parameters:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_plan.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_plan.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.c_int,\n]\nlib.ggml_graph_plan.restype = ggml_cplan\n# GGML_API int               ggml_graph_compute(struct ggml_cgraph * cgraph, struct ggml_cplan * cplan);\ndef ggml_graph_compute(\n    cgraph: ggml_cgraph_p,\n    cplan: ggml_cplan_p,\n) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_plan.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_plan.restype = ggml_cplan\n# GGML_API int               ggml_graph_compute(struct ggml_cgraph * cgraph, struct ggml_cplan * cplan);\ndef ggml_graph_compute(\n    cgraph: ggml_cgraph_p,\n    cplan: ggml_cplan_p,\n) -> int:\n    return lib.ggml_graph_compute(cgraph, cplan)\nlib.ggml_graph_compute.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_cplan),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_compute.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_compute.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_cplan),\n]\nlib.ggml_graph_compute.restype = ctypes.c_int\n# // same as ggml_graph_compute() but the work data is allocated as a part of the context\n# // note: the drawback of this API is that you must have ensured that the context has enough memory for the work data\n# GGML_API void ggml_graph_compute_with_ctx(struct ggml_context * ctx, struct ggml_cgraph * cgraph, int n_threads);\ndef ggml_graph_compute_with_ctx(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_compute.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_compute.restype = ctypes.c_int\n# // same as ggml_graph_compute() but the work data is allocated as a part of the context\n# // note: the drawback of this API is that you must have ensured that the context has enough memory for the work data\n# GGML_API void ggml_graph_compute_with_ctx(struct ggml_context * ctx, struct ggml_cgraph * cgraph, int n_threads);\ndef ggml_graph_compute_with_ctx(\n    ctx: ggml_context_p,\n    cgraph: ggml_cgraph_p,\n    n_threads: Union[ctypes.c_int, int],\n):\n    \"\"\"Compute the graph with a context.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_compute_with_ctx.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_compute_with_ctx.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.c_int,\n]\nlib.ggml_graph_compute_with_ctx.restype = None\n# GGML_API struct ggml_tensor * ggml_graph_get_tensor(struct ggml_cgraph * cgraph, const char * name);\ndef ggml_graph_get_tensor(\n    cgraph: ggml_cgraph_p,\n    name: bytes,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_compute_with_ctx.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_compute_with_ctx.restype = None\n# GGML_API struct ggml_tensor * ggml_graph_get_tensor(struct ggml_cgraph * cgraph, const char * name);\ndef ggml_graph_get_tensor(\n    cgraph: ggml_cgraph_p,\n    name: bytes,\n) -> ggml_tensor_p:\n    \"\"\"Get a tensor from the graph by name.\n    Parameters:\n        cgraph: The graph.\n        name: The name of the tensor.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_get_tensor.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_get_tensor.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.c_char_p,\n]\nlib.ggml_graph_get_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API void                 ggml_graph_export(const struct ggml_cgraph * cgraph, const char * fname);\ndef ggml_graph_export(\n    cgraph: ggml_cgraph_p,\n    fname: bytes,\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_get_tensor.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_get_tensor.restype = ctypes.POINTER(ggml_tensor)\n# GGML_API void                 ggml_graph_export(const struct ggml_cgraph * cgraph, const char * fname);\ndef ggml_graph_export(\n    cgraph: ggml_cgraph_p,\n    fname: bytes,\n):\n    return lib.ggml_graph_export(cgraph, fname)\nlib.ggml_graph_export.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.c_char_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_export.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_export.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.c_char_p,\n]\nlib.ggml_graph_export.restype = None\n# GGML_API struct ggml_cgraph * ggml_graph_import(const char * fname, struct ggml_context ** ctx_data, struct ggml_context ** ctx_eval);\ndef ggml_graph_import(\n    fname: bytes,\n    ctx_data: \"ctypes._Pointer[ggml_context_p]\",  # type: ignore\n    ctx_eval: \"ctypes._Pointer[ggml_context_p]\",  # type: ignore",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_export.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_export.restype = None\n# GGML_API struct ggml_cgraph * ggml_graph_import(const char * fname, struct ggml_context ** ctx_data, struct ggml_context ** ctx_eval);\ndef ggml_graph_import(\n    fname: bytes,\n    ctx_data: \"ctypes._Pointer[ggml_context_p]\",  # type: ignore\n    ctx_eval: \"ctypes._Pointer[ggml_context_p]\",  # type: ignore\n) -> ggml_cgraph_p:\n    return lib.ggml_graph_import(fname, ctx_data, ctx_eval)\nlib.ggml_graph_import.argtypes = [\n    ctypes.c_char_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_import.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_import.argtypes = [\n    ctypes.c_char_p,\n    ctypes.POINTER(ggml_context_p),\n    ctypes.POINTER(ggml_context_p),\n]\nlib.ggml_graph_import.restype = ctypes.POINTER(ggml_cgraph)\n# // print info and performance information for the graph\n# GGML_API void ggml_graph_print(const struct ggml_cgraph * cgraph);\ndef ggml_graph_print(\n    cgraph: ggml_cgraph_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_import.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_import.restype = ctypes.POINTER(ggml_cgraph)\n# // print info and performance information for the graph\n# GGML_API void ggml_graph_print(const struct ggml_cgraph * cgraph);\ndef ggml_graph_print(\n    cgraph: ggml_cgraph_p,\n):\n    return lib.ggml_graph_print(cgraph)\nlib.ggml_graph_print.argtypes = [ctypes.POINTER(ggml_cgraph)]\nlib.ggml_graph_print.restype = None\n# // dump the graph into a file using the dot format",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_print.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_print.argtypes = [ctypes.POINTER(ggml_cgraph)]\nlib.ggml_graph_print.restype = None\n# // dump the graph into a file using the dot format\n# GGML_API void ggml_graph_dump_dot(const struct ggml_cgraph * gb, const struct ggml_cgraph * gf, const char * filename);\ndef ggml_graph_dump_dot(\n    gb: ggml_cgraph_p,\n    gf: ggml_cgraph_p,\n    filename: bytes,\n):\n    return lib.ggml_graph_dump_dot(gb, gf, filename)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_print.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_print.restype = None\n# // dump the graph into a file using the dot format\n# GGML_API void ggml_graph_dump_dot(const struct ggml_cgraph * gb, const struct ggml_cgraph * gf, const char * filename);\ndef ggml_graph_dump_dot(\n    gb: ggml_cgraph_p,\n    gf: ggml_cgraph_p,\n    filename: bytes,\n):\n    return lib.ggml_graph_dump_dot(gb, gf, filename)\nlib.ggml_graph_dump_dot.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_dump_dot.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_dump_dot.argtypes = [\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.c_char_p,\n]\nlib.ggml_graph_dump_dot.restype = None\n# // build gradient checkpointing backward graph gb for gf using provided checkpoints\n# // gb_tmp will contain original backward graph with rewritten backward process nodes,\n# // but without the second forward pass nodes.\n# GGML_API void ggml_build_backward_gradient_checkpointing(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_graph_dump_dot.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_graph_dump_dot.restype = None\n# // build gradient checkpointing backward graph gb for gf using provided checkpoints\n# // gb_tmp will contain original backward graph with rewritten backward process nodes,\n# // but without the second forward pass nodes.\n# GGML_API void ggml_build_backward_gradient_checkpointing(\n#         struct ggml_context   * ctx,\n#         struct ggml_cgraph    * gf,\n#         struct ggml_cgraph    * gb,\n#         struct ggml_cgraph    * gb_tmp,\n#         struct ggml_tensor  * * checkpoints,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_build_backward_gradient_checkpointing.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_build_backward_gradient_checkpointing.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ctypes.POINTER(ggml_tensor)),\n    ctypes.c_int,\n]\nlib.ggml_build_backward_gradient_checkpointing.restype = None\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_build_backward_gradient_checkpointing.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_build_backward_gradient_checkpointing.restype = None\n# //\n# // optimization\n# //\n# // optimization methods\n# enum ggml_opt_type {\n#     GGML_OPT_ADAM,\n#     GGML_OPT_LBFGS,\n# };\nGGML_OPT_ADAM = 0",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OPT_ADAM",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OPT_ADAM = 0\nGGML_OPT_LBFGS = 1\n# // linesearch methods\n# enum ggml_linesearch {\n#     GGML_LINESEARCH_DEFAULT = 1,\n#     GGML_LINESEARCH_BACKTRACKING_ARMIJO       = 0,\n#     GGML_LINESEARCH_BACKTRACKING_WOLFE        = 1,\n#     GGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 2,\n# };\nGGML_LINESEARCH_DEFAULT = 1",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OPT_LBFGS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OPT_LBFGS = 1\n# // linesearch methods\n# enum ggml_linesearch {\n#     GGML_LINESEARCH_DEFAULT = 1,\n#     GGML_LINESEARCH_BACKTRACKING_ARMIJO       = 0,\n#     GGML_LINESEARCH_BACKTRACKING_WOLFE        = 1,\n#     GGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 2,\n# };\nGGML_LINESEARCH_DEFAULT = 1\nGGML_LINESEARCH_BACKTRACKING_ARMIJO = 0",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LINESEARCH_DEFAULT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LINESEARCH_DEFAULT = 1\nGGML_LINESEARCH_BACKTRACKING_ARMIJO = 0\nGGML_LINESEARCH_BACKTRACKING_WOLFE = 1\nGGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 2\n# // optimization return values\n# enum ggml_opt_result {\n#     GGML_OPT_OK = 0,\n#     GGML_OPT_DID_NOT_CONVERGE,\n#     GGML_OPT_NO_CONTEXT,\n#     GGML_OPT_INVALID_WOLFE,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LINESEARCH_BACKTRACKING_ARMIJO",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LINESEARCH_BACKTRACKING_ARMIJO = 0\nGGML_LINESEARCH_BACKTRACKING_WOLFE = 1\nGGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 2\n# // optimization return values\n# enum ggml_opt_result {\n#     GGML_OPT_OK = 0,\n#     GGML_OPT_DID_NOT_CONVERGE,\n#     GGML_OPT_NO_CONTEXT,\n#     GGML_OPT_INVALID_WOLFE,\n#     GGML_OPT_FAIL,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LINESEARCH_BACKTRACKING_WOLFE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LINESEARCH_BACKTRACKING_WOLFE = 1\nGGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 2\n# // optimization return values\n# enum ggml_opt_result {\n#     GGML_OPT_OK = 0,\n#     GGML_OPT_DID_NOT_CONVERGE,\n#     GGML_OPT_NO_CONTEXT,\n#     GGML_OPT_INVALID_WOLFE,\n#     GGML_OPT_FAIL,\n#     GGML_OPT_CANCEL,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 2\n# // optimization return values\n# enum ggml_opt_result {\n#     GGML_OPT_OK = 0,\n#     GGML_OPT_DID_NOT_CONVERGE,\n#     GGML_OPT_NO_CONTEXT,\n#     GGML_OPT_INVALID_WOLFE,\n#     GGML_OPT_FAIL,\n#     GGML_OPT_CANCEL,\n#     GGML_LINESEARCH_FAIL = -128,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OPT_OK",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OPT_OK = 0\nGGML_OPT_DID_NOT_CONVERGE = 1\nGGML_OPT_NO_CONTEXT = 2\nGGML_OPT_INVALID_WOLFE = 3\nGGML_OPT_FAIL = 4\nGGML_OPT_CANCEL = 5\nGGML_LINESEARCH_FAIL = -128\nGGML_LINESEARCH_MINIMUM_STEP = -127\nGGML_LINESEARCH_MAXIMUM_STEP = -126\nGGML_LINESEARCH_MAXIMUM_ITERATIONS = -125",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OPT_DID_NOT_CONVERGE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OPT_DID_NOT_CONVERGE = 1\nGGML_OPT_NO_CONTEXT = 2\nGGML_OPT_INVALID_WOLFE = 3\nGGML_OPT_FAIL = 4\nGGML_OPT_CANCEL = 5\nGGML_LINESEARCH_FAIL = -128\nGGML_LINESEARCH_MINIMUM_STEP = -127\nGGML_LINESEARCH_MAXIMUM_STEP = -126\nGGML_LINESEARCH_MAXIMUM_ITERATIONS = -125\nGGML_LINESEARCH_INVALID_PARAMETERS = -124",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OPT_NO_CONTEXT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OPT_NO_CONTEXT = 2\nGGML_OPT_INVALID_WOLFE = 3\nGGML_OPT_FAIL = 4\nGGML_OPT_CANCEL = 5\nGGML_LINESEARCH_FAIL = -128\nGGML_LINESEARCH_MINIMUM_STEP = -127\nGGML_LINESEARCH_MAXIMUM_STEP = -126\nGGML_LINESEARCH_MAXIMUM_ITERATIONS = -125\nGGML_LINESEARCH_INVALID_PARAMETERS = -124\n# typedef void (*ggml_opt_callback)(void * data, int accum_step, float * sched, bool * cancel);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OPT_INVALID_WOLFE",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OPT_INVALID_WOLFE = 3\nGGML_OPT_FAIL = 4\nGGML_OPT_CANCEL = 5\nGGML_LINESEARCH_FAIL = -128\nGGML_LINESEARCH_MINIMUM_STEP = -127\nGGML_LINESEARCH_MAXIMUM_STEP = -126\nGGML_LINESEARCH_MAXIMUM_ITERATIONS = -125\nGGML_LINESEARCH_INVALID_PARAMETERS = -124\n# typedef void (*ggml_opt_callback)(void * data, int accum_step, float * sched, bool * cancel);\nggml_opt_callback = ctypes.CFUNCTYPE(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OPT_FAIL",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OPT_FAIL = 4\nGGML_OPT_CANCEL = 5\nGGML_LINESEARCH_FAIL = -128\nGGML_LINESEARCH_MINIMUM_STEP = -127\nGGML_LINESEARCH_MAXIMUM_STEP = -126\nGGML_LINESEARCH_MAXIMUM_ITERATIONS = -125\nGGML_LINESEARCH_INVALID_PARAMETERS = -124\n# typedef void (*ggml_opt_callback)(void * data, int accum_step, float * sched, bool * cancel);\nggml_opt_callback = ctypes.CFUNCTYPE(\n    None,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_OPT_CANCEL",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_OPT_CANCEL = 5\nGGML_LINESEARCH_FAIL = -128\nGGML_LINESEARCH_MINIMUM_STEP = -127\nGGML_LINESEARCH_MAXIMUM_STEP = -126\nGGML_LINESEARCH_MAXIMUM_ITERATIONS = -125\nGGML_LINESEARCH_INVALID_PARAMETERS = -124\n# typedef void (*ggml_opt_callback)(void * data, int accum_step, float * sched, bool * cancel);\nggml_opt_callback = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LINESEARCH_FAIL",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LINESEARCH_FAIL = -128\nGGML_LINESEARCH_MINIMUM_STEP = -127\nGGML_LINESEARCH_MAXIMUM_STEP = -126\nGGML_LINESEARCH_MAXIMUM_ITERATIONS = -125\nGGML_LINESEARCH_INVALID_PARAMETERS = -124\n# typedef void (*ggml_opt_callback)(void * data, int accum_step, float * sched, bool * cancel);\nggml_opt_callback = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_void_p,\n    ctypes.c_int,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LINESEARCH_MINIMUM_STEP",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LINESEARCH_MINIMUM_STEP = -127\nGGML_LINESEARCH_MAXIMUM_STEP = -126\nGGML_LINESEARCH_MAXIMUM_ITERATIONS = -125\nGGML_LINESEARCH_INVALID_PARAMETERS = -124\n# typedef void (*ggml_opt_callback)(void * data, int accum_step, float * sched, bool * cancel);\nggml_opt_callback = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_float),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LINESEARCH_MAXIMUM_STEP",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LINESEARCH_MAXIMUM_STEP = -126\nGGML_LINESEARCH_MAXIMUM_ITERATIONS = -125\nGGML_LINESEARCH_INVALID_PARAMETERS = -124\n# typedef void (*ggml_opt_callback)(void * data, int accum_step, float * sched, bool * cancel);\nggml_opt_callback = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ctypes.c_bool),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LINESEARCH_MAXIMUM_ITERATIONS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LINESEARCH_MAXIMUM_ITERATIONS = -125\nGGML_LINESEARCH_INVALID_PARAMETERS = -124\n# typedef void (*ggml_opt_callback)(void * data, int accum_step, float * sched, bool * cancel);\nggml_opt_callback = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ctypes.c_bool),\n)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_LINESEARCH_INVALID_PARAMETERS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_LINESEARCH_INVALID_PARAMETERS = -124\n# typedef void (*ggml_opt_callback)(void * data, int accum_step, float * sched, bool * cancel);\nggml_opt_callback = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ctypes.c_bool),\n)\n# typedef void (*ggml_log_callback)(enum ggml_log_level level, const char * text, void * user_data);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_callback",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_opt_callback = ctypes.CFUNCTYPE(\n    None,\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.POINTER(ctypes.c_bool),\n)\n# typedef void (*ggml_log_callback)(enum ggml_log_level level, const char * text, void * user_data);\nggml_log_callback = ctypes.CFUNCTYPE(\n    None, ctypes.c_int, ctypes.c_char_p, ctypes.c_void_p",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_log_callback",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_log_callback = ctypes.CFUNCTYPE(\n    None, ctypes.c_int, ctypes.c_char_p, ctypes.c_void_p\n)\n# // optimization parameters\n# //\n# //   see ggml.c (ggml_opt_default_params) for default values\n# //\n# struct ggml_opt_params {\n#     enum ggml_opt_type type;\n#     size_t graph_size;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_opt_context_p",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_opt_context_p = ctypes.POINTER(ggml_opt_context)\n# GGML_API struct ggml_opt_params ggml_opt_default_params(enum ggml_opt_type type);\ndef ggml_opt_default_params(type: Union[ctypes.c_int, bool]) -> ggml_opt_params:\n    return lib.ggml_opt_default_params(type)\nlib.ggml_opt_default_params.argtypes = [ctypes.c_int]\nlib.ggml_opt_default_params.restype = ggml_opt_params\n# // optimize the function defined by the tensor f\n# GGML_API enum ggml_opt_result ggml_opt(\n#         struct ggml_context * ctx,\n#         struct ggml_opt_params params,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt_default_params.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt_default_params.argtypes = [ctypes.c_int]\nlib.ggml_opt_default_params.restype = ggml_opt_params\n# // optimize the function defined by the tensor f\n# GGML_API enum ggml_opt_result ggml_opt(\n#         struct ggml_context * ctx,\n#         struct ggml_opt_params params,\n#         struct ggml_tensor * f);\ndef ggml_opt(\n    ctx: ggml_context_p,\n    params: ggml_opt_params,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt_default_params.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt_default_params.restype = ggml_opt_params\n# // optimize the function defined by the tensor f\n# GGML_API enum ggml_opt_result ggml_opt(\n#         struct ggml_context * ctx,\n#         struct ggml_opt_params params,\n#         struct ggml_tensor * f);\ndef ggml_opt(\n    ctx: ggml_context_p,\n    params: ggml_opt_params,\n    f: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt.argtypes = [ggml_context_p, ggml_opt_params, ctypes.POINTER(ggml_tensor)]\nlib.ggml_opt.restype = ctypes.c_int\n# // initialize optimizer context\n# GGML_API void ggml_opt_init(\n#         struct ggml_context     * ctx,\n#         struct ggml_opt_context * opt,\n#         struct ggml_opt_params    params,\n#         int64_t                   nx);\ndef ggml_opt_init(\n    ctx: ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt.restype = ctypes.c_int\n# // initialize optimizer context\n# GGML_API void ggml_opt_init(\n#         struct ggml_context     * ctx,\n#         struct ggml_opt_context * opt,\n#         struct ggml_opt_params    params,\n#         int64_t                   nx);\ndef ggml_opt_init(\n    ctx: ggml_context_p,\n    opt: \"ctypes._Pointer[ggml_opt_context]\",  # type: ignore",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt_init.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt_init.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_opt_context),\n    ggml_opt_params,\n    ctypes.c_int64,\n]\nlib.ggml_opt_init.restype = None\n# // continue optimizing the function defined by the tensor f\n# GGML_API enum ggml_opt_result ggml_opt_resume(\n#         struct ggml_context * ctx,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt_init.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt_init.restype = None\n# // continue optimizing the function defined by the tensor f\n# GGML_API enum ggml_opt_result ggml_opt_resume(\n#         struct ggml_context * ctx,\n#         struct ggml_opt_context * opt,\n#         struct ggml_tensor * f);\ndef ggml_opt_resume(\n    ctx: ggml_context_p,\n    opt: \"ctypes._Pointer[ggml_opt_context]\",  # type: ignore\n    f: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt_resume.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt_resume.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_opt_context),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_opt_resume.restype = ctypes.c_int\n# // continue optimizing the function defined by the tensor f\n# GGML_API enum ggml_opt_result ggml_opt_resume_g(\n#         struct ggml_context * ctx,\n#         struct ggml_opt_context * opt,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt_resume.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt_resume.restype = ctypes.c_int\n# // continue optimizing the function defined by the tensor f\n# GGML_API enum ggml_opt_result ggml_opt_resume_g(\n#         struct ggml_context * ctx,\n#         struct ggml_opt_context * opt,\n#         struct ggml_tensor * f,\n#         struct ggml_cgraph * gf,\n#         struct ggml_cgraph * gb,\n#         ggml_opt_callback callback,\n#         void * callback_data);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt_resume_g.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt_resume_g.argtypes = [\n    ggml_context_p,\n    ctypes.POINTER(ggml_opt_context),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_cgraph),\n    ctypes.POINTER(ggml_cgraph),\n    ggml_opt_callback,\n    ctypes.c_void_p,\n]\nlib.ggml_opt_resume_g.restype = ctypes.c_int",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_opt_resume_g.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_opt_resume_g.restype = ctypes.c_int\n# //\n# // quantization\n# //\n# // TODO: these would probably get removed in favor of the more general ggml_quantize_chunk\n# GGML_API size_t ggml_quantize_q4_0(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q4_0(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q4_0.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q4_0.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q4_0.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q4_1(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q4_1(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q4_0.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q4_0.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q4_1(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q4_1(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q4_1(src, dst, n, k, hist)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q4_1.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q4_1.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q4_1.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q5_0(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q5_0(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q4_1.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q4_1.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q5_0(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q5_0(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q5_0(src, dst, n, k, hist)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q5_0.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q5_0.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q5_0.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q5_1(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q5_1(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q5_0.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q5_0.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q5_1(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q5_1(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q5_1(src, dst, n, k, hist)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q5_1.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q5_1.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q5_1.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q8_0(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q8_0(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q5_1.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q5_1.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q8_0(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q8_0(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q8_0(src, dst, n, k, hist)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q8_0.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q8_0.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q8_0.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q2_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q2_K(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q8_0.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q8_0.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q2_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q2_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q2_K(src, dst, n, k, hist)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q2_K.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q2_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q2_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q3_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q3_K(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q2_K.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q2_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q3_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q3_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q3_K(src, dst, n, k, hist)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q3_K.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q3_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q3_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q4_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q4_K(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q3_K.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q3_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q4_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q4_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q4_K(src, dst, n, k, hist)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q4_K.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q4_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q4_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q5_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q5_K(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q4_K.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q4_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q5_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q5_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q5_K(src, dst, n, k, hist)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q5_K.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q5_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q5_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q6_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q6_K(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q5_K.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q5_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_q6_K(const float * src, void * dst, int n, int k, int64_t * hist);\ndef ggml_quantize_q6_K(\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    n: Union[ctypes.c_int, int],\n    k: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:\n    return lib.ggml_quantize_q6_K(src, dst, n, k, hist)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q6_K.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q6_K.argtypes = [\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_q6_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_chunk(enum ggml_type type, const float * src, void * dst, int start, int n, int64_t * hist);\ndef ggml_quantize_chunk(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_q6_K.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_q6_K.restype = ctypes.c_size_t\n# GGML_API size_t ggml_quantize_chunk(enum ggml_type type, const float * src, void * dst, int start, int n, int64_t * hist);\ndef ggml_quantize_chunk(\n    type: Union[ctypes.c_int, int],\n    src: CFloatArray,\n    dst: ctypes.c_void_p,\n    start: Union[ctypes.c_int, int],\n    n: Union[ctypes.c_int, int],\n    hist: CInt64Array,\n) -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_chunk.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_chunk.argtypes = [\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_float),\n    ctypes.c_void_p,\n    ctypes.c_int,\n    ctypes.c_int,\n    ctypes.POINTER(ctypes.c_int64),\n]\nlib.ggml_quantize_chunk.restype = ctypes.c_size_t\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_quantize_chunk.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_quantize_chunk.restype = ctypes.c_size_t\n# //\n# // gguf\n# //\n# enum gguf_type {\n#     GGUF_TYPE_UINT8   = 0,\n#     GGUF_TYPE_INT8    = 1,\n#     GGUF_TYPE_UINT16  = 2,\n#     GGUF_TYPE_INT16   = 3,\n#     GGUF_TYPE_UINT32  = 4,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_UINT8",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_UINT8 = 0\nGGUF_TYPE_INT8 = 1\nGGUF_TYPE_UINT16 = 2\nGGUF_TYPE_INT16 = 3\nGGUF_TYPE_UINT32 = 4\nGGUF_TYPE_INT32 = 5\nGGUF_TYPE_FLOAT32 = 6\nGGUF_TYPE_BOOL = 7\nGGUF_TYPE_STRING = 8\nGGUF_TYPE_ARRAY = 9",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_INT8",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_INT8 = 1\nGGUF_TYPE_UINT16 = 2\nGGUF_TYPE_INT16 = 3\nGGUF_TYPE_UINT32 = 4\nGGUF_TYPE_INT32 = 5\nGGUF_TYPE_FLOAT32 = 6\nGGUF_TYPE_BOOL = 7\nGGUF_TYPE_STRING = 8\nGGUF_TYPE_ARRAY = 9\nGGUF_TYPE_COUNT = 10",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_UINT16",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_UINT16 = 2\nGGUF_TYPE_INT16 = 3\nGGUF_TYPE_UINT32 = 4\nGGUF_TYPE_INT32 = 5\nGGUF_TYPE_FLOAT32 = 6\nGGUF_TYPE_BOOL = 7\nGGUF_TYPE_STRING = 8\nGGUF_TYPE_ARRAY = 9\nGGUF_TYPE_COUNT = 10\n# struct gguf_context;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_INT16",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_INT16 = 3\nGGUF_TYPE_UINT32 = 4\nGGUF_TYPE_INT32 = 5\nGGUF_TYPE_FLOAT32 = 6\nGGUF_TYPE_BOOL = 7\nGGUF_TYPE_STRING = 8\nGGUF_TYPE_ARRAY = 9\nGGUF_TYPE_COUNT = 10\n# struct gguf_context;\ngguf_context_p = ctypes.c_void_p",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_UINT32",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_UINT32 = 4\nGGUF_TYPE_INT32 = 5\nGGUF_TYPE_FLOAT32 = 6\nGGUF_TYPE_BOOL = 7\nGGUF_TYPE_STRING = 8\nGGUF_TYPE_ARRAY = 9\nGGUF_TYPE_COUNT = 10\n# struct gguf_context;\ngguf_context_p = ctypes.c_void_p\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_INT32",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_INT32 = 5\nGGUF_TYPE_FLOAT32 = 6\nGGUF_TYPE_BOOL = 7\nGGUF_TYPE_STRING = 8\nGGUF_TYPE_ARRAY = 9\nGGUF_TYPE_COUNT = 10\n# struct gguf_context;\ngguf_context_p = ctypes.c_void_p\n# //\n# // system info",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_FLOAT32",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_FLOAT32 = 6\nGGUF_TYPE_BOOL = 7\nGGUF_TYPE_STRING = 8\nGGUF_TYPE_ARRAY = 9\nGGUF_TYPE_COUNT = 10\n# struct gguf_context;\ngguf_context_p = ctypes.c_void_p\n# //\n# // system info\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_BOOL",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_BOOL = 7\nGGUF_TYPE_STRING = 8\nGGUF_TYPE_ARRAY = 9\nGGUF_TYPE_COUNT = 10\n# struct gguf_context;\ngguf_context_p = ctypes.c_void_p\n# //\n# // system info\n# //\n# GGML_API int ggml_cpu_has_avx        (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_STRING",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_STRING = 8\nGGUF_TYPE_ARRAY = 9\nGGUF_TYPE_COUNT = 10\n# struct gguf_context;\ngguf_context_p = ctypes.c_void_p\n# //\n# // system info\n# //\n# GGML_API int ggml_cpu_has_avx        (void);\ndef ggml_cpu_has_avx() -> int:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_ARRAY",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_ARRAY = 9\nGGUF_TYPE_COUNT = 10\n# struct gguf_context;\ngguf_context_p = ctypes.c_void_p\n# //\n# // system info\n# //\n# GGML_API int ggml_cpu_has_avx        (void);\ndef ggml_cpu_has_avx() -> int:\n    return lib.ggml_cpu_has_avx()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGUF_TYPE_COUNT",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGUF_TYPE_COUNT = 10\n# struct gguf_context;\ngguf_context_p = ctypes.c_void_p\n# //\n# // system info\n# //\n# GGML_API int ggml_cpu_has_avx        (void);\ndef ggml_cpu_has_avx() -> int:\n    return lib.ggml_cpu_has_avx()\nlib.ggml_cpu_has_avx.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "gguf_context_p",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "gguf_context_p = ctypes.c_void_p\n# //\n# // system info\n# //\n# GGML_API int ggml_cpu_has_avx        (void);\ndef ggml_cpu_has_avx() -> int:\n    return lib.ggml_cpu_has_avx()\nlib.ggml_cpu_has_avx.argtypes = []\nlib.ggml_cpu_has_avx.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx2       (void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx.argtypes = []\nlib.ggml_cpu_has_avx.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx2       (void);\ndef ggml_cpu_has_avx2() -> int:\n    return lib.ggml_cpu_has_avx2()\nlib.ggml_cpu_has_avx2.argtypes = []\nlib.ggml_cpu_has_avx2.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512     (void);\ndef ggml_cpu_has_avx512() -> int:\n    return lib.ggml_cpu_has_avx512()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx2       (void);\ndef ggml_cpu_has_avx2() -> int:\n    return lib.ggml_cpu_has_avx2()\nlib.ggml_cpu_has_avx2.argtypes = []\nlib.ggml_cpu_has_avx2.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512     (void);\ndef ggml_cpu_has_avx512() -> int:\n    return lib.ggml_cpu_has_avx512()\nlib.ggml_cpu_has_avx512.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx2.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx2.argtypes = []\nlib.ggml_cpu_has_avx2.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512     (void);\ndef ggml_cpu_has_avx512() -> int:\n    return lib.ggml_cpu_has_avx512()\nlib.ggml_cpu_has_avx512.argtypes = []\nlib.ggml_cpu_has_avx512.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vbmi(void);\ndef ggml_cpu_has_avx512_vbmi() -> int:\n    return lib.ggml_cpu_has_avx512_vbmi()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx2.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx2.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512     (void);\ndef ggml_cpu_has_avx512() -> int:\n    return lib.ggml_cpu_has_avx512()\nlib.ggml_cpu_has_avx512.argtypes = []\nlib.ggml_cpu_has_avx512.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vbmi(void);\ndef ggml_cpu_has_avx512_vbmi() -> int:\n    return lib.ggml_cpu_has_avx512_vbmi()\nlib.ggml_cpu_has_avx512_vbmi.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx512.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx512.argtypes = []\nlib.ggml_cpu_has_avx512.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vbmi(void);\ndef ggml_cpu_has_avx512_vbmi() -> int:\n    return lib.ggml_cpu_has_avx512_vbmi()\nlib.ggml_cpu_has_avx512_vbmi.argtypes = []\nlib.ggml_cpu_has_avx512_vbmi.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vnni(void);\ndef ggml_cpu_has_avx512_vnni() -> int:\n    return lib.ggml_cpu_has_avx512_vnni()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx512.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx512.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vbmi(void);\ndef ggml_cpu_has_avx512_vbmi() -> int:\n    return lib.ggml_cpu_has_avx512_vbmi()\nlib.ggml_cpu_has_avx512_vbmi.argtypes = []\nlib.ggml_cpu_has_avx512_vbmi.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vnni(void);\ndef ggml_cpu_has_avx512_vnni() -> int:\n    return lib.ggml_cpu_has_avx512_vnni()\nlib.ggml_cpu_has_avx512_vnni.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx512_vbmi.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx512_vbmi.argtypes = []\nlib.ggml_cpu_has_avx512_vbmi.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vnni(void);\ndef ggml_cpu_has_avx512_vnni() -> int:\n    return lib.ggml_cpu_has_avx512_vnni()\nlib.ggml_cpu_has_avx512_vnni.argtypes = []\nlib.ggml_cpu_has_avx512_vnni.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fma        (void);\ndef ggml_cpu_has_fma() -> int:\n    return lib.ggml_cpu_has_fma()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx512_vbmi.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx512_vbmi.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_avx512_vnni(void);\ndef ggml_cpu_has_avx512_vnni() -> int:\n    return lib.ggml_cpu_has_avx512_vnni()\nlib.ggml_cpu_has_avx512_vnni.argtypes = []\nlib.ggml_cpu_has_avx512_vnni.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fma        (void);\ndef ggml_cpu_has_fma() -> int:\n    return lib.ggml_cpu_has_fma()\nlib.ggml_cpu_has_fma.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx512_vnni.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx512_vnni.argtypes = []\nlib.ggml_cpu_has_avx512_vnni.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fma        (void);\ndef ggml_cpu_has_fma() -> int:\n    return lib.ggml_cpu_has_fma()\nlib.ggml_cpu_has_fma.argtypes = []\nlib.ggml_cpu_has_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_neon       (void);\ndef ggml_cpu_has_neon() -> int:\n    return lib.ggml_cpu_has_neon()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_avx512_vnni.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_avx512_vnni.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fma        (void);\ndef ggml_cpu_has_fma() -> int:\n    return lib.ggml_cpu_has_fma()\nlib.ggml_cpu_has_fma.argtypes = []\nlib.ggml_cpu_has_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_neon       (void);\ndef ggml_cpu_has_neon() -> int:\n    return lib.ggml_cpu_has_neon()\nlib.ggml_cpu_has_neon.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_fma.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_fma.argtypes = []\nlib.ggml_cpu_has_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_neon       (void);\ndef ggml_cpu_has_neon() -> int:\n    return lib.ggml_cpu_has_neon()\nlib.ggml_cpu_has_neon.argtypes = []\nlib.ggml_cpu_has_neon.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_arm_fma    (void);\ndef ggml_cpu_has_arm_fma() -> int:\n    return lib.ggml_cpu_has_arm_fma()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_fma.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_neon       (void);\ndef ggml_cpu_has_neon() -> int:\n    return lib.ggml_cpu_has_neon()\nlib.ggml_cpu_has_neon.argtypes = []\nlib.ggml_cpu_has_neon.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_arm_fma    (void);\ndef ggml_cpu_has_arm_fma() -> int:\n    return lib.ggml_cpu_has_arm_fma()\nlib.ggml_cpu_has_arm_fma.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_neon.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_neon.argtypes = []\nlib.ggml_cpu_has_neon.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_arm_fma    (void);\ndef ggml_cpu_has_arm_fma() -> int:\n    return lib.ggml_cpu_has_arm_fma()\nlib.ggml_cpu_has_arm_fma.argtypes = []\nlib.ggml_cpu_has_arm_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_metal      (void);\ndef ggml_cpu_has_metal() -> int:\n    return lib.ggml_cpu_has_metal()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_neon.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_neon.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_arm_fma    (void);\ndef ggml_cpu_has_arm_fma() -> int:\n    return lib.ggml_cpu_has_arm_fma()\nlib.ggml_cpu_has_arm_fma.argtypes = []\nlib.ggml_cpu_has_arm_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_metal      (void);\ndef ggml_cpu_has_metal() -> int:\n    return lib.ggml_cpu_has_metal()\nlib.ggml_cpu_has_metal.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_arm_fma.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_arm_fma.argtypes = []\nlib.ggml_cpu_has_arm_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_metal      (void);\ndef ggml_cpu_has_metal() -> int:\n    return lib.ggml_cpu_has_metal()\nlib.ggml_cpu_has_metal.argtypes = []\nlib.ggml_cpu_has_metal.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_f16c       (void);\ndef ggml_cpu_has_f16c() -> int:\n    return lib.ggml_cpu_has_f16c()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_arm_fma.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_arm_fma.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_metal      (void);\ndef ggml_cpu_has_metal() -> int:\n    return lib.ggml_cpu_has_metal()\nlib.ggml_cpu_has_metal.argtypes = []\nlib.ggml_cpu_has_metal.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_f16c       (void);\ndef ggml_cpu_has_f16c() -> int:\n    return lib.ggml_cpu_has_f16c()\nlib.ggml_cpu_has_f16c.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_metal.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_metal.argtypes = []\nlib.ggml_cpu_has_metal.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_f16c       (void);\ndef ggml_cpu_has_f16c() -> int:\n    return lib.ggml_cpu_has_f16c()\nlib.ggml_cpu_has_f16c.argtypes = []\nlib.ggml_cpu_has_f16c.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fp16_va    (void);\ndef ggml_cpu_has_fp16_va() -> int:\n    return lib.ggml_cpu_has_fp16_va()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_metal.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_metal.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_f16c       (void);\ndef ggml_cpu_has_f16c() -> int:\n    return lib.ggml_cpu_has_f16c()\nlib.ggml_cpu_has_f16c.argtypes = []\nlib.ggml_cpu_has_f16c.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fp16_va    (void);\ndef ggml_cpu_has_fp16_va() -> int:\n    return lib.ggml_cpu_has_fp16_va()\nlib.ggml_cpu_has_fp16_va.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_f16c.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_f16c.argtypes = []\nlib.ggml_cpu_has_f16c.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fp16_va    (void);\ndef ggml_cpu_has_fp16_va() -> int:\n    return lib.ggml_cpu_has_fp16_va()\nlib.ggml_cpu_has_fp16_va.argtypes = []\nlib.ggml_cpu_has_fp16_va.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_wasm_simd  (void);\ndef ggml_cpu_has_wasm_simd() -> int:\n    return lib.ggml_cpu_has_wasm_simd()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_f16c.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_f16c.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_fp16_va    (void);\ndef ggml_cpu_has_fp16_va() -> int:\n    return lib.ggml_cpu_has_fp16_va()\nlib.ggml_cpu_has_fp16_va.argtypes = []\nlib.ggml_cpu_has_fp16_va.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_wasm_simd  (void);\ndef ggml_cpu_has_wasm_simd() -> int:\n    return lib.ggml_cpu_has_wasm_simd()\nlib.ggml_cpu_has_wasm_simd.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_fp16_va.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_fp16_va.argtypes = []\nlib.ggml_cpu_has_fp16_va.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_wasm_simd  (void);\ndef ggml_cpu_has_wasm_simd() -> int:\n    return lib.ggml_cpu_has_wasm_simd()\nlib.ggml_cpu_has_wasm_simd.argtypes = []\nlib.ggml_cpu_has_wasm_simd.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_blas       (void);\ndef ggml_cpu_has_blas() -> int:\n    return lib.ggml_cpu_has_blas()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_fp16_va.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_fp16_va.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_wasm_simd  (void);\ndef ggml_cpu_has_wasm_simd() -> int:\n    return lib.ggml_cpu_has_wasm_simd()\nlib.ggml_cpu_has_wasm_simd.argtypes = []\nlib.ggml_cpu_has_wasm_simd.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_blas       (void);\ndef ggml_cpu_has_blas() -> int:\n    return lib.ggml_cpu_has_blas()\nlib.ggml_cpu_has_blas.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_wasm_simd.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_wasm_simd.argtypes = []\nlib.ggml_cpu_has_wasm_simd.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_blas       (void);\ndef ggml_cpu_has_blas() -> int:\n    return lib.ggml_cpu_has_blas()\nlib.ggml_cpu_has_blas.argtypes = []\nlib.ggml_cpu_has_blas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_cublas     (void);\ndef ggml_cpu_has_cublas() -> int:\n    return lib.ggml_cpu_has_cublas()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_wasm_simd.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_wasm_simd.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_blas       (void);\ndef ggml_cpu_has_blas() -> int:\n    return lib.ggml_cpu_has_blas()\nlib.ggml_cpu_has_blas.argtypes = []\nlib.ggml_cpu_has_blas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_cublas     (void);\ndef ggml_cpu_has_cublas() -> int:\n    return lib.ggml_cpu_has_cublas()\nlib.ggml_cpu_has_cublas.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_blas.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_blas.argtypes = []\nlib.ggml_cpu_has_blas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_cublas     (void);\ndef ggml_cpu_has_cublas() -> int:\n    return lib.ggml_cpu_has_cublas()\nlib.ggml_cpu_has_cublas.argtypes = []\nlib.ggml_cpu_has_cublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_clblast    (void);\ndef ggml_cpu_has_clblast() -> int:\n    return lib.ggml_cpu_has_clblast()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_blas.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_blas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_cublas     (void);\ndef ggml_cpu_has_cublas() -> int:\n    return lib.ggml_cpu_has_cublas()\nlib.ggml_cpu_has_cublas.argtypes = []\nlib.ggml_cpu_has_cublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_clblast    (void);\ndef ggml_cpu_has_clblast() -> int:\n    return lib.ggml_cpu_has_clblast()\nlib.ggml_cpu_has_clblast.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_cublas.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_cublas.argtypes = []\nlib.ggml_cpu_has_cublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_clblast    (void);\ndef ggml_cpu_has_clblast() -> int:\n    return lib.ggml_cpu_has_clblast()\nlib.ggml_cpu_has_clblast.argtypes = []\nlib.ggml_cpu_has_clblast.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_gpublas    (void);\ndef ggml_cpu_has_gpublas() -> int:\n    return lib.ggml_cpu_has_gpublas()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_cublas.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_cublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_clblast    (void);\ndef ggml_cpu_has_clblast() -> int:\n    return lib.ggml_cpu_has_clblast()\nlib.ggml_cpu_has_clblast.argtypes = []\nlib.ggml_cpu_has_clblast.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_gpublas    (void);\ndef ggml_cpu_has_gpublas() -> int:\n    return lib.ggml_cpu_has_gpublas()\nlib.ggml_cpu_has_gpublas.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_clblast.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_clblast.argtypes = []\nlib.ggml_cpu_has_clblast.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_gpublas    (void);\ndef ggml_cpu_has_gpublas() -> int:\n    return lib.ggml_cpu_has_gpublas()\nlib.ggml_cpu_has_gpublas.argtypes = []\nlib.ggml_cpu_has_gpublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_sse3       (void);\ndef ggml_cpu_has_sse3() -> int:\n    return lib.ggml_cpu_has_sse3()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_clblast.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_clblast.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_gpublas    (void);\ndef ggml_cpu_has_gpublas() -> int:\n    return lib.ggml_cpu_has_gpublas()\nlib.ggml_cpu_has_gpublas.argtypes = []\nlib.ggml_cpu_has_gpublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_sse3       (void);\ndef ggml_cpu_has_sse3() -> int:\n    return lib.ggml_cpu_has_sse3()\nlib.ggml_cpu_has_sse3.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_gpublas.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_gpublas.argtypes = []\nlib.ggml_cpu_has_gpublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_sse3       (void);\ndef ggml_cpu_has_sse3() -> int:\n    return lib.ggml_cpu_has_sse3()\nlib.ggml_cpu_has_sse3.argtypes = []\nlib.ggml_cpu_has_sse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_ssse3      (void);\ndef ggml_cpu_has_ssse3() -> int:\n    return lib.ggml_cpu_has_ssse3()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_gpublas.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_gpublas.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_sse3       (void);\ndef ggml_cpu_has_sse3() -> int:\n    return lib.ggml_cpu_has_sse3()\nlib.ggml_cpu_has_sse3.argtypes = []\nlib.ggml_cpu_has_sse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_ssse3      (void);\ndef ggml_cpu_has_ssse3() -> int:\n    return lib.ggml_cpu_has_ssse3()\nlib.ggml_cpu_has_ssse3.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_sse3.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_sse3.argtypes = []\nlib.ggml_cpu_has_sse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_ssse3      (void);\ndef ggml_cpu_has_ssse3() -> int:\n    return lib.ggml_cpu_has_ssse3()\nlib.ggml_cpu_has_ssse3.argtypes = []\nlib.ggml_cpu_has_ssse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_vsx        (void);\ndef ggml_cpu_has_vsx() -> int:\n    return lib.ggml_cpu_has_vsx()",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_sse3.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_sse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_ssse3      (void);\ndef ggml_cpu_has_ssse3() -> int:\n    return lib.ggml_cpu_has_ssse3()\nlib.ggml_cpu_has_ssse3.argtypes = []\nlib.ggml_cpu_has_ssse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_vsx        (void);\ndef ggml_cpu_has_vsx() -> int:\n    return lib.ggml_cpu_has_vsx()\nlib.ggml_cpu_has_vsx.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_ssse3.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_ssse3.argtypes = []\nlib.ggml_cpu_has_ssse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_vsx        (void);\ndef ggml_cpu_has_vsx() -> int:\n    return lib.ggml_cpu_has_vsx()\nlib.ggml_cpu_has_vsx.argtypes = []\nlib.ggml_cpu_has_vsx.restype = ctypes.c_int\n# //\n# // Internal types and functions exposed for tests and benchmarks\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_ssse3.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_ssse3.restype = ctypes.c_int\n# GGML_API int ggml_cpu_has_vsx        (void);\ndef ggml_cpu_has_vsx() -> int:\n    return lib.ggml_cpu_has_vsx()\nlib.ggml_cpu_has_vsx.argtypes = []\nlib.ggml_cpu_has_vsx.restype = ctypes.c_int\n# //\n# // Internal types and functions exposed for tests and benchmarks\n# //\n# typedef void (*ggml_to_float_t)(const void * x, float * y, int k);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_vsx.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_vsx.argtypes = []\nlib.ggml_cpu_has_vsx.restype = ctypes.c_int\n# //\n# // Internal types and functions exposed for tests and benchmarks\n# //\n# typedef void (*ggml_to_float_t)(const void * x, float * y, int k);\nggml_to_float_t = ctypes.CFUNCTYPE(\n    None, ctypes.c_void_p, ctypes.POINTER(ctypes.c_float), ctypes.c_int\n)\n# typedef void (*ggml_from_float_t)(const float * x, void * y, int k);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_cpu_has_vsx.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_cpu_has_vsx.restype = ctypes.c_int\n# //\n# // Internal types and functions exposed for tests and benchmarks\n# //\n# typedef void (*ggml_to_float_t)(const void * x, float * y, int k);\nggml_to_float_t = ctypes.CFUNCTYPE(\n    None, ctypes.c_void_p, ctypes.POINTER(ctypes.c_float), ctypes.c_int\n)\n# typedef void (*ggml_from_float_t)(const float * x, void * y, int k);\nggml_from_float_t = ctypes.CFUNCTYPE(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_to_float_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_to_float_t = ctypes.CFUNCTYPE(\n    None, ctypes.c_void_p, ctypes.POINTER(ctypes.c_float), ctypes.c_int\n)\n# typedef void (*ggml_from_float_t)(const float * x, void * y, int k);\nggml_from_float_t = ctypes.CFUNCTYPE(\n    None, ctypes.POINTER(ctypes.c_float), ctypes.c_void_p, ctypes.c_int\n)\n# typedef void (*ggml_vec_dot_t)(const int n, float * s, const void * x, const void * y);\nggml_vec_dot_t = ctypes.CFUNCTYPE(\n    None, ctypes.c_int, ctypes.POINTER(ctypes.c_float), ctypes.c_void_p, ctypes.c_void_p",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_from_float_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_from_float_t = ctypes.CFUNCTYPE(\n    None, ctypes.POINTER(ctypes.c_float), ctypes.c_void_p, ctypes.c_int\n)\n# typedef void (*ggml_vec_dot_t)(const int n, float * s, const void * x, const void * y);\nggml_vec_dot_t = ctypes.CFUNCTYPE(\n    None, ctypes.c_int, ctypes.POINTER(ctypes.c_float), ctypes.c_void_p, ctypes.c_void_p\n)\n# typedef struct {\n#     const char      * type_name;\n#     int               blck_size;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_vec_dot_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_vec_dot_t = ctypes.CFUNCTYPE(\n    None, ctypes.c_int, ctypes.POINTER(ctypes.c_float), ctypes.c_void_p, ctypes.c_void_p\n)\n# typedef struct {\n#     const char      * type_name;\n#     int               blck_size;\n#     size_t            type_size;\n#     bool              is_quantized;\n#     ggml_to_float_t   to_float;\n#     ggml_from_float_t from_float;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_internal_get_type_traits.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_internal_get_type_traits.argtypes = [ctypes.c_int]\nlib.ggml_internal_get_type_traits.restype = ggml_type_traits_t\n#####################################################\n# GGML ALLOC API\n# source: ggml-alloc.h\n#####################################################\n# struct ggml_backend;\n# struct ggml_backend_buffer;\n# struct ggml_backend_buffer_type;\nggml_backend_t = ctypes.c_void_p",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_internal_get_type_traits.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_internal_get_type_traits.restype = ggml_type_traits_t\n#####################################################\n# GGML ALLOC API\n# source: ggml-alloc.h\n#####################################################\n# struct ggml_backend;\n# struct ggml_backend_buffer;\n# struct ggml_backend_buffer_type;\nggml_backend_t = ctypes.c_void_p\nggml_backend_buffer_p = ctypes.c_void_p",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_t = ctypes.c_void_p\nggml_backend_buffer_p = ctypes.c_void_p\nggml_backend_buffer_type_p = ctypes.c_void_p\n# //\n# // Legacy API\n# //\n# typedef struct ggml_allocr * ggml_allocr_t;\nggml_allocr_t = ctypes.c_void_p\n# // initialize allocator for use with CPU backend only\n# GGML_API ggml_allocr_t ggml_allocr_new(void * data, size_t size, size_t alignment);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_p",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_p = ctypes.c_void_p\nggml_backend_buffer_type_p = ctypes.c_void_p\n# //\n# // Legacy API\n# //\n# typedef struct ggml_allocr * ggml_allocr_t;\nggml_allocr_t = ctypes.c_void_p\n# // initialize allocator for use with CPU backend only\n# GGML_API ggml_allocr_t ggml_allocr_new(void * data, size_t size, size_t alignment);\ndef ggml_allocr_new(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_type_p",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_type_p = ctypes.c_void_p\n# //\n# // Legacy API\n# //\n# typedef struct ggml_allocr * ggml_allocr_t;\nggml_allocr_t = ctypes.c_void_p\n# // initialize allocator for use with CPU backend only\n# GGML_API ggml_allocr_t ggml_allocr_new(void * data, size_t size, size_t alignment);\ndef ggml_allocr_new(\n    data: ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_allocr_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_allocr_t = ctypes.c_void_p\n# // initialize allocator for use with CPU backend only\n# GGML_API ggml_allocr_t ggml_allocr_new(void * data, size_t size, size_t alignment);\ndef ggml_allocr_new(\n    data: ctypes.c_void_p,\n    size: Union[ctypes.c_size_t, int],\n    alignment: Union[ctypes.c_size_t, int],\n) -> ggml_allocr_t:\n    return lib.ggml_allocr_new(data, size, alignment)\nlib.ggml_allocr_new.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t]\nlib.ggml_allocr_new.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_measure(size_t alignment);\ndef ggml_allocr_new_measure(alignment: Union[ctypes.c_size_t, int]) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_measure(alignment)\nlib.ggml_allocr_new_measure.argtypes = [ctypes.c_size_t]\nlib.ggml_allocr_new_measure.restype = ggml_allocr_t\n# // initialize allocator for use with ggml-backend\n# GGML_API ggml_allocr_t ggml_allocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_allocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_allocr_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_measure(size_t alignment);\ndef ggml_allocr_new_measure(alignment: Union[ctypes.c_size_t, int]) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_measure(alignment)\nlib.ggml_allocr_new_measure.argtypes = [ctypes.c_size_t]\nlib.ggml_allocr_new_measure.restype = ggml_allocr_t\n# // initialize allocator for use with ggml-backend\n# GGML_API ggml_allocr_t ggml_allocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_allocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_from_buffer(buffer)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new_measure.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new_measure.argtypes = [ctypes.c_size_t]\nlib.ggml_allocr_new_measure.restype = ggml_allocr_t\n# // initialize allocator for use with ggml-backend\n# GGML_API ggml_allocr_t ggml_allocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_allocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_from_buffer(buffer)\nlib.ggml_allocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_allocr_new_from_buffer.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_allocr_new_from_backend(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new_measure.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new_measure.restype = ggml_allocr_t\n# // initialize allocator for use with ggml-backend\n# GGML_API ggml_allocr_t ggml_allocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_allocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_from_buffer(buffer)\nlib.ggml_allocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_allocr_new_from_buffer.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_allocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new_from_buffer.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_allocr_new_from_buffer.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_allocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_from_backend(backend, size)\nlib.ggml_allocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_allocr_new_from_backend.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_measure_from_backend(struct ggml_backend * backend);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new_from_buffer.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new_from_buffer.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_allocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_from_backend(backend, size)\nlib.ggml_allocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_allocr_new_from_backend.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_measure_from_backend(struct ggml_backend * backend);\ndef ggml_allocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_allocr_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new_from_backend.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_allocr_new_from_backend.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_measure_from_backend(struct ggml_backend * backend);\ndef ggml_allocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_measure_from_backend(backend)\nlib.ggml_allocr_new_measure_from_backend.argtypes = [ggml_backend_t]\nlib.ggml_allocr_new_measure_from_backend.restype = ggml_allocr_t\n# GGML_API struct ggml_backend_buffer * ggml_allocr_get_buffer(ggml_allocr_t alloc);\ndef ggml_allocr_get_buffer(alloc: ggml_allocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_allocr_get_buffer(alloc)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new_from_backend.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new_from_backend.restype = ggml_allocr_t\n# GGML_API ggml_allocr_t ggml_allocr_new_measure_from_backend(struct ggml_backend * backend);\ndef ggml_allocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_allocr_t:\n    return lib.ggml_allocr_new_measure_from_backend(backend)\nlib.ggml_allocr_new_measure_from_backend.argtypes = [ggml_backend_t]\nlib.ggml_allocr_new_measure_from_backend.restype = ggml_allocr_t\n# GGML_API struct ggml_backend_buffer * ggml_allocr_get_buffer(ggml_allocr_t alloc);\ndef ggml_allocr_get_buffer(alloc: ggml_allocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_allocr_get_buffer(alloc)\nlib.ggml_allocr_get_buffer.argtypes = [ggml_allocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new_measure_from_backend.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new_measure_from_backend.argtypes = [ggml_backend_t]\nlib.ggml_allocr_new_measure_from_backend.restype = ggml_allocr_t\n# GGML_API struct ggml_backend_buffer * ggml_allocr_get_buffer(ggml_allocr_t alloc);\ndef ggml_allocr_get_buffer(alloc: ggml_allocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_allocr_get_buffer(alloc)\nlib.ggml_allocr_get_buffer.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_get_buffer.restype = ggml_backend_buffer_p\n# // tell the allocator to parse nodes following the order described in the list\n# // you should call this if your graph are optimized to execute out-of-order\n# GGML_API void   ggml_allocr_set_parse_seq(ggml_allocr_t alloc, const int * list, int n);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_new_measure_from_backend.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_new_measure_from_backend.restype = ggml_allocr_t\n# GGML_API struct ggml_backend_buffer * ggml_allocr_get_buffer(ggml_allocr_t alloc);\ndef ggml_allocr_get_buffer(alloc: ggml_allocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_allocr_get_buffer(alloc)\nlib.ggml_allocr_get_buffer.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_get_buffer.restype = ggml_backend_buffer_p\n# // tell the allocator to parse nodes following the order described in the list\n# // you should call this if your graph are optimized to execute out-of-order\n# GGML_API void   ggml_allocr_set_parse_seq(ggml_allocr_t alloc, const int * list, int n);\ndef ggml_allocr_set_parse_seq(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_get_buffer.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_get_buffer.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_get_buffer.restype = ggml_backend_buffer_p\n# // tell the allocator to parse nodes following the order described in the list\n# // you should call this if your graph are optimized to execute out-of-order\n# GGML_API void   ggml_allocr_set_parse_seq(ggml_allocr_t alloc, const int * list, int n);\ndef ggml_allocr_set_parse_seq(\n    alloc: ggml_allocr_t,\n    list: \"ctypes._Pointer(ctypes.c_int)\",  # type: ignore\n    n: Union[ctypes.c_int, int],\n) -> None:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_get_buffer.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_get_buffer.restype = ggml_backend_buffer_p\n# // tell the allocator to parse nodes following the order described in the list\n# // you should call this if your graph are optimized to execute out-of-order\n# GGML_API void   ggml_allocr_set_parse_seq(ggml_allocr_t alloc, const int * list, int n);\ndef ggml_allocr_set_parse_seq(\n    alloc: ggml_allocr_t,\n    list: \"ctypes._Pointer(ctypes.c_int)\",  # type: ignore\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_allocr_set_parse_seq(alloc, list, n)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_set_parse_seq.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_set_parse_seq.argtypes = [\n    ggml_allocr_t,\n    ctypes.POINTER(ctypes.c_int),\n    ctypes.c_int,\n]\nlib.ggml_allocr_set_parse_seq.restype = None\n# GGML_API void   ggml_allocr_free       (ggml_allocr_t alloc);\ndef ggml_allocr_free(alloc: ggml_allocr_t) -> None:\n    return lib.ggml_allocr_free(alloc)\nlib.ggml_allocr_free.argtypes = [ggml_allocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_set_parse_seq.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_set_parse_seq.restype = None\n# GGML_API void   ggml_allocr_free       (ggml_allocr_t alloc);\ndef ggml_allocr_free(alloc: ggml_allocr_t) -> None:\n    return lib.ggml_allocr_free(alloc)\nlib.ggml_allocr_free.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_free.restype = None\n# GGML_API bool   ggml_allocr_is_measure (ggml_allocr_t alloc);\ndef ggml_allocr_is_measure(alloc: ggml_allocr_t) -> ctypes.c_bool:\n    return lib.ggml_allocr_is_measure(alloc)\nlib.ggml_allocr_is_measure.argtypes = [ggml_allocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_free.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_free.restype = None\n# GGML_API bool   ggml_allocr_is_measure (ggml_allocr_t alloc);\ndef ggml_allocr_is_measure(alloc: ggml_allocr_t) -> ctypes.c_bool:\n    return lib.ggml_allocr_is_measure(alloc)\nlib.ggml_allocr_is_measure.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_allocr_reset      (ggml_allocr_t alloc);\ndef ggml_allocr_reset(alloc: ggml_allocr_t) -> None:\n    return lib.ggml_allocr_reset(alloc)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_free.restype = None\n# GGML_API bool   ggml_allocr_is_measure (ggml_allocr_t alloc);\ndef ggml_allocr_is_measure(alloc: ggml_allocr_t) -> ctypes.c_bool:\n    return lib.ggml_allocr_is_measure(alloc)\nlib.ggml_allocr_is_measure.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_allocr_reset      (ggml_allocr_t alloc);\ndef ggml_allocr_reset(alloc: ggml_allocr_t) -> None:\n    return lib.ggml_allocr_reset(alloc)\nlib.ggml_allocr_reset.argtypes = [ggml_allocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_is_measure.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_is_measure.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_allocr_reset      (ggml_allocr_t alloc);\ndef ggml_allocr_reset(alloc: ggml_allocr_t) -> None:\n    return lib.ggml_allocr_reset(alloc)\nlib.ggml_allocr_reset.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_reset.restype = None\n# GGML_API void   ggml_allocr_alloc      (ggml_allocr_t alloc, struct ggml_tensor * tensor);\ndef ggml_allocr_alloc(alloc: ggml_allocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_allocr_alloc(alloc, tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_is_measure.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_allocr_reset      (ggml_allocr_t alloc);\ndef ggml_allocr_reset(alloc: ggml_allocr_t) -> None:\n    return lib.ggml_allocr_reset(alloc)\nlib.ggml_allocr_reset.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_reset.restype = None\n# GGML_API void   ggml_allocr_alloc      (ggml_allocr_t alloc, struct ggml_tensor * tensor);\ndef ggml_allocr_alloc(alloc: ggml_allocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_allocr_alloc(alloc, tensor)\nlib.ggml_allocr_alloc.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_reset.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_reset.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_reset.restype = None\n# GGML_API void   ggml_allocr_alloc      (ggml_allocr_t alloc, struct ggml_tensor * tensor);\ndef ggml_allocr_alloc(alloc: ggml_allocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_allocr_alloc(alloc, tensor)\nlib.ggml_allocr_alloc.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_allocr_alloc.restype = None\n# GGML_API size_t ggml_allocr_max_size   (ggml_allocr_t alloc);\ndef ggml_allocr_max_size(alloc: ggml_allocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_allocr_max_size(alloc)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_reset.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_reset.restype = None\n# GGML_API void   ggml_allocr_alloc      (ggml_allocr_t alloc, struct ggml_tensor * tensor);\ndef ggml_allocr_alloc(alloc: ggml_allocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_allocr_alloc(alloc, tensor)\nlib.ggml_allocr_alloc.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_allocr_alloc.restype = None\n# GGML_API size_t ggml_allocr_max_size   (ggml_allocr_t alloc);\ndef ggml_allocr_max_size(alloc: ggml_allocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_allocr_max_size(alloc)\nlib.ggml_allocr_max_size.argtypes = [ggml_allocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_alloc.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_alloc.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_allocr_alloc.restype = None\n# GGML_API size_t ggml_allocr_max_size   (ggml_allocr_t alloc);\ndef ggml_allocr_max_size(alloc: ggml_allocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_allocr_max_size(alloc)\nlib.ggml_allocr_max_size.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_max_size.restype = ctypes.c_size_t\n# GGML_API size_t ggml_allocr_alloc_graph(ggml_allocr_t alloc, struct ggml_cgraph * graph);\ndef ggml_allocr_alloc_graph(alloc: ggml_allocr_t, graph: ggml_cgraph_p) -> int:\n    return lib.ggml_allocr_alloc_graph(alloc, graph)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_alloc.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_alloc.restype = None\n# GGML_API size_t ggml_allocr_max_size   (ggml_allocr_t alloc);\ndef ggml_allocr_max_size(alloc: ggml_allocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_allocr_max_size(alloc)\nlib.ggml_allocr_max_size.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_max_size.restype = ctypes.c_size_t\n# GGML_API size_t ggml_allocr_alloc_graph(ggml_allocr_t alloc, struct ggml_cgraph * graph);\ndef ggml_allocr_alloc_graph(alloc: ggml_allocr_t, graph: ggml_cgraph_p) -> int:\n    return lib.ggml_allocr_alloc_graph(alloc, graph)\nlib.ggml_allocr_alloc_graph.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_cgraph)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_max_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_max_size.argtypes = [ggml_allocr_t]\nlib.ggml_allocr_max_size.restype = ctypes.c_size_t\n# GGML_API size_t ggml_allocr_alloc_graph(ggml_allocr_t alloc, struct ggml_cgraph * graph);\ndef ggml_allocr_alloc_graph(alloc: ggml_allocr_t, graph: ggml_cgraph_p) -> int:\n    return lib.ggml_allocr_alloc_graph(alloc, graph)\nlib.ggml_allocr_alloc_graph.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_cgraph)]\nlib.ggml_allocr_alloc_graph.restype = ctypes.c_size_t\n# //\n# // ggml-backend v2 API\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_max_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_max_size.restype = ctypes.c_size_t\n# GGML_API size_t ggml_allocr_alloc_graph(ggml_allocr_t alloc, struct ggml_cgraph * graph);\ndef ggml_allocr_alloc_graph(alloc: ggml_allocr_t, graph: ggml_cgraph_p) -> int:\n    return lib.ggml_allocr_alloc_graph(alloc, graph)\nlib.ggml_allocr_alloc_graph.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_cgraph)]\nlib.ggml_allocr_alloc_graph.restype = ctypes.c_size_t\n# //\n# // ggml-backend v2 API\n# //\n# // Separate tensor and graph allocator objects",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_alloc_graph.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_alloc_graph.argtypes = [ggml_allocr_t, ctypes.POINTER(ggml_cgraph)]\nlib.ggml_allocr_alloc_graph.restype = ctypes.c_size_t\n# //\n# // ggml-backend v2 API\n# //\n# // Separate tensor and graph allocator objects\n# // This is necessary for multi-backend allocation because the graph allocator needs to use multiple tensor allocators\n# // The original API is kept as a wrapper around the new API\n# // Tensor allocator\n# typedef struct ggml_tallocr * ggml_tallocr_t;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_allocr_alloc_graph.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_allocr_alloc_graph.restype = ctypes.c_size_t\n# //\n# // ggml-backend v2 API\n# //\n# // Separate tensor and graph allocator objects\n# // This is necessary for multi-backend allocation because the graph allocator needs to use multiple tensor allocators\n# // The original API is kept as a wrapper around the new API\n# // Tensor allocator\n# typedef struct ggml_tallocr * ggml_tallocr_t;\nggml_tallocr_t = ctypes.c_void_p",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_tallocr_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_tallocr_t = ctypes.c_void_p\n# GGML_API ggml_tallocr_t ggml_tallocr_new(void * data, size_t size, size_t alignment);\ndef ggml_tallocr_new(\n    data: ctypes.c_void_p,\n    size: Union[ctypes.c_size_t, int],\n    alignment: Union[ctypes.c_size_t, int],\n) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new(data, size, alignment)\nlib.ggml_tallocr_new.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t]\nlib.ggml_tallocr_new.restype = ggml_tallocr_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t]\nlib.ggml_tallocr_new.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_measure(size_t alignment);\ndef ggml_tallocr_new_measure(alignment: Union[ctypes.c_size_t, int]) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_measure(alignment)\nlib.ggml_tallocr_new_measure.argtypes = [ctypes.c_size_t]\nlib.ggml_tallocr_new_measure.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_tallocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_buffer(buffer)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_measure(size_t alignment);\ndef ggml_tallocr_new_measure(alignment: Union[ctypes.c_size_t, int]) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_measure(alignment)\nlib.ggml_tallocr_new_measure.argtypes = [ctypes.c_size_t]\nlib.ggml_tallocr_new_measure.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_tallocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_buffer(buffer)\nlib.ggml_tallocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new_measure.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new_measure.argtypes = [ctypes.c_size_t]\nlib.ggml_tallocr_new_measure.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_tallocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_buffer(buffer)\nlib.ggml_tallocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_tallocr_new_from_buffer.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_tallocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new_measure.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new_measure.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_buffer(struct ggml_backend_buffer * buffer);\ndef ggml_tallocr_new_from_buffer(buffer: ggml_backend_buffer_p) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_buffer(buffer)\nlib.ggml_tallocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_tallocr_new_from_buffer.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_tallocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_tallocr_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new_from_buffer.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new_from_buffer.argtypes = [ggml_backend_buffer_p]\nlib.ggml_tallocr_new_from_buffer.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_tallocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_backend(backend, size)\nlib.ggml_tallocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_tallocr_new_from_backend.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_measure_from_backend(struct ggml_backend * backend);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new_from_buffer.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new_from_buffer.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_from_backend(struct ggml_backend * backend, size_t size); // allocates an owned buffer\ndef ggml_tallocr_new_from_backend(\n    backend: ggml_backend_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_from_backend(backend, size)\nlib.ggml_tallocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_tallocr_new_from_backend.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_measure_from_backend(struct ggml_backend * backend);\ndef ggml_tallocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_tallocr_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new_from_backend.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new_from_backend.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_tallocr_new_from_backend.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_measure_from_backend(struct ggml_backend * backend);\ndef ggml_tallocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_measure_from_backend(backend)\nlib.ggml_tallocr_new_measure_from_backend.argtypes = [ggml_backend_t]\nlib.ggml_tallocr_new_measure_from_backend.restype = ggml_tallocr_t\n# GGML_API struct ggml_backend_buffer * ggml_tallocr_get_buffer(ggml_tallocr_t talloc);\ndef ggml_tallocr_get_buffer(talloc: ggml_tallocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_tallocr_get_buffer(talloc)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new_from_backend.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new_from_backend.restype = ggml_tallocr_t\n# GGML_API ggml_tallocr_t ggml_tallocr_new_measure_from_backend(struct ggml_backend * backend);\ndef ggml_tallocr_new_measure_from_backend(backend: ggml_backend_t) -> ggml_tallocr_t:\n    return lib.ggml_tallocr_new_measure_from_backend(backend)\nlib.ggml_tallocr_new_measure_from_backend.argtypes = [ggml_backend_t]\nlib.ggml_tallocr_new_measure_from_backend.restype = ggml_tallocr_t\n# GGML_API struct ggml_backend_buffer * ggml_tallocr_get_buffer(ggml_tallocr_t talloc);\ndef ggml_tallocr_get_buffer(talloc: ggml_tallocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_tallocr_get_buffer(talloc)\nlib.ggml_tallocr_get_buffer.argtypes = [ggml_tallocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new_measure_from_backend.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new_measure_from_backend.argtypes = [ggml_backend_t]\nlib.ggml_tallocr_new_measure_from_backend.restype = ggml_tallocr_t\n# GGML_API struct ggml_backend_buffer * ggml_tallocr_get_buffer(ggml_tallocr_t talloc);\ndef ggml_tallocr_get_buffer(talloc: ggml_tallocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_tallocr_get_buffer(talloc)\nlib.ggml_tallocr_get_buffer.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_get_buffer.restype = ggml_backend_buffer_p\n# GGML_API void   ggml_tallocr_free       (ggml_tallocr_t talloc);\ndef ggml_tallocr_free(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_free(talloc)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_new_measure_from_backend.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_new_measure_from_backend.restype = ggml_tallocr_t\n# GGML_API struct ggml_backend_buffer * ggml_tallocr_get_buffer(ggml_tallocr_t talloc);\ndef ggml_tallocr_get_buffer(talloc: ggml_tallocr_t) -> ggml_backend_buffer_p:\n    return lib.ggml_tallocr_get_buffer(talloc)\nlib.ggml_tallocr_get_buffer.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_get_buffer.restype = ggml_backend_buffer_p\n# GGML_API void   ggml_tallocr_free       (ggml_tallocr_t talloc);\ndef ggml_tallocr_free(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_free(talloc)\nlib.ggml_tallocr_free.argtypes = [ggml_tallocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_get_buffer.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_get_buffer.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_get_buffer.restype = ggml_backend_buffer_p\n# GGML_API void   ggml_tallocr_free       (ggml_tallocr_t talloc);\ndef ggml_tallocr_free(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_free(talloc)\nlib.ggml_tallocr_free.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_free.restype = None\n# GGML_API bool   ggml_tallocr_is_measure (ggml_tallocr_t talloc);\ndef ggml_tallocr_is_measure(talloc: ggml_tallocr_t) -> bool:\n    return lib.ggml_tallocr_is_measure(talloc)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_get_buffer.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_get_buffer.restype = ggml_backend_buffer_p\n# GGML_API void   ggml_tallocr_free       (ggml_tallocr_t talloc);\ndef ggml_tallocr_free(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_free(talloc)\nlib.ggml_tallocr_free.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_free.restype = None\n# GGML_API bool   ggml_tallocr_is_measure (ggml_tallocr_t talloc);\ndef ggml_tallocr_is_measure(talloc: ggml_tallocr_t) -> bool:\n    return lib.ggml_tallocr_is_measure(talloc)\nlib.ggml_tallocr_is_measure.argtypes = [ggml_tallocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_free.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_free.restype = None\n# GGML_API bool   ggml_tallocr_is_measure (ggml_tallocr_t talloc);\ndef ggml_tallocr_is_measure(talloc: ggml_tallocr_t) -> bool:\n    return lib.ggml_tallocr_is_measure(talloc)\nlib.ggml_tallocr_is_measure.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_tallocr_reset      (ggml_tallocr_t talloc);\ndef ggml_tallocr_reset(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_reset(talloc)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_free.restype = None\n# GGML_API bool   ggml_tallocr_is_measure (ggml_tallocr_t talloc);\ndef ggml_tallocr_is_measure(talloc: ggml_tallocr_t) -> bool:\n    return lib.ggml_tallocr_is_measure(talloc)\nlib.ggml_tallocr_is_measure.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_tallocr_reset      (ggml_tallocr_t talloc);\ndef ggml_tallocr_reset(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_reset(talloc)\nlib.ggml_tallocr_reset.argtypes = [ggml_tallocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_is_measure.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_is_measure.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_tallocr_reset      (ggml_tallocr_t talloc);\ndef ggml_tallocr_reset(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_reset(talloc)\nlib.ggml_tallocr_reset.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_reset.restype = None\n# GGML_API void   ggml_tallocr_alloc      (ggml_tallocr_t talloc, struct ggml_tensor * tensor);\ndef ggml_tallocr_alloc(talloc: ggml_tallocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_tallocr_alloc(talloc, tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_is_measure.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_is_measure.restype = ctypes.c_bool\n# GGML_API void   ggml_tallocr_reset      (ggml_tallocr_t talloc);\ndef ggml_tallocr_reset(talloc: ggml_tallocr_t) -> None:\n    return lib.ggml_tallocr_reset(talloc)\nlib.ggml_tallocr_reset.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_reset.restype = None\n# GGML_API void   ggml_tallocr_alloc      (ggml_tallocr_t talloc, struct ggml_tensor * tensor);\ndef ggml_tallocr_alloc(talloc: ggml_tallocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_tallocr_alloc(talloc, tensor)\nlib.ggml_tallocr_alloc.argtypes = [ggml_tallocr_t, ctypes.POINTER(ggml_tensor)]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_reset.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_reset.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_reset.restype = None\n# GGML_API void   ggml_tallocr_alloc      (ggml_tallocr_t talloc, struct ggml_tensor * tensor);\ndef ggml_tallocr_alloc(talloc: ggml_tallocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_tallocr_alloc(talloc, tensor)\nlib.ggml_tallocr_alloc.argtypes = [ggml_tallocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_tallocr_alloc.restype = None\n# GGML_API size_t ggml_tallocr_max_size   (ggml_tallocr_t talloc);\ndef ggml_tallocr_max_size(talloc: ggml_tallocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_tallocr_max_size(talloc)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_reset.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_reset.restype = None\n# GGML_API void   ggml_tallocr_alloc      (ggml_tallocr_t talloc, struct ggml_tensor * tensor);\ndef ggml_tallocr_alloc(talloc: ggml_tallocr_t, tensor: ggml_tensor_p) -> None:\n    return lib.ggml_tallocr_alloc(talloc, tensor)\nlib.ggml_tallocr_alloc.argtypes = [ggml_tallocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_tallocr_alloc.restype = None\n# GGML_API size_t ggml_tallocr_max_size   (ggml_tallocr_t talloc);\ndef ggml_tallocr_max_size(talloc: ggml_tallocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_tallocr_max_size(talloc)\nlib.ggml_tallocr_max_size.argtypes = [ggml_tallocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_alloc.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_alloc.argtypes = [ggml_tallocr_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_tallocr_alloc.restype = None\n# GGML_API size_t ggml_tallocr_max_size   (ggml_tallocr_t talloc);\ndef ggml_tallocr_max_size(talloc: ggml_tallocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_tallocr_max_size(talloc)\nlib.ggml_tallocr_max_size.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_max_size.restype = ctypes.c_size_t\n# // Graph allocator\n# typedef struct ggml_gallocr * ggml_gallocr_t;\nggml_gallocr_t = ctypes.c_void_p",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_alloc.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_alloc.restype = None\n# GGML_API size_t ggml_tallocr_max_size   (ggml_tallocr_t talloc);\ndef ggml_tallocr_max_size(talloc: ggml_tallocr_t) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_tallocr_max_size(talloc)\nlib.ggml_tallocr_max_size.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_max_size.restype = ctypes.c_size_t\n# // Graph allocator\n# typedef struct ggml_gallocr * ggml_gallocr_t;\nggml_gallocr_t = ctypes.c_void_p\n# GGML_API ggml_gallocr_t ggml_gallocr_new(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_max_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_max_size.argtypes = [ggml_tallocr_t]\nlib.ggml_tallocr_max_size.restype = ctypes.c_size_t\n# // Graph allocator\n# typedef struct ggml_gallocr * ggml_gallocr_t;\nggml_gallocr_t = ctypes.c_void_p\n# GGML_API ggml_gallocr_t ggml_gallocr_new(void);\ndef ggml_gallocr_new() -> ggml_gallocr_t:\n    return lib.ggml_gallocr_new()\nlib.ggml_gallocr_new.argtypes = []\nlib.ggml_gallocr_new.restype = ggml_gallocr_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_tallocr_max_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_tallocr_max_size.restype = ctypes.c_size_t\n# // Graph allocator\n# typedef struct ggml_gallocr * ggml_gallocr_t;\nggml_gallocr_t = ctypes.c_void_p\n# GGML_API ggml_gallocr_t ggml_gallocr_new(void);\ndef ggml_gallocr_new() -> ggml_gallocr_t:\n    return lib.ggml_gallocr_new()\nlib.ggml_gallocr_new.argtypes = []\nlib.ggml_gallocr_new.restype = ggml_gallocr_t\n# GGML_API void   ggml_gallocr_free(ggml_gallocr_t galloc);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_gallocr_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_gallocr_t = ctypes.c_void_p\n# GGML_API ggml_gallocr_t ggml_gallocr_new(void);\ndef ggml_gallocr_new() -> ggml_gallocr_t:\n    return lib.ggml_gallocr_new()\nlib.ggml_gallocr_new.argtypes = []\nlib.ggml_gallocr_new.restype = ggml_gallocr_t\n# GGML_API void   ggml_gallocr_free(ggml_gallocr_t galloc);\ndef ggml_gallocr_free(galloc: ggml_gallocr_t) -> None:\n    return lib.ggml_gallocr_free(galloc)\nlib.ggml_gallocr_free.argtypes = [ggml_gallocr_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_new.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_new.argtypes = []\nlib.ggml_gallocr_new.restype = ggml_gallocr_t\n# GGML_API void   ggml_gallocr_free(ggml_gallocr_t galloc);\ndef ggml_gallocr_free(galloc: ggml_gallocr_t) -> None:\n    return lib.ggml_gallocr_free(galloc)\nlib.ggml_gallocr_free.argtypes = [ggml_gallocr_t]\nlib.ggml_gallocr_free.restype = None\n# GGML_API void   ggml_gallocr_set_parse_seq(ggml_gallocr_t galloc, const int * list, int n);\ndef ggml_gallocr_set_parse_seq(\n    galloc: ggml_gallocr_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_new.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_new.restype = ggml_gallocr_t\n# GGML_API void   ggml_gallocr_free(ggml_gallocr_t galloc);\ndef ggml_gallocr_free(galloc: ggml_gallocr_t) -> None:\n    return lib.ggml_gallocr_free(galloc)\nlib.ggml_gallocr_free.argtypes = [ggml_gallocr_t]\nlib.ggml_gallocr_free.restype = None\n# GGML_API void   ggml_gallocr_set_parse_seq(ggml_gallocr_t galloc, const int * list, int n);\ndef ggml_gallocr_set_parse_seq(\n    galloc: ggml_gallocr_t,\n    list: \"ctypes._Pointer(ctypes.c_int)\",  # type: ignore",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_free.argtypes = [ggml_gallocr_t]\nlib.ggml_gallocr_free.restype = None\n# GGML_API void   ggml_gallocr_set_parse_seq(ggml_gallocr_t galloc, const int * list, int n);\ndef ggml_gallocr_set_parse_seq(\n    galloc: ggml_gallocr_t,\n    list: \"ctypes._Pointer(ctypes.c_int)\",  # type: ignore\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_gallocr_set_parse_seq(galloc, list, n)\nlib.ggml_gallocr_set_parse_seq.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_free.restype = None\n# GGML_API void   ggml_gallocr_set_parse_seq(ggml_gallocr_t galloc, const int * list, int n);\ndef ggml_gallocr_set_parse_seq(\n    galloc: ggml_gallocr_t,\n    list: \"ctypes._Pointer(ctypes.c_int)\",  # type: ignore\n    n: Union[ctypes.c_int, int],\n) -> None:\n    return lib.ggml_gallocr_set_parse_seq(galloc, list, n)\nlib.ggml_gallocr_set_parse_seq.argtypes = [\n    ggml_gallocr_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_set_parse_seq.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_set_parse_seq.argtypes = [\n    ggml_gallocr_t,\n    ctypes.POINTER(ctypes.c_int),\n    ctypes.c_int,\n]\nlib.ggml_gallocr_set_parse_seq.restype = None\n# GGML_API size_t ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, ggml_tallocr_t talloc, struct ggml_cgraph * graph);\ndef ggml_gallocr_alloc_graph(\n    galloc: ggml_gallocr_t, talloc: ggml_tallocr_t, graph: ggml_cgraph_p\n) -> Union[ctypes.c_size_t, int]:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_set_parse_seq.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_set_parse_seq.restype = None\n# GGML_API size_t ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, ggml_tallocr_t talloc, struct ggml_cgraph * graph);\ndef ggml_gallocr_alloc_graph(\n    galloc: ggml_gallocr_t, talloc: ggml_tallocr_t, graph: ggml_cgraph_p\n) -> Union[ctypes.c_size_t, int]:\n    return lib.ggml_gallocr_alloc_graph(galloc, talloc, graph)\nlib.ggml_gallocr_alloc_graph.argtypes = [\n    ggml_gallocr_t,\n    ggml_tallocr_t,\n    ctypes.POINTER(ggml_cgraph),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_alloc_graph.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_alloc_graph.argtypes = [\n    ggml_gallocr_t,\n    ggml_tallocr_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_gallocr_alloc_graph.restype = ctypes.c_size_t\n# // Allocate tensors from the allocators given by the hash table\n# GGML_API void   ggml_gallocr_alloc_graph_n(\n#                     ggml_gallocr_t galloc,\n#                     struct ggml_cgraph * graph,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_alloc_graph.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_alloc_graph.restype = ctypes.c_size_t\n# // Allocate tensors from the allocators given by the hash table\n# GGML_API void   ggml_gallocr_alloc_graph_n(\n#                     ggml_gallocr_t galloc,\n#                     struct ggml_cgraph * graph,\n#                     struct ggml_hash_set hash_set,\n#                     ggml_tallocr_t * hash_node_talloc);\ndef ggml_gallocr_alloc_graph_n(\n    galloc: ggml_gallocr_t,\n    graph: ggml_cgraph_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_alloc_graph_n.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_alloc_graph_n.argtypes = [\n    ggml_gallocr_t,\n    ctypes.POINTER(ggml_cgraph),\n    ggml_hash_set,\n    ctypes.POINTER(ggml_tallocr_t),\n]\nlib.ggml_gallocr_alloc_graph_n.restype = None\n# // Utils\n# // Create a buffer and allocate all the tensors in a ggml_context\n# GGML_API struct ggml_backend_buffer * ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context * ctx, struct ggml_backend_buffer_type * buft);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_gallocr_alloc_graph_n.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_gallocr_alloc_graph_n.restype = None\n# // Utils\n# // Create a buffer and allocate all the tensors in a ggml_context\n# GGML_API struct ggml_backend_buffer * ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context * ctx, struct ggml_backend_buffer_type * buft);\ndef ggml_backend_alloc_ctx_tensors_from_buft(\n    ctx: ggml_context_p, buft: ggml_backend_buffer_type_p\n) -> ggml_backend_buffer_p:\n    return lib.ggml_backend_alloc_ctx_tensors_from_buft(ctx, buft)\nlib.ggml_backend_alloc_ctx_tensors_from_buft.argtypes = [\n    ggml_context_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_alloc_ctx_tensors_from_buft.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_alloc_ctx_tensors_from_buft.argtypes = [\n    ggml_context_p,\n    ggml_backend_buffer_type_p,\n]\nlib.ggml_backend_alloc_ctx_tensors_from_buft.restype = ggml_backend_buffer_p\n# GGML_API struct ggml_backend_buffer * ggml_backend_alloc_ctx_tensors(struct ggml_context * ctx, struct ggml_backend * backend);\ndef ggml_backend_alloc_ctx_tensors(\n    ctx: ggml_context_p, backend: ggml_backend_t\n) -> ggml_backend_buffer_p:\n    return lib.ggml_backend_alloc_ctx_tensors(ctx, backend)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_alloc_ctx_tensors_from_buft.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_alloc_ctx_tensors_from_buft.restype = ggml_backend_buffer_p\n# GGML_API struct ggml_backend_buffer * ggml_backend_alloc_ctx_tensors(struct ggml_context * ctx, struct ggml_backend * backend);\ndef ggml_backend_alloc_ctx_tensors(\n    ctx: ggml_context_p, backend: ggml_backend_t\n) -> ggml_backend_buffer_p:\n    return lib.ggml_backend_alloc_ctx_tensors(ctx, backend)\nlib.ggml_backend_alloc_ctx_tensors.argtypes = [\n    ggml_context_p,\n    ggml_backend_t,\n]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_alloc_ctx_tensors.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_alloc_ctx_tensors.argtypes = [\n    ggml_context_p,\n    ggml_backend_t,\n]\nlib.ggml_backend_alloc_ctx_tensors.restype = ggml_backend_buffer_p\n#####################################################\n# GGML Backend API\n# source: ggml-backend.h\n#####################################################\n# typedef struct ggml_backend_buffer_type * ggml_backend_buffer_type_t;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_alloc_ctx_tensors.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_alloc_ctx_tensors.restype = ggml_backend_buffer_p\n#####################################################\n# GGML Backend API\n# source: ggml-backend.h\n#####################################################\n# typedef struct ggml_backend_buffer_type * ggml_backend_buffer_type_t;\n# typedef struct ggml_backend_buffer * ggml_backend_buffer_t;\n# typedef struct ggml_backend * ggml_backend_t;\n# typedef void * ggml_backend_graph_plan_t;\nggml_backend_buffer_type_t = ctypes.c_void_p",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_type_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_type_t = ctypes.c_void_p\nggml_backend_buffer_t = ctypes.c_void_p\nggml_backend_t = ctypes.c_void_p\nggml_backend_graph_plan_t = ctypes.c_void_p\n# //\n# // Backend buffer\n# //\n# // buffer type\n# GGML_API ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size);\ndef ggml_backend_buft_alloc_buffer(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_t = ctypes.c_void_p\nggml_backend_t = ctypes.c_void_p\nggml_backend_graph_plan_t = ctypes.c_void_p\n# //\n# // Backend buffer\n# //\n# // buffer type\n# GGML_API ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size);\ndef ggml_backend_buft_alloc_buffer(\n    buft: ggml_backend_buffer_type_t, size: Union[ctypes.c_size_t, int]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_t = ctypes.c_void_p\nggml_backend_graph_plan_t = ctypes.c_void_p\n# //\n# // Backend buffer\n# //\n# // buffer type\n# GGML_API ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size);\ndef ggml_backend_buft_alloc_buffer(\n    buft: ggml_backend_buffer_type_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_backend_buffer_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_graph_plan_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_graph_plan_t = ctypes.c_void_p\n# //\n# // Backend buffer\n# //\n# // buffer type\n# GGML_API ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size);\ndef ggml_backend_buft_alloc_buffer(\n    buft: ggml_backend_buffer_type_t, size: Union[ctypes.c_size_t, int]\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_buft_alloc_buffer(buft, size)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buft_alloc_buffer.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buft_alloc_buffer.argtypes = [\n    ggml_backend_buffer_type_t,\n    ctypes.c_size_t,\n]\nlib.ggml_backend_buft_alloc_buffer.restype = ggml_backend_buffer_t\n# GGML_API size_t ggml_backend_buft_get_alignment (ggml_backend_buffer_type_t buft);\ndef ggml_backend_buft_get_alignment(\n    buft: ggml_backend_buffer_type_t,\n) -> int:\n    return lib.ggml_backend_buft_get_alignment(buft)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buft_alloc_buffer.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buft_alloc_buffer.restype = ggml_backend_buffer_t\n# GGML_API size_t ggml_backend_buft_get_alignment (ggml_backend_buffer_type_t buft);\ndef ggml_backend_buft_get_alignment(\n    buft: ggml_backend_buffer_type_t,\n) -> int:\n    return lib.ggml_backend_buft_get_alignment(buft)\nlib.ggml_backend_buft_get_alignment.argtypes = [ggml_backend_buffer_type_t]\nlib.ggml_backend_buft_get_alignment.restype = ctypes.c_size_t\n# GGML_API size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, struct ggml_tensor * tensor);\ndef ggml_backend_buft_get_alloc_size(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buft_get_alignment.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buft_get_alignment.argtypes = [ggml_backend_buffer_type_t]\nlib.ggml_backend_buft_get_alignment.restype = ctypes.c_size_t\n# GGML_API size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, struct ggml_tensor * tensor);\ndef ggml_backend_buft_get_alloc_size(\n    buft: ggml_backend_buffer_type_t, tensor: ggml_tensor_p\n) -> int:\n    return lib.ggml_backend_buft_get_alloc_size(buft, tensor)\nlib.ggml_backend_buft_get_alloc_size.argtypes = [\n    ggml_backend_buffer_type_t,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buft_get_alignment.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buft_get_alignment.restype = ctypes.c_size_t\n# GGML_API size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, struct ggml_tensor * tensor);\ndef ggml_backend_buft_get_alloc_size(\n    buft: ggml_backend_buffer_type_t, tensor: ggml_tensor_p\n) -> int:\n    return lib.ggml_backend_buft_get_alloc_size(buft, tensor)\nlib.ggml_backend_buft_get_alloc_size.argtypes = [\n    ggml_backend_buffer_type_t,\n    ctypes.POINTER(ggml_tensor),\n]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buft_get_alloc_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buft_get_alloc_size.argtypes = [\n    ggml_backend_buffer_type_t,\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_buft_get_alloc_size.restype = ctypes.c_size_t\n# GGML_API bool ggml_backend_buft_supports_backend(ggml_backend_buffer_type_t buft, ggml_backend_t backend);\ndef ggml_backend_buft_supports_backend(\n    buft: ggml_backend_buffer_type_t, backend: ggml_backend_t\n) -> bool:\n    return lib.ggml_backend_buft_supports_backend(buft, backend)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buft_get_alloc_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buft_get_alloc_size.restype = ctypes.c_size_t\n# GGML_API bool ggml_backend_buft_supports_backend(ggml_backend_buffer_type_t buft, ggml_backend_t backend);\ndef ggml_backend_buft_supports_backend(\n    buft: ggml_backend_buffer_type_t, backend: ggml_backend_t\n) -> bool:\n    return lib.ggml_backend_buft_supports_backend(buft, backend)\nlib.ggml_backend_buft_supports_backend.argtypes = [\n    ggml_backend_buffer_type_t,\n    ggml_backend_t,\n]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buft_supports_backend.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buft_supports_backend.argtypes = [\n    ggml_backend_buffer_type_t,\n    ggml_backend_t,\n]\nlib.ggml_backend_buft_supports_backend.restype = ctypes.c_bool\n# // buffer\n# GGML_API void   ggml_backend_buffer_free          (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_free(\n    buffer: ggml_backend_buffer_t,\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buft_supports_backend.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buft_supports_backend.restype = ctypes.c_bool\n# // buffer\n# GGML_API void   ggml_backend_buffer_free          (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_free(\n    buffer: ggml_backend_buffer_t,\n):\n    return lib.ggml_backend_buffer_free(buffer)\nlib.ggml_backend_buffer_free.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_free.restype = None\n# GGML_API void * ggml_backend_buffer_get_base      (ggml_backend_buffer_t buffer);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_free.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_free.restype = None\n# GGML_API void * ggml_backend_buffer_get_base      (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_get_base(\n    buffer: ggml_backend_buffer_t,\n) -> ctypes.c_void_p:\n    return lib.ggml_backend_buffer_get_base(buffer)\nlib.ggml_backend_buffer_get_base.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_base.restype = ctypes.c_void_p\n# GGML_API size_t ggml_backend_buffer_get_size      (ggml_backend_buffer_t buffer);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_free.restype = None\n# GGML_API void * ggml_backend_buffer_get_base      (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_get_base(\n    buffer: ggml_backend_buffer_t,\n) -> ctypes.c_void_p:\n    return lib.ggml_backend_buffer_get_base(buffer)\nlib.ggml_backend_buffer_get_base.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_base.restype = ctypes.c_void_p\n# GGML_API size_t ggml_backend_buffer_get_size      (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_get_size(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_get_base.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_get_base.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_base.restype = ctypes.c_void_p\n# GGML_API size_t ggml_backend_buffer_get_size      (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_get_size(\n    buffer: ggml_backend_buffer_t,\n) -> int:\n    return lib.ggml_backend_buffer_get_size(buffer)\nlib.ggml_backend_buffer_get_size.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_size.restype = ctypes.c_size_t\n# GGML_API void   ggml_backend_buffer_init_tensor   (ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_get_base.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_get_base.restype = ctypes.c_void_p\n# GGML_API size_t ggml_backend_buffer_get_size      (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_get_size(\n    buffer: ggml_backend_buffer_t,\n) -> int:\n    return lib.ggml_backend_buffer_get_size(buffer)\nlib.ggml_backend_buffer_get_size.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_size.restype = ctypes.c_size_t\n# GGML_API void   ggml_backend_buffer_init_tensor   (ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_buffer_init_tensor(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_get_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_get_size.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_size.restype = ctypes.c_size_t\n# GGML_API void   ggml_backend_buffer_init_tensor   (ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_buffer_init_tensor(\n    buffer: ggml_backend_buffer_t,\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_backend_buffer_init_tensor(buffer, tensor)\nlib.ggml_backend_buffer_init_tensor.argtypes = [\n    ggml_backend_buffer_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_get_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_get_size.restype = ctypes.c_size_t\n# GGML_API void   ggml_backend_buffer_init_tensor   (ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_buffer_init_tensor(\n    buffer: ggml_backend_buffer_t,\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_backend_buffer_init_tensor(buffer, tensor)\nlib.ggml_backend_buffer_init_tensor.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_init_tensor.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_init_tensor.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_buffer_init_tensor.restype = None\n# GGML_API size_t ggml_backend_buffer_get_alignment (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_get_alignment(\n    buffer: ggml_backend_buffer_t,\n) -> int:\n    return lib.ggml_backend_buffer_get_alignment(buffer)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_init_tensor.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_init_tensor.restype = None\n# GGML_API size_t ggml_backend_buffer_get_alignment (ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_get_alignment(\n    buffer: ggml_backend_buffer_t,\n) -> int:\n    return lib.ggml_backend_buffer_get_alignment(buffer)\nlib.ggml_backend_buffer_get_alignment.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_alignment.restype = ctypes.c_size_t\n# GGML_API size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_buffer_get_alloc_size(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_get_alignment.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_get_alignment.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_get_alignment.restype = ctypes.c_size_t\n# GGML_API size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_buffer_get_alloc_size(\n    buffer: ggml_backend_buffer_t, tensor: ggml_tensor_p\n) -> int:\n    return lib.ggml_backend_buffer_get_alloc_size(buffer, tensor)\nlib.ggml_backend_buffer_get_alloc_size.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_get_alignment.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_get_alignment.restype = ctypes.c_size_t\n# GGML_API size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_buffer_get_alloc_size(\n    buffer: ggml_backend_buffer_t, tensor: ggml_tensor_p\n) -> int:\n    return lib.ggml_backend_buffer_get_alloc_size(buffer, tensor)\nlib.ggml_backend_buffer_get_alloc_size.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_get_alloc_size.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_get_alloc_size.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_buffer_get_alloc_size.restype = ctypes.c_size_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_buffer_type(ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_type(\n    buffer: ggml_backend_buffer_t,\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_buffer_type(buffer)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_get_alloc_size.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_get_alloc_size.restype = ctypes.c_size_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_buffer_type(ggml_backend_buffer_t buffer);\ndef ggml_backend_buffer_type(\n    buffer: ggml_backend_buffer_t,\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_buffer_type(buffer)\nlib.ggml_backend_buffer_type.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_type.restype = ggml_backend_buffer_type_t\n# //\n# // Backend",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_type.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_type.argtypes = [ggml_backend_buffer_t]\nlib.ggml_backend_buffer_type.restype = ggml_backend_buffer_type_t\n# //\n# // Backend\n# //\n# GGML_API const char * ggml_backend_name(ggml_backend_t backend);\ndef ggml_backend_name(\n    backend: ggml_backend_t,\n) -> bytes:\n    return lib.ggml_backend_name(backend)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_type.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_type.restype = ggml_backend_buffer_type_t\n# //\n# // Backend\n# //\n# GGML_API const char * ggml_backend_name(ggml_backend_t backend);\ndef ggml_backend_name(\n    backend: ggml_backend_t,\n) -> bytes:\n    return lib.ggml_backend_name(backend)\nlib.ggml_backend_name.argtypes = [ggml_backend_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_name.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_name.argtypes = [ggml_backend_t]\nlib.ggml_backend_name.restype = ctypes.c_char_p\n# GGML_API void         ggml_backend_free(ggml_backend_t backend);\ndef ggml_backend_free(\n    backend: ggml_backend_t,\n):\n    return lib.ggml_backend_free(backend)\nlib.ggml_backend_free.argtypes = [ggml_backend_t]\nlib.ggml_backend_free.restype = None\n# GGML_API ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_name.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_name.restype = ctypes.c_char_p\n# GGML_API void         ggml_backend_free(ggml_backend_t backend);\ndef ggml_backend_free(\n    backend: ggml_backend_t,\n):\n    return lib.ggml_backend_free(backend)\nlib.ggml_backend_free.argtypes = [ggml_backend_t]\nlib.ggml_backend_free.restype = None\n# GGML_API ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend);\ndef ggml_backend_get_default_buffer_type(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_free.argtypes = [ggml_backend_t]\nlib.ggml_backend_free.restype = None\n# GGML_API ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend);\ndef ggml_backend_get_default_buffer_type(\n    backend: ggml_backend_t,\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_get_default_buffer_type(backend)\nlib.ggml_backend_get_default_buffer_type.argtypes = [ggml_backend_t]\nlib.ggml_backend_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_free.restype = None\n# GGML_API ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend);\ndef ggml_backend_get_default_buffer_type(\n    backend: ggml_backend_t,\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_get_default_buffer_type(backend)\nlib.ggml_backend_get_default_buffer_type.argtypes = [ggml_backend_t]\nlib.ggml_backend_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size);\ndef ggml_backend_alloc_buffer(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_get_default_buffer_type.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_get_default_buffer_type.argtypes = [ggml_backend_t]\nlib.ggml_backend_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size);\ndef ggml_backend_alloc_buffer(\n    backend: ggml_backend_t,\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_alloc_buffer(backend, size)\nlib.ggml_backend_alloc_buffer.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_backend_alloc_buffer.restype = ggml_backend_buffer_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_get_default_buffer_type.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size);\ndef ggml_backend_alloc_buffer(\n    backend: ggml_backend_t,\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_alloc_buffer(backend, size)\nlib.ggml_backend_alloc_buffer.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_backend_alloc_buffer.restype = ggml_backend_buffer_t\n# GGML_API size_t                     ggml_backend_get_alignment(ggml_backend_t backend);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_alloc_buffer.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_alloc_buffer.argtypes = [ggml_backend_t, ctypes.c_size_t]\nlib.ggml_backend_alloc_buffer.restype = ggml_backend_buffer_t\n# GGML_API size_t                     ggml_backend_get_alignment(ggml_backend_t backend);\ndef ggml_backend_get_alignment(\n    backend: ggml_backend_t,\n) -> int:\n    return lib.ggml_backend_get_alignment(backend)\nlib.ggml_backend_get_alignment.argtypes = [ggml_backend_t]\nlib.ggml_backend_get_alignment.restype = ctypes.c_size_t\n# GGML_API void ggml_backend_tensor_set_async(ggml_backend_t backend,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_alloc_buffer.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_alloc_buffer.restype = ggml_backend_buffer_t\n# GGML_API size_t                     ggml_backend_get_alignment(ggml_backend_t backend);\ndef ggml_backend_get_alignment(\n    backend: ggml_backend_t,\n) -> int:\n    return lib.ggml_backend_get_alignment(backend)\nlib.ggml_backend_get_alignment.argtypes = [ggml_backend_t]\nlib.ggml_backend_get_alignment.restype = ctypes.c_size_t\n# GGML_API void ggml_backend_tensor_set_async(ggml_backend_t backend,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_set_async(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_get_alignment.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_get_alignment.argtypes = [ggml_backend_t]\nlib.ggml_backend_get_alignment.restype = ctypes.c_size_t\n# GGML_API void ggml_backend_tensor_set_async(ggml_backend_t backend,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_set_async(\n    backend: ggml_backend_t,\n    tensor: ggml_tensor_p,\n    data: ctypes.c_void_p,\n    offset: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_get_alignment.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_get_alignment.restype = ctypes.c_size_t\n# GGML_API void ggml_backend_tensor_set_async(ggml_backend_t backend,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_set_async(\n    backend: ggml_backend_t,\n    tensor: ggml_tensor_p,\n    data: ctypes.c_void_p,\n    offset: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_backend_tensor_set_async(backend, tensor, data, offset, size)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_set_async.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_set_async.argtypes = [\n    ggml_backend_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_backend_tensor_set_async.restype = None\n# GGML_API void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor * tensor,       void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_get_async(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_set_async.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_set_async.restype = None\n# GGML_API void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor * tensor,       void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_get_async(\n    backend: ggml_backend_t,\n    tensor: ggml_tensor_p,\n    data: ctypes.c_void_p,\n    offset: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_backend_tensor_get_async(backend, tensor, data, offset, size)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_get_async.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_get_async.argtypes = [\n    ggml_backend_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_backend_tensor_get_async.restype = None\n# GGML_API void ggml_backend_tensor_set(      struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_set(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_get_async.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_get_async.restype = None\n# GGML_API void ggml_backend_tensor_set(      struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_set(\n    tensor: ggml_tensor_p,\n    data: ctypes.c_void_p,\n    offset: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_backend_tensor_set(tensor, data, offset, size)\nlib.ggml_backend_tensor_set.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_set.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_set.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_backend_tensor_set.restype = None\n# GGML_API void ggml_backend_tensor_get(const struct ggml_tensor * tensor,       void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_get(\n    tensor: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_set.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_set.restype = None\n# GGML_API void ggml_backend_tensor_get(const struct ggml_tensor * tensor,       void * data, size_t offset, size_t size);\ndef ggml_backend_tensor_get(\n    tensor: ggml_tensor_p,\n    data: ctypes.c_void_p,\n    offset: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n):\n    return lib.ggml_backend_tensor_get(tensor, data, offset, size)\nlib.ggml_backend_tensor_get.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_get.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_get.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n]\nlib.ggml_backend_tensor_get.restype = None\n# GGML_API void ggml_backend_synchronize(ggml_backend_t backend);\ndef ggml_backend_synchronize(\n    backend: ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_get.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_get.restype = None\n# GGML_API void ggml_backend_synchronize(ggml_backend_t backend);\ndef ggml_backend_synchronize(\n    backend: ggml_backend_t,\n):\n    return lib.ggml_backend_synchronize(backend)\nlib.ggml_backend_synchronize.argtypes = [ggml_backend_t]\nlib.ggml_backend_synchronize.restype = None\n# GGML_API ggml_backend_graph_plan_t ggml_backend_graph_plan_create (ggml_backend_t backend, struct ggml_cgraph * cgraph);\ndef ggml_backend_graph_plan_create(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_synchronize.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_synchronize.argtypes = [ggml_backend_t]\nlib.ggml_backend_synchronize.restype = None\n# GGML_API ggml_backend_graph_plan_t ggml_backend_graph_plan_create (ggml_backend_t backend, struct ggml_cgraph * cgraph);\ndef ggml_backend_graph_plan_create(\n    backend: ggml_backend_t,\n    cgraph: ggml_cgraph_p,\n) -> ggml_backend_graph_plan_t:\n    return lib.ggml_backend_graph_plan_create(backend, cgraph)\nlib.ggml_backend_graph_plan_create.argtypes = [\n    ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_synchronize.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_synchronize.restype = None\n# GGML_API ggml_backend_graph_plan_t ggml_backend_graph_plan_create (ggml_backend_t backend, struct ggml_cgraph * cgraph);\ndef ggml_backend_graph_plan_create(\n    backend: ggml_backend_t,\n    cgraph: ggml_cgraph_p,\n) -> ggml_backend_graph_plan_t:\n    return lib.ggml_backend_graph_plan_create(backend, cgraph)\nlib.ggml_backend_graph_plan_create.argtypes = [\n    ggml_backend_t,\n    ctypes.POINTER(ggml_cgraph),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_plan_create.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_plan_create.argtypes = [\n    ggml_backend_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_backend_graph_plan_create.restype = ggml_backend_graph_plan_t\n# GGML_API void ggml_backend_graph_plan_free   (ggml_backend_t backend, ggml_backend_graph_plan_t plan);\ndef ggml_backend_graph_plan_free(\n    backend: ggml_backend_t,\n    plan: ggml_backend_graph_plan_t,\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_plan_create.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_plan_create.restype = ggml_backend_graph_plan_t\n# GGML_API void ggml_backend_graph_plan_free   (ggml_backend_t backend, ggml_backend_graph_plan_t plan);\ndef ggml_backend_graph_plan_free(\n    backend: ggml_backend_t,\n    plan: ggml_backend_graph_plan_t,\n):\n    return lib.ggml_backend_graph_plan_free(backend, plan)\nlib.ggml_backend_graph_plan_free.argtypes = [ggml_backend_t, ggml_backend_graph_plan_t]\nlib.ggml_backend_graph_plan_free.restype = None\n# GGML_API void ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_plan_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_plan_free.argtypes = [ggml_backend_t, ggml_backend_graph_plan_t]\nlib.ggml_backend_graph_plan_free.restype = None\n# GGML_API void ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan);\ndef ggml_backend_graph_plan_compute(\n    backend: ggml_backend_t,\n    plan: ggml_backend_graph_plan_t,\n):\n    return lib.ggml_backend_graph_plan_compute(backend, plan)\nlib.ggml_backend_graph_plan_compute.argtypes = [\n    ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_plan_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_plan_free.restype = None\n# GGML_API void ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan);\ndef ggml_backend_graph_plan_compute(\n    backend: ggml_backend_t,\n    plan: ggml_backend_graph_plan_t,\n):\n    return lib.ggml_backend_graph_plan_compute(backend, plan)\nlib.ggml_backend_graph_plan_compute.argtypes = [\n    ggml_backend_t,\n    ggml_backend_graph_plan_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_plan_compute.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_plan_compute.argtypes = [\n    ggml_backend_t,\n    ggml_backend_graph_plan_t,\n]\nlib.ggml_backend_graph_plan_compute.restype = None\n# GGML_API void ggml_backend_graph_compute     (ggml_backend_t backend, struct ggml_cgraph * cgraph);\ndef ggml_backend_graph_compute(\n    backend: ggml_backend_t,\n    cgraph: ggml_cgraph_p,\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_plan_compute.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_plan_compute.restype = None\n# GGML_API void ggml_backend_graph_compute     (ggml_backend_t backend, struct ggml_cgraph * cgraph);\ndef ggml_backend_graph_compute(\n    backend: ggml_backend_t,\n    cgraph: ggml_cgraph_p,\n):\n    return lib.ggml_backend_graph_compute(backend, cgraph)\nlib.ggml_backend_graph_compute.argtypes = [ggml_backend_t, ctypes.POINTER(ggml_cgraph)]\nlib.ggml_backend_graph_compute.restype = None\n# GGML_API bool ggml_backend_supports_op       (ggml_backend_t backend, const struct ggml_tensor * op);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_compute.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_compute.argtypes = [ggml_backend_t, ctypes.POINTER(ggml_cgraph)]\nlib.ggml_backend_graph_compute.restype = None\n# GGML_API bool ggml_backend_supports_op       (ggml_backend_t backend, const struct ggml_tensor * op);\ndef ggml_backend_supports_op(\n    backend: ggml_backend_t,\n    op: ggml_tensor_p,\n) -> Union[ctypes.c_bool, bool]:\n    return lib.ggml_backend_supports_op(backend, op)\nlib.ggml_backend_supports_op.argtypes = [ggml_backend_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_backend_supports_op.restype = ctypes.c_bool",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_compute.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_compute.restype = None\n# GGML_API bool ggml_backend_supports_op       (ggml_backend_t backend, const struct ggml_tensor * op);\ndef ggml_backend_supports_op(\n    backend: ggml_backend_t,\n    op: ggml_tensor_p,\n) -> Union[ctypes.c_bool, bool]:\n    return lib.ggml_backend_supports_op(backend, op)\nlib.ggml_backend_supports_op.argtypes = [ggml_backend_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_backend_supports_op.restype = ctypes.c_bool\n# // tensor copy between different backends",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_supports_op.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_supports_op.argtypes = [ggml_backend_t, ctypes.POINTER(ggml_tensor)]\nlib.ggml_backend_supports_op.restype = ctypes.c_bool\n# // tensor copy between different backends\n# GGML_API void ggml_backend_tensor_copy(struct ggml_tensor * src, struct ggml_tensor * dst);\ndef ggml_backend_tensor_copy(\n    src: ggml_tensor_p,\n    dst: ggml_tensor_p,\n):\n    return lib.ggml_backend_tensor_copy(src, dst)\nlib.ggml_backend_tensor_copy.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_supports_op.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_supports_op.restype = ctypes.c_bool\n# // tensor copy between different backends\n# GGML_API void ggml_backend_tensor_copy(struct ggml_tensor * src, struct ggml_tensor * dst);\ndef ggml_backend_tensor_copy(\n    src: ggml_tensor_p,\n    dst: ggml_tensor_p,\n):\n    return lib.ggml_backend_tensor_copy(src, dst)\nlib.ggml_backend_tensor_copy.argtypes = [\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_copy.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_copy.argtypes = [\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_tensor_copy.restype = None\n# GGML_API void ggml_backend_tensor_copy_async(ggml_backend_t backend, struct ggml_tensor * src, struct ggml_tensor * dst); // automatic fallback to sync copy\ndef ggml_backend_tensor_copy_async(\n    backend: ggml_backend_t,\n    src: ggml_tensor_p,\n    dst: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_copy.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_copy.restype = None\n# GGML_API void ggml_backend_tensor_copy_async(ggml_backend_t backend, struct ggml_tensor * src, struct ggml_tensor * dst); // automatic fallback to sync copy\ndef ggml_backend_tensor_copy_async(\n    backend: ggml_backend_t,\n    src: ggml_tensor_p,\n    dst: ggml_tensor_p,\n):\n    return lib.ggml_backend_tensor_copy_async(backend, src, dst)\n# lib.ggml_backend_tensor_copy_async.argtypes = [\n#     ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_cpu_init.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_cpu_init.argtypes = []\nlib.ggml_backend_cpu_init.restype = ggml_backend_t\n# GGML_API bool ggml_backend_is_cpu(ggml_backend_t backend);\ndef ggml_backend_is_cpu(\n    backend: ggml_backend_t,\n) -> bool:\n    return lib.ggml_backend_is_cpu(backend)\nlib.ggml_backend_is_cpu.argtypes = [ggml_backend_t]\nlib.ggml_backend_is_cpu.restype = ctypes.c_bool\n# GGML_API void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_cpu_init.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_cpu_init.restype = ggml_backend_t\n# GGML_API bool ggml_backend_is_cpu(ggml_backend_t backend);\ndef ggml_backend_is_cpu(\n    backend: ggml_backend_t,\n) -> bool:\n    return lib.ggml_backend_is_cpu(backend)\nlib.ggml_backend_is_cpu.argtypes = [ggml_backend_t]\nlib.ggml_backend_is_cpu.restype = ctypes.c_bool\n# GGML_API void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads);\ndef ggml_backend_cpu_set_n_threads(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_is_cpu.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_is_cpu.argtypes = [ggml_backend_t]\nlib.ggml_backend_is_cpu.restype = ctypes.c_bool\n# GGML_API void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads);\ndef ggml_backend_cpu_set_n_threads(\n    backend_cpu: ggml_backend_t,\n    n_threads: Union[ctypes.c_int, int],\n):\n    return lib.ggml_backend_cpu_set_n_threads(backend_cpu, n_threads)\nlib.ggml_backend_cpu_set_n_threads.argtypes = [ggml_backend_t, ctypes.c_int]\nlib.ggml_backend_cpu_set_n_threads.restype = None",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_is_cpu.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_is_cpu.restype = ctypes.c_bool\n# GGML_API void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads);\ndef ggml_backend_cpu_set_n_threads(\n    backend_cpu: ggml_backend_t,\n    n_threads: Union[ctypes.c_int, int],\n):\n    return lib.ggml_backend_cpu_set_n_threads(backend_cpu, n_threads)\nlib.ggml_backend_cpu_set_n_threads.argtypes = [ggml_backend_t, ctypes.c_int]\nlib.ggml_backend_cpu_set_n_threads.restype = None\n# // Create a backend buffer from an existing pointer",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_cpu_set_n_threads.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_cpu_set_n_threads.argtypes = [ggml_backend_t, ctypes.c_int]\nlib.ggml_backend_cpu_set_n_threads.restype = None\n# // Create a backend buffer from an existing pointer\n# GGML_API ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void * ptr, size_t size);\ndef ggml_backend_cpu_buffer_from_ptr(\n    ptr: ctypes.c_void_p,\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_cpu_buffer_from_ptr(ptr, size)\nlib.ggml_backend_cpu_buffer_from_ptr.argtypes = [ctypes.c_void_p, ctypes.c_size_t]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_cpu_set_n_threads.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_cpu_set_n_threads.restype = None\n# // Create a backend buffer from an existing pointer\n# GGML_API ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void * ptr, size_t size);\ndef ggml_backend_cpu_buffer_from_ptr(\n    ptr: ctypes.c_void_p,\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_cpu_buffer_from_ptr(ptr, size)\nlib.ggml_backend_cpu_buffer_from_ptr.argtypes = [ctypes.c_void_p, ctypes.c_size_t]\nlib.ggml_backend_cpu_buffer_from_ptr.restype = ggml_backend_buffer_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_cpu_buffer_from_ptr.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_cpu_buffer_from_ptr.argtypes = [ctypes.c_void_p, ctypes.c_size_t]\nlib.ggml_backend_cpu_buffer_from_ptr.restype = ggml_backend_buffer_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type(void);\ndef ggml_backend_cpu_buffer_type() -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_cpu_buffer_type()\nlib.ggml_backend_cpu_buffer_type.argtypes = []\nlib.ggml_backend_cpu_buffer_type.restype = ggml_backend_buffer_type_t\n# //\n# // Backend registry\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_cpu_buffer_from_ptr.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_cpu_buffer_from_ptr.restype = ggml_backend_buffer_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type(void);\ndef ggml_backend_cpu_buffer_type() -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_cpu_buffer_type()\nlib.ggml_backend_cpu_buffer_type.argtypes = []\nlib.ggml_backend_cpu_buffer_type.restype = ggml_backend_buffer_type_t\n# //\n# // Backend registry\n# //\n# // The backend registry is a registry of all the available backends, and allows initializing backends in a generic way",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_cpu_buffer_type.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_cpu_buffer_type.argtypes = []\nlib.ggml_backend_cpu_buffer_type.restype = ggml_backend_buffer_type_t\n# //\n# // Backend registry\n# //\n# // The backend registry is a registry of all the available backends, and allows initializing backends in a generic way\n# GGML_API size_t                     ggml_backend_reg_get_count(void);\ndef ggml_backend_reg_get_count() -> int:\n    return lib.ggml_backend_reg_get_count()\nlib.ggml_backend_reg_get_count.argtypes = []",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_cpu_buffer_type.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_cpu_buffer_type.restype = ggml_backend_buffer_type_t\n# //\n# // Backend registry\n# //\n# // The backend registry is a registry of all the available backends, and allows initializing backends in a generic way\n# GGML_API size_t                     ggml_backend_reg_get_count(void);\ndef ggml_backend_reg_get_count() -> int:\n    return lib.ggml_backend_reg_get_count()\nlib.ggml_backend_reg_get_count.argtypes = []\nlib.ggml_backend_reg_get_count.restype = ctypes.c_size_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_get_count.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_get_count.argtypes = []\nlib.ggml_backend_reg_get_count.restype = ctypes.c_size_t\n# GGML_API size_t                     ggml_backend_reg_find_by_name(const char * name);\ndef ggml_backend_reg_find_by_name(\n    name: bytes,\n) -> int:\n    return lib.ggml_backend_reg_find_by_name(name)\nlib.ggml_backend_reg_find_by_name.argtypes = [ctypes.c_char_p]\nlib.ggml_backend_reg_find_by_name.restype = ctypes.c_size_t\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend_from_str(const char * backend_str); // str is name[:params]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_get_count.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_get_count.restype = ctypes.c_size_t\n# GGML_API size_t                     ggml_backend_reg_find_by_name(const char * name);\ndef ggml_backend_reg_find_by_name(\n    name: bytes,\n) -> int:\n    return lib.ggml_backend_reg_find_by_name(name)\nlib.ggml_backend_reg_find_by_name.argtypes = [ctypes.c_char_p]\nlib.ggml_backend_reg_find_by_name.restype = ctypes.c_size_t\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend_from_str(const char * backend_str); // str is name[:params]\ndef ggml_backend_reg_init_backend_from_str(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_find_by_name.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_find_by_name.argtypes = [ctypes.c_char_p]\nlib.ggml_backend_reg_find_by_name.restype = ctypes.c_size_t\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend_from_str(const char * backend_str); // str is name[:params]\ndef ggml_backend_reg_init_backend_from_str(\n    backend_str: bytes,\n) -> ggml_backend_t:\n    return lib.ggml_backend_reg_init_backend_from_str(backend_str)\nlib.ggml_backend_reg_init_backend_from_str.argtypes = [ctypes.c_char_p]\nlib.ggml_backend_reg_init_backend_from_str.restype = ggml_backend_t\n# GGML_API const char *               ggml_backend_reg_get_name(size_t i);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_find_by_name.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_find_by_name.restype = ctypes.c_size_t\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend_from_str(const char * backend_str); // str is name[:params]\ndef ggml_backend_reg_init_backend_from_str(\n    backend_str: bytes,\n) -> ggml_backend_t:\n    return lib.ggml_backend_reg_init_backend_from_str(backend_str)\nlib.ggml_backend_reg_init_backend_from_str.argtypes = [ctypes.c_char_p]\nlib.ggml_backend_reg_init_backend_from_str.restype = ggml_backend_t\n# GGML_API const char *               ggml_backend_reg_get_name(size_t i);\ndef ggml_backend_reg_get_name(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_init_backend_from_str.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_init_backend_from_str.argtypes = [ctypes.c_char_p]\nlib.ggml_backend_reg_init_backend_from_str.restype = ggml_backend_t\n# GGML_API const char *               ggml_backend_reg_get_name(size_t i);\ndef ggml_backend_reg_get_name(\n    i: Union[ctypes.c_size_t, int],\n) -> bytes:\n    return lib.ggml_backend_reg_get_name(i)\nlib.ggml_backend_reg_get_name.argtypes = [ctypes.c_size_t]\nlib.ggml_backend_reg_get_name.restype = ctypes.c_char_p\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend(size_t i, const char * params); // params is backend-specific",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_init_backend_from_str.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_init_backend_from_str.restype = ggml_backend_t\n# GGML_API const char *               ggml_backend_reg_get_name(size_t i);\ndef ggml_backend_reg_get_name(\n    i: Union[ctypes.c_size_t, int],\n) -> bytes:\n    return lib.ggml_backend_reg_get_name(i)\nlib.ggml_backend_reg_get_name.argtypes = [ctypes.c_size_t]\nlib.ggml_backend_reg_get_name.restype = ctypes.c_char_p\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend(size_t i, const char * params); // params is backend-specific\ndef ggml_backend_reg_init_backend(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_get_name.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_get_name.argtypes = [ctypes.c_size_t]\nlib.ggml_backend_reg_get_name.restype = ctypes.c_char_p\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend(size_t i, const char * params); // params is backend-specific\ndef ggml_backend_reg_init_backend(\n    i: Union[ctypes.c_size_t, int],\n    params: bytes,\n) -> ggml_backend_t:\n    return lib.ggml_backend_reg_init_backend(i, params)\nlib.ggml_backend_reg_init_backend.argtypes = [ctypes.c_size_t, ctypes.c_char_p]\nlib.ggml_backend_reg_init_backend.restype = ggml_backend_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_get_name.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_get_name.restype = ctypes.c_char_p\n# GGML_API ggml_backend_t             ggml_backend_reg_init_backend(size_t i, const char * params); // params is backend-specific\ndef ggml_backend_reg_init_backend(\n    i: Union[ctypes.c_size_t, int],\n    params: bytes,\n) -> ggml_backend_t:\n    return lib.ggml_backend_reg_init_backend(i, params)\nlib.ggml_backend_reg_init_backend.argtypes = [ctypes.c_size_t, ctypes.c_char_p]\nlib.ggml_backend_reg_init_backend.restype = ggml_backend_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_reg_get_default_buffer_type(size_t i);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_init_backend.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_init_backend.argtypes = [ctypes.c_size_t, ctypes.c_char_p]\nlib.ggml_backend_reg_init_backend.restype = ggml_backend_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_reg_get_default_buffer_type(size_t i);\ndef ggml_backend_reg_get_default_buffer_type(\n    i: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_reg_get_default_buffer_type(i)\nlib.ggml_backend_reg_get_default_buffer_type.argtypes = [ctypes.c_size_t]\nlib.ggml_backend_reg_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_reg_alloc_buffer(size_t i, size_t size);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_init_backend.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_init_backend.restype = ggml_backend_t\n# GGML_API ggml_backend_buffer_type_t ggml_backend_reg_get_default_buffer_type(size_t i);\ndef ggml_backend_reg_get_default_buffer_type(\n    i: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_type_t:\n    return lib.ggml_backend_reg_get_default_buffer_type(i)\nlib.ggml_backend_reg_get_default_buffer_type.argtypes = [ctypes.c_size_t]\nlib.ggml_backend_reg_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_reg_alloc_buffer(size_t i, size_t size);\ndef ggml_backend_reg_alloc_buffer(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_get_default_buffer_type.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_get_default_buffer_type.argtypes = [ctypes.c_size_t]\nlib.ggml_backend_reg_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_reg_alloc_buffer(size_t i, size_t size);\ndef ggml_backend_reg_alloc_buffer(\n    i: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_reg_alloc_buffer(i, size)\nlib.ggml_backend_reg_alloc_buffer.argtypes = [ctypes.c_size_t, ctypes.c_size_t]\nlib.ggml_backend_reg_alloc_buffer.restype = ggml_backend_buffer_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_get_default_buffer_type.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_get_default_buffer_type.restype = ggml_backend_buffer_type_t\n# GGML_API ggml_backend_buffer_t      ggml_backend_reg_alloc_buffer(size_t i, size_t size);\ndef ggml_backend_reg_alloc_buffer(\n    i: Union[ctypes.c_size_t, int],\n    size: Union[ctypes.c_size_t, int],\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_reg_alloc_buffer(i, size)\nlib.ggml_backend_reg_alloc_buffer.argtypes = [ctypes.c_size_t, ctypes.c_size_t]\nlib.ggml_backend_reg_alloc_buffer.restype = ggml_backend_buffer_t\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_alloc_buffer.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_alloc_buffer.argtypes = [ctypes.c_size_t, ctypes.c_size_t]\nlib.ggml_backend_reg_alloc_buffer.restype = ggml_backend_buffer_t\n# //\n# // Backend scheduler\n# //\n# // The backend scheduler allows for multiple backends to be used together\n# // Handles compute buffer allocation, assignment of tensors to backends, and copying of tensors between backends\n# // The backends are selected based on:\n# // - the backend that supports the operation\n# // - the location of the pre-allocated tensors (e.g. the weights)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_reg_alloc_buffer.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_reg_alloc_buffer.restype = ggml_backend_buffer_t\n# //\n# // Backend scheduler\n# //\n# // The backend scheduler allows for multiple backends to be used together\n# // Handles compute buffer allocation, assignment of tensors to backends, and copying of tensors between backends\n# // The backends are selected based on:\n# // - the backend that supports the operation\n# // - the location of the pre-allocated tensors (e.g. the weights)\n# /*",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_sched_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_sched_t = ctypes.c_void_p\n# // Initialize a backend scheduler\n# GGML_API ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t * backends, int n_backends);\ndef ggml_backend_sched_new(\n    backends: ggml_backend_t,\n    n_backends: Union[ctypes.c_int, int],\n) -> ggml_backend_sched_t:\n    return lib.ggml_backend_sched_new(backends, n_backends)\nlib.ggml_backend_sched_new.argtypes = [ggml_backend_t, ctypes.c_int]\nlib.ggml_backend_sched_new.restype = ggml_backend_sched_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_new.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_new.argtypes = [ggml_backend_t, ctypes.c_int]\nlib.ggml_backend_sched_new.restype = ggml_backend_sched_t\n# GGML_API void ggml_backend_sched_free(ggml_backend_sched_t sched);\ndef ggml_backend_sched_free(\n    sched: ggml_backend_sched_t,\n):\n    return lib.ggml_backend_sched_free(sched)\nlib.ggml_backend_sched_free.argtypes = [ggml_backend_sched_t]\nlib.ggml_backend_sched_free.restype = None\n# // Initialize backend buffers from a measure graph",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_new.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_new.restype = ggml_backend_sched_t\n# GGML_API void ggml_backend_sched_free(ggml_backend_sched_t sched);\ndef ggml_backend_sched_free(\n    sched: ggml_backend_sched_t,\n):\n    return lib.ggml_backend_sched_free(sched)\nlib.ggml_backend_sched_free.argtypes = [ggml_backend_sched_t]\nlib.ggml_backend_sched_free.restype = None\n# // Initialize backend buffers from a measure graph\n# GGML_API void ggml_backend_sched_init_measure(ggml_backend_sched_t sched, struct ggml_cgraph * measure_graph);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_free.argtypes = [ggml_backend_sched_t]\nlib.ggml_backend_sched_free.restype = None\n# // Initialize backend buffers from a measure graph\n# GGML_API void ggml_backend_sched_init_measure(ggml_backend_sched_t sched, struct ggml_cgraph * measure_graph);\ndef ggml_backend_sched_init_measure(\n    sched: ggml_backend_sched_t,\n    measure_graph: ggml_cgraph_p,\n):\n    return lib.ggml_backend_sched_init_measure(sched, measure_graph)\nlib.ggml_backend_sched_init_measure.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_free.restype = None\n# // Initialize backend buffers from a measure graph\n# GGML_API void ggml_backend_sched_init_measure(ggml_backend_sched_t sched, struct ggml_cgraph * measure_graph);\ndef ggml_backend_sched_init_measure(\n    sched: ggml_backend_sched_t,\n    measure_graph: ggml_cgraph_p,\n):\n    return lib.ggml_backend_sched_init_measure(sched, measure_graph)\nlib.ggml_backend_sched_init_measure.argtypes = [\n    ggml_backend_sched_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_init_measure.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_init_measure.argtypes = [\n    ggml_backend_sched_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_backend_sched_init_measure.restype = None\n# GGML_API ggml_tallocr_t        ggml_backend_sched_get_tallocr(ggml_backend_sched_t sched, ggml_backend_t backend);\ndef ggml_backend_sched_get_tallocr(\n    sched: ggml_backend_sched_t,\n    backend: ggml_backend_t,\n) -> ggml_tallocr_t:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_init_measure.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_init_measure.restype = None\n# GGML_API ggml_tallocr_t        ggml_backend_sched_get_tallocr(ggml_backend_sched_t sched, ggml_backend_t backend);\ndef ggml_backend_sched_get_tallocr(\n    sched: ggml_backend_sched_t,\n    backend: ggml_backend_t,\n) -> ggml_tallocr_t:\n    return lib.ggml_backend_sched_get_tallocr(sched, backend)\nlib.ggml_backend_sched_get_tallocr.argtypes = [ggml_backend_sched_t, ggml_backend_t]\nlib.ggml_backend_sched_get_tallocr.restype = ggml_tallocr_t\n# GGML_API ggml_backend_buffer_t ggml_backend_sched_get_buffer (ggml_backend_sched_t sched, ggml_backend_t backend);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_get_tallocr.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_get_tallocr.argtypes = [ggml_backend_sched_t, ggml_backend_t]\nlib.ggml_backend_sched_get_tallocr.restype = ggml_tallocr_t\n# GGML_API ggml_backend_buffer_t ggml_backend_sched_get_buffer (ggml_backend_sched_t sched, ggml_backend_t backend);\ndef ggml_backend_sched_get_buffer(\n    sched: ggml_backend_sched_t,\n    backend: ggml_backend_t,\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_sched_get_buffer(sched, backend)\nlib.ggml_backend_sched_get_buffer.argtypes = [ggml_backend_sched_t, ggml_backend_t]\nlib.ggml_backend_sched_get_buffer.restype = ggml_backend_buffer_t",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_get_tallocr.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_get_tallocr.restype = ggml_tallocr_t\n# GGML_API ggml_backend_buffer_t ggml_backend_sched_get_buffer (ggml_backend_sched_t sched, ggml_backend_t backend);\ndef ggml_backend_sched_get_buffer(\n    sched: ggml_backend_sched_t,\n    backend: ggml_backend_t,\n) -> ggml_backend_buffer_t:\n    return lib.ggml_backend_sched_get_buffer(sched, backend)\nlib.ggml_backend_sched_get_buffer.argtypes = [ggml_backend_sched_t, ggml_backend_t]\nlib.ggml_backend_sched_get_buffer.restype = ggml_backend_buffer_t\n# GGML_API void ggml_backend_sched_set_node_backend(ggml_backend_sched_t sched, struct ggml_tensor * node, ggml_backend_t backend);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_get_buffer.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_get_buffer.argtypes = [ggml_backend_sched_t, ggml_backend_t]\nlib.ggml_backend_sched_get_buffer.restype = ggml_backend_buffer_t\n# GGML_API void ggml_backend_sched_set_node_backend(ggml_backend_sched_t sched, struct ggml_tensor * node, ggml_backend_t backend);\ndef ggml_backend_sched_set_node_backend(\n    sched: ggml_backend_sched_t,\n    node: ggml_tensor_p,\n    backend: ggml_backend_t,\n):\n    return lib.ggml_backend_sched_set_node_backend(sched, node, backend)\nlib.ggml_backend_sched_set_node_backend.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_get_buffer.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_get_buffer.restype = ggml_backend_buffer_t\n# GGML_API void ggml_backend_sched_set_node_backend(ggml_backend_sched_t sched, struct ggml_tensor * node, ggml_backend_t backend);\ndef ggml_backend_sched_set_node_backend(\n    sched: ggml_backend_sched_t,\n    node: ggml_tensor_p,\n    backend: ggml_backend_t,\n):\n    return lib.ggml_backend_sched_set_node_backend(sched, node, backend)\nlib.ggml_backend_sched_set_node_backend.argtypes = [\n    ggml_backend_sched_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_set_node_backend.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_set_node_backend.argtypes = [\n    ggml_backend_sched_t,\n    ctypes.POINTER(ggml_tensor),\n    ggml_backend_t,\n]\nlib.ggml_backend_sched_set_node_backend.restype = None\n# // Allocate a graph on the backend scheduler\n# GGML_API void ggml_backend_sched_graph_compute(\n#         ggml_backend_sched_t sched,\n#         struct ggml_cgraph * graph);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_set_node_backend.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_set_node_backend.restype = None\n# // Allocate a graph on the backend scheduler\n# GGML_API void ggml_backend_sched_graph_compute(\n#         ggml_backend_sched_t sched,\n#         struct ggml_cgraph * graph);\ndef ggml_backend_sched_graph_compute(\n    sched: ggml_backend_sched_t,\n    graph: ggml_cgraph_p,\n):\n    return lib.ggml_backend_sched_graph_compute(sched, graph)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_graph_compute.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_graph_compute.argtypes = [\n    ggml_backend_sched_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_backend_sched_graph_compute.restype = None\n# //\n# // Utils\n# //\n# struct ggml_backend_graph_copy {\n#     ggml_backend_buffer_t buffer;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_sched_graph_compute.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_sched_graph_compute.restype = None\n# //\n# // Utils\n# //\n# struct ggml_backend_graph_copy {\n#     ggml_backend_buffer_t buffer;\n#     struct ggml_context * ctx_allocated;\n#     struct ggml_context * ctx_unallocated;\n#     struct ggml_cgraph * graph;\n# };",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_graph_copy_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_graph_copy_t = ggml_backend_graph_copy\n# // Copy a graph to a different backend\n# GGML_API struct ggml_backend_graph_copy ggml_backend_graph_copy(ggml_backend_t backend, struct ggml_cgraph * graph);\ndef ggml_backend_graph_copy(\n    backend: ggml_backend_t,\n    graph: ggml_cgraph_p,\n) -> ggml_backend_graph_copy_t:\n    return lib.ggml_backend_graph_copy(backend, graph)\nlib.ggml_backend_graph_copy.argtypes = [\n    ggml_backend_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_copy.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_copy.argtypes = [\n    ggml_backend_t,\n    ctypes.POINTER(ggml_cgraph),\n]\nlib.ggml_backend_graph_copy.restype = ggml_backend_graph_copy_t\n# GGML_API void                           ggml_backend_graph_copy_free(struct ggml_backend_graph_copy copy);\ndef ggml_backend_graph_copy_free(\n    copy: ggml_backend_graph_copy_t,\n):\n    return lib.ggml_backend_graph_copy_free(copy)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_copy.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_copy.restype = ggml_backend_graph_copy_t\n# GGML_API void                           ggml_backend_graph_copy_free(struct ggml_backend_graph_copy copy);\ndef ggml_backend_graph_copy_free(\n    copy: ggml_backend_graph_copy_t,\n):\n    return lib.ggml_backend_graph_copy_free(copy)\nlib.ggml_backend_graph_copy_free.argtypes = [ggml_backend_graph_copy_t]\nlib.ggml_backend_graph_copy_free.restype = None\n# typedef bool (*ggml_backend_eval_callback)(int node_index, struct ggml_tensor * t1, struct ggml_tensor * t2, void * user_data);\nggml_backend_eval_callback = ctypes.CFUNCTYPE(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_copy_free.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_copy_free.argtypes = [ggml_backend_graph_copy_t]\nlib.ggml_backend_graph_copy_free.restype = None\n# typedef bool (*ggml_backend_eval_callback)(int node_index, struct ggml_tensor * t1, struct ggml_tensor * t2, void * user_data);\nggml_backend_eval_callback = ctypes.CFUNCTYPE(\n    ctypes.c_bool,\n    ctypes.c_int,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_graph_copy_free.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_graph_copy_free.restype = None\n# typedef bool (*ggml_backend_eval_callback)(int node_index, struct ggml_tensor * t1, struct ggml_tensor * t2, void * user_data);\nggml_backend_eval_callback = ctypes.CFUNCTYPE(\n    ctypes.c_bool,\n    ctypes.c_int,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n)\n# // Compare the output of two backends",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_eval_callback",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_eval_callback = ctypes.CFUNCTYPE(\n    ctypes.c_bool,\n    ctypes.c_int,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n)\n# // Compare the output of two backends\n# GGML_API void ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph * graph, ggml_backend_eval_callback callback, void * user_data);\ndef ggml_backend_compare_graph_backend(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_compare_graph_backend.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_compare_graph_backend.argtypes = [\n    ggml_backend_t,\n    ggml_backend_t,\n    ctypes.POINTER(ggml_cgraph),\n    ggml_backend_eval_callback,\n    ctypes.c_void_p,\n]\nlib.ggml_backend_compare_graph_backend.restype = None\n# // Tensor initialization\n# GGML_API void ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor * tensor, void * addr);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_compare_graph_backend.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_compare_graph_backend.restype = None\n# // Tensor initialization\n# GGML_API void ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor * tensor, void * addr);\ndef ggml_backend_tensor_alloc(\n    buffer: ggml_backend_buffer_t,\n    tensor: ggml_tensor_p,\n    addr: ctypes.c_void_p,\n):\n    return lib.ggml_backend_tensor_alloc(buffer, tensor, addr)\nlib.ggml_backend_tensor_alloc.argtypes = [",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_alloc.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_alloc.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n]\nlib.ggml_backend_tensor_alloc.restype = None\n# GGML_API void ggml_backend_view_init(ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_view_init(\n    buffer: ggml_backend_buffer_t,\n    tensor: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_tensor_alloc.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_tensor_alloc.restype = None\n# GGML_API void ggml_backend_view_init(ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\ndef ggml_backend_view_init(\n    buffer: ggml_backend_buffer_t,\n    tensor: ggml_tensor_p,\n):\n    return lib.ggml_backend_view_init(buffer, tensor)\nlib.ggml_backend_view_init.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_view_init.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_view_init.argtypes = [\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n]\nlib.ggml_backend_view_init.restype = None\n#####################################################\n# GGML Backend Implementation API\n# source: ggml-backend-impl.h\n#####################################################\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_view_init.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_view_init.restype = None\n#####################################################\n# GGML Backend Implementation API\n# source: ggml-backend-impl.h\n#####################################################\n# //\n# // Backend buffer\n# //\n# // buffer type\n# typedef void * ggml_backend_buffer_type_context_t;",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_type_context_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_type_context_t = ctypes.c_void_p\n# struct ggml_backend_buffer_type_i {\n#     ggml_backend_buffer_t (*alloc_buffer)    (ggml_backend_buffer_type_t buft, size_t size);\n#     size_t                (*get_alignment)   (ggml_backend_buffer_type_t buft); // tensor alignment\n#     size_t                (*get_alloc_size)  (ggml_backend_buffer_type_t buft, struct ggml_tensor * tensor); // data size needed to allocate the tensor, including padding\n#     bool                  (*supports_backend)(ggml_backend_buffer_type_t buft, ggml_backend_t backend); // check if the buffer type is usable by the backend\n# };\nggml_backend_buffer_i_alloc_buffer = ctypes.CFUNCTYPE(\n    ggml_backend_buffer_t, ggml_backend_buffer_type_t, ctypes.c_size_t\n)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_alloc_buffer",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_alloc_buffer = ctypes.CFUNCTYPE(\n    ggml_backend_buffer_t, ggml_backend_buffer_type_t, ctypes.c_size_t\n)\nggml_backend_buffer_i_get_alignment = ctypes.CFUNCTYPE(\n    ctypes.c_size_t, ggml_backend_buffer_type_t\n)\nggml_backend_buffer_i_get_alloc_size = ctypes.CFUNCTYPE(\n    ctypes.c_size_t, ggml_backend_buffer_type_t, ctypes.POINTER(ggml_tensor)\n)\nggml_backend_buffer_i_supports_backend = ctypes.CFUNCTYPE(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_get_alignment",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_get_alignment = ctypes.CFUNCTYPE(\n    ctypes.c_size_t, ggml_backend_buffer_type_t\n)\nggml_backend_buffer_i_get_alloc_size = ctypes.CFUNCTYPE(\n    ctypes.c_size_t, ggml_backend_buffer_type_t, ctypes.POINTER(ggml_tensor)\n)\nggml_backend_buffer_i_supports_backend = ctypes.CFUNCTYPE(\n    ctypes.c_bool, ggml_backend_buffer_type_t, ggml_backend_t\n)\nclass ggml_backend_buffer_type_i(ctypes.Structure):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_get_alloc_size",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_get_alloc_size = ctypes.CFUNCTYPE(\n    ctypes.c_size_t, ggml_backend_buffer_type_t, ctypes.POINTER(ggml_tensor)\n)\nggml_backend_buffer_i_supports_backend = ctypes.CFUNCTYPE(\n    ctypes.c_bool, ggml_backend_buffer_type_t, ggml_backend_t\n)\nclass ggml_backend_buffer_type_i(ctypes.Structure):\n    _fields_ = [\n        (\"alloc_buffer\", ggml_backend_buffer_i_alloc_buffer),\n        (\"get_alignment\", ggml_backend_buffer_i_get_alignment),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_supports_backend",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_supports_backend = ctypes.CFUNCTYPE(\n    ctypes.c_bool, ggml_backend_buffer_type_t, ggml_backend_t\n)\nclass ggml_backend_buffer_type_i(ctypes.Structure):\n    _fields_ = [\n        (\"alloc_buffer\", ggml_backend_buffer_i_alloc_buffer),\n        (\"get_alignment\", ggml_backend_buffer_i_get_alignment),\n        (\"get_alloc_size\", ggml_backend_buffer_i_get_alloc_size),\n        (\"supports_backend\", ggml_backend_buffer_i_supports_backend),\n    ]",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_context_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_context_t = ctypes.c_void_p\n# struct ggml_backend_buffer_i {\n#     void     (*free_buffer)(ggml_backend_buffer_t buffer);\n#     //void     (*reset)      (ggml_backend_buffer_t buffer); // reset any internal state due to tensor initialization, such as tensor extras\n#     void *   (*get_base)   (ggml_backend_buffer_t buffer);\n#     void     (*init_tensor)(ggml_backend_buffer_t buffer, struct ggml_tensor * tensor);\n#     void     (*set_tensor) (ggml_backend_buffer_t buffer,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);\n#     void     (*get_tensor) (ggml_backend_buffer_t buffer, const struct ggml_tensor * tensor,       void * data, size_t offset, size_t size);\n#     // (optional) copy tensor between different buffer-type, allow for single-copy tranfers\n#     void (*cpy_tensor_from)(ggml_backend_buffer_t buffer, struct ggml_tensor * src, struct ggml_tensor * dst);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_free_buffer",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_free_buffer = ctypes.CFUNCTYPE(None, ggml_backend_buffer_t)\nggml_backend_buffer_i_get_base = ctypes.CFUNCTYPE(\n    ctypes.c_void_p, ggml_backend_buffer_t\n)\nggml_backend_buffer_i_init_tensor = ctypes.CFUNCTYPE(\n    None, ggml_backend_buffer_t, ctypes.POINTER(ggml_tensor)\n)\nggml_backend_buffer_i_set_tensor = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_buffer_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_get_base",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_get_base = ctypes.CFUNCTYPE(\n    ctypes.c_void_p, ggml_backend_buffer_t\n)\nggml_backend_buffer_i_init_tensor = ctypes.CFUNCTYPE(\n    None, ggml_backend_buffer_t, ctypes.POINTER(ggml_tensor)\n)\nggml_backend_buffer_i_set_tensor = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_init_tensor",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_init_tensor = ctypes.CFUNCTYPE(\n    None, ggml_backend_buffer_t, ctypes.POINTER(ggml_tensor)\n)\nggml_backend_buffer_i_set_tensor = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_set_tensor",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_set_tensor = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n)\nggml_backend_buffer_i_get_tensor = ctypes.CFUNCTYPE(\n    None,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_get_tensor",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_get_tensor = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n)\nggml_backend_buffer_i_cpy_tensor_from = ctypes.CFUNCTYPE(\n    None,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_cpy_tensor_from",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_cpy_tensor_from = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n)\nggml_backend_buffer_i_cpy_tensor_to = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_buffer_i_cpy_tensor_to",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_buffer_i_cpy_tensor_to = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_buffer_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.POINTER(ggml_tensor),\n)\nclass ggml_backend_buffer_i(ctypes.Structure):\n    _fields_ = [\n        (\"free_buffer\", ggml_backend_buffer_i_free_buffer),\n        (\"get_base\", ggml_backend_buffer_i_get_base),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_init.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_init.argtypes = [\n    ggml_backend_buffer_type_t,\n    ggml_backend_buffer_i,\n    ggml_backend_buffer_context_t,\n    ctypes.c_size_t,\n]\nlib.ggml_backend_buffer_init.restype = ggml_backend_buffer_t\n# //\n# // Backend\n# //",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_buffer_init.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_buffer_init.restype = ggml_backend_buffer_t\n# //\n# // Backend\n# //\n# typedef void * ggml_backend_context_t;\nggml_backend_context_t = ctypes.c_void_p\n# struct ggml_backend_i {\n#     const char * (*get_name)(ggml_backend_t backend);\n#     void (*free)(ggml_backend_t backend);\n#     // buffer allocation",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_context_t",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_context_t = ctypes.c_void_p\n# struct ggml_backend_i {\n#     const char * (*get_name)(ggml_backend_t backend);\n#     void (*free)(ggml_backend_t backend);\n#     // buffer allocation\n#     ggml_backend_buffer_type_t (*get_default_buffer_type)(ggml_backend_t backend);\n#     // (optional) asynchroneous tensor data access\n#     void (*set_tensor_async)(ggml_backend_t backend,       struct ggml_tensor * tensor, const void * data, size_t offset, size_t size);\n#     void (*get_tensor_async)(ggml_backend_t backend, const struct ggml_tensor * tensor,       void * data, size_t offset, size_t size);\n#     // (optional) asynchroneous tensor copy",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_get_name",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_get_name = ctypes.CFUNCTYPE(ctypes.c_char_p, ggml_backend_t)\nggml_backend_i_free = ctypes.CFUNCTYPE(None, ggml_backend_t)\nggml_backend_i_get_default_buffer_type = ctypes.CFUNCTYPE(\n    ggml_backend_buffer_type_t, ggml_backend_t\n)\nggml_backend_i_set_tensor_async = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_free",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_free = ctypes.CFUNCTYPE(None, ggml_backend_t)\nggml_backend_i_get_default_buffer_type = ctypes.CFUNCTYPE(\n    ggml_backend_buffer_type_t, ggml_backend_t\n)\nggml_backend_i_set_tensor_async = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_get_default_buffer_type",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_get_default_buffer_type = ctypes.CFUNCTYPE(\n    ggml_backend_buffer_type_t, ggml_backend_t\n)\nggml_backend_i_set_tensor_async = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_set_tensor_async",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_set_tensor_async = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n)\nggml_backend_i_get_tensor_async = ctypes.CFUNCTYPE(\n    None,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_get_tensor_async",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_get_tensor_async = ctypes.CFUNCTYPE(\n    None,\n    ggml_backend_t,\n    ctypes.POINTER(ggml_tensor),\n    ctypes.c_void_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n)\nggml_backend_i_cpy_tensor_from_async = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ctypes.POINTER(ggml_tensor), ctypes.POINTER(ggml_tensor)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_cpy_tensor_from_async",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_cpy_tensor_from_async = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ctypes.POINTER(ggml_tensor), ctypes.POINTER(ggml_tensor)\n)\nggml_backend_i_cpy_tensor_to_async = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ctypes.POINTER(ggml_tensor), ctypes.POINTER(ggml_tensor)\n)\nggml_backend_i_synchronize = ctypes.CFUNCTYPE(None, ggml_backend_t)\nggml_backend_i_graph_plan_create = ctypes.CFUNCTYPE(\n    ggml_backend_graph_plan_t, ggml_backend_t, ctypes.POINTER(ggml_cgraph)\n)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_cpy_tensor_to_async",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_cpy_tensor_to_async = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ctypes.POINTER(ggml_tensor), ctypes.POINTER(ggml_tensor)\n)\nggml_backend_i_synchronize = ctypes.CFUNCTYPE(None, ggml_backend_t)\nggml_backend_i_graph_plan_create = ctypes.CFUNCTYPE(\n    ggml_backend_graph_plan_t, ggml_backend_t, ctypes.POINTER(ggml_cgraph)\n)\nggml_backend_i_graph_plan_free = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ggml_backend_graph_plan_t\n)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_synchronize",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_synchronize = ctypes.CFUNCTYPE(None, ggml_backend_t)\nggml_backend_i_graph_plan_create = ctypes.CFUNCTYPE(\n    ggml_backend_graph_plan_t, ggml_backend_t, ctypes.POINTER(ggml_cgraph)\n)\nggml_backend_i_graph_plan_free = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ggml_backend_graph_plan_t\n)\nggml_backend_i_graph_plan_compute = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ggml_backend_graph_plan_t\n)",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_graph_plan_create",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_graph_plan_create = ctypes.CFUNCTYPE(\n    ggml_backend_graph_plan_t, ggml_backend_t, ctypes.POINTER(ggml_cgraph)\n)\nggml_backend_i_graph_plan_free = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ggml_backend_graph_plan_t\n)\nggml_backend_i_graph_plan_compute = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ggml_backend_graph_plan_t\n)\nggml_backend_i_graph_compute = ctypes.CFUNCTYPE(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_graph_plan_free",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_graph_plan_free = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ggml_backend_graph_plan_t\n)\nggml_backend_i_graph_plan_compute = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ggml_backend_graph_plan_t\n)\nggml_backend_i_graph_compute = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ctypes.POINTER(ggml_cgraph)\n)\nggml_backend_i_supports_op = ctypes.CFUNCTYPE(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_graph_plan_compute",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_graph_plan_compute = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ggml_backend_graph_plan_t\n)\nggml_backend_i_graph_compute = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ctypes.POINTER(ggml_cgraph)\n)\nggml_backend_i_supports_op = ctypes.CFUNCTYPE(\n    ctypes.c_bool, ggml_backend_t, ctypes.POINTER(ggml_tensor)\n)\nclass ggml_backend_i(ctypes.Structure):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_graph_compute",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_graph_compute = ctypes.CFUNCTYPE(\n    None, ggml_backend_t, ctypes.POINTER(ggml_cgraph)\n)\nggml_backend_i_supports_op = ctypes.CFUNCTYPE(\n    ctypes.c_bool, ggml_backend_t, ctypes.POINTER(ggml_tensor)\n)\nclass ggml_backend_i(ctypes.Structure):\n    _fields_ = [\n        (\"get_name\", ggml_backend_i_get_name),\n        (\"free\", ggml_backend_i_free),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_i_supports_op",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_i_supports_op = ctypes.CFUNCTYPE(\n    ctypes.c_bool, ggml_backend_t, ctypes.POINTER(ggml_tensor)\n)\nclass ggml_backend_i(ctypes.Structure):\n    _fields_ = [\n        (\"get_name\", ggml_backend_i_get_name),\n        (\"free\", ggml_backend_i_free),\n        (\"get_default_buffer_type\", ggml_backend_i_get_default_buffer_type),\n        (\"set_tensor_async\", ggml_backend_i_set_tensor_async),\n        (\"get_tensor_async\", ggml_backend_i_get_tensor_async),",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_backend_init_fn",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_backend_init_fn = ctypes.CFUNCTYPE(\n    ggml_backend_t, ctypes.c_char_p, ctypes.c_void_p\n)\n# void ggml_backend_register(const char * name, ggml_backend_init_fn init_fn, ggml_backend_buffer_type_t default_buffer_type, void * user_data);\ndef ggml_backend_register(\n    name: bytes,\n    init_fn,\n    default_buffer_type: ggml_backend_buffer_type_t,\n    user_data: ctypes.c_void_p,\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_register.argtypes",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_register.argtypes = [\n    ctypes.c_char_p,\n    ggml_backend_init_fn,\n    ggml_backend_buffer_type_t,\n    ctypes.c_void_p,\n]\nlib.ggml_backend_register.restype = None\n#####################################################\n# GGML CUDA API\n# source: ggml-cuda.h",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "lib.ggml_backend_register.restype",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "lib.ggml_backend_register.restype = None\n#####################################################\n# GGML CUDA API\n# source: ggml-cuda.h\n#####################################################\nGGML_USE_CUBLAS = hasattr(lib, \"ggml_init_cublas\")\nGGML_CUDA_MAX_DEVICES = 16\n# // Always success. To check if CUDA is actually loaded, use `ggml_cublas_loaded`.\n# GGML_API void   ggml_init_cublas(void);\ndef ggml_init_cublas():",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_USE_CUBLAS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_USE_CUBLAS = hasattr(lib, \"ggml_init_cublas\")\nGGML_CUDA_MAX_DEVICES = 16\n# // Always success. To check if CUDA is actually loaded, use `ggml_cublas_loaded`.\n# GGML_API void   ggml_init_cublas(void);\ndef ggml_init_cublas():\n    return lib.ggml_init_cublas()\nif GGML_USE_CUBLAS:\n    lib.ggml_init_cublas.argtypes = []\n    lib.ggml_init_cublas.restype = None\n# // Returns `true` if there are available CUDA devices and cublas loads successfully; otherwise, it returns `false`.",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_CUDA_MAX_DEVICES",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_CUDA_MAX_DEVICES = 16\n# // Always success. To check if CUDA is actually loaded, use `ggml_cublas_loaded`.\n# GGML_API void   ggml_init_cublas(void);\ndef ggml_init_cublas():\n    return lib.ggml_init_cublas()\nif GGML_USE_CUBLAS:\n    lib.ggml_init_cublas.argtypes = []\n    lib.ggml_init_cublas.restype = None\n# // Returns `true` if there are available CUDA devices and cublas loads successfully; otherwise, it returns `false`.\n# GGML_API bool   ggml_cublas_loaded(void);",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_USE_METAL",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_USE_METAL = hasattr(lib, \"ggml_metal_init\")\n# // max memory buffers that can be mapped to the device\n# #define GGML_METAL_MAX_BUFFERS 64\nGGML_METAL_MAX_BUFFERS = 64\n# #define GGML_METAL_MAX_COMMAND_BUFFERS 32\nGGML_METAL_MAX_COMMAND_BUFFERS = 32\n# struct ggml_metal_context;\nggml_metal_context_p = ctypes.c_void_p\n# void ggml_metal_log_set_callback(ggml_log_callback log_callback, void * user_data);\ndef ggml_metal_log_set_callback(",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_METAL_MAX_BUFFERS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_METAL_MAX_BUFFERS = 64\n# #define GGML_METAL_MAX_COMMAND_BUFFERS 32\nGGML_METAL_MAX_COMMAND_BUFFERS = 32\n# struct ggml_metal_context;\nggml_metal_context_p = ctypes.c_void_p\n# void ggml_metal_log_set_callback(ggml_log_callback log_callback, void * user_data);\ndef ggml_metal_log_set_callback(\n    log_callback,  # type: \"ctypes._CFuncPtr\" # type: ignore\n    user_data: ctypes.c_void_p,\n):",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_METAL_MAX_COMMAND_BUFFERS",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_METAL_MAX_COMMAND_BUFFERS = 32\n# struct ggml_metal_context;\nggml_metal_context_p = ctypes.c_void_p\n# void ggml_metal_log_set_callback(ggml_log_callback log_callback, void * user_data);\ndef ggml_metal_log_set_callback(\n    log_callback,  # type: \"ctypes._CFuncPtr\" # type: ignore\n    user_data: ctypes.c_void_p,\n):\n    return lib.ggml_metal_log_set_callback(log_callback, user_data)\nif GGML_USE_METAL:",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "ggml_metal_context_p",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "ggml_metal_context_p = ctypes.c_void_p\n# void ggml_metal_log_set_callback(ggml_log_callback log_callback, void * user_data);\ndef ggml_metal_log_set_callback(\n    log_callback,  # type: \"ctypes._CFuncPtr\" # type: ignore\n    user_data: ctypes.c_void_p,\n):\n    return lib.ggml_metal_log_set_callback(log_callback, user_data)\nif GGML_USE_METAL:\n    lib.ggml_metal_log_set_callback.argtypes = [\n        ggml_log_callback,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "GGML_USE_CLBLAST",
        "kind": 5,
        "importPath": "lib.seamless_communication.ggml.third_party_ggml",
        "description": "lib.seamless_communication.ggml.third_party_ggml",
        "peekOfCode": "GGML_USE_CLBLAST = hasattr(lib, \"ggml_cl_init\")\n# void ggml_cl_init(void);\ndef ggml_cl_init():\n    return lib.ggml_cl_init()\nif GGML_USE_CLBLAST:\n    lib.ggml_cl_init.argtypes = []\n    lib.ggml_cl_init.restype = None\n# void   ggml_cl_mul(const struct ggml_tensor * src0, const struct ggml_tensor * src1, struct ggml_tensor * dst);\ndef ggml_cl_mul(\n    src0: ggml_tensor_p,",
        "detail": "lib.seamless_communication.ggml.third_party_ggml",
        "documentation": {}
    },
    {
        "label": "init_whisper_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "peekOfCode": "def init_whisper_model(\n    device: Device,\n    whisper_model_name: str = \"large\",\n) -> Whisper:\n    return whisper.load_model(name=whisper_model_name, device=device)\ndef transcribe_series(\n    audio_paths_series: pd.Series,\n    asr_model: Whisper,\n    audio_lang: str,\n    beam_size: int = 1,",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "transcribe_series",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "peekOfCode": "def transcribe_series(\n    audio_paths_series: pd.Series,\n    asr_model: Whisper,\n    audio_lang: str,\n    beam_size: int = 1,\n    temperature: float = 0.0,\n) -> pd.Series:\n    \"\"\"Transcribes each audio filepath from series and returns series of transcriptions\n    Args:\n        audio_paths_series (pd.Series): each line contains path to audio file.",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "whisper_normalize_series",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "peekOfCode": "def whisper_normalize_series(\n    transcription_series: pd.Series, text_lang: str\n) -> pd.Series:\n    \"\"\"Normalizes the text series using whisper noramlizer. English has a specific one in whisper package.\n    Args:\n        transcription_series (pd.Series): Each line contains arbitrary text written in text_lang\n        text_lang (str): Language of the text in series\n    Returns:\n        pd.Series: Series with normalized text\n    \"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "compute_asr_bleu",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "peekOfCode": "def compute_asr_bleu(\n    audio_paths_series: pd.Series,\n    ref_text_series: pd.Series,\n    lang: str,\n    asr_model: Whisper,\n    whisper_normalize_text: bool = True,\n    beam_size: int = 1,\n    temperature: float = 0.0,\n    return_transcriptions: bool = True,\n) -> Tuple[Score, Signature, pd.DataFrame]:",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "get_tokenizer",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "peekOfCode": "def get_tokenizer(lang: str, metric: str = \"bleu\") -> str:\n    \"\"\"Get tokenizer for language\n    Args:\n        lang (str): Three letter code of the language\n        metric (str): Metric being computed. Valid values are \"bleu\" and \"asr\"\n    \"\"\"\n    lang_tok_map = {\n        \"cmn\": \"char\",\n        \"jpn\": \"char\",\n        \"tha\": \"char\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "compute_asr_error_rate",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "peekOfCode": "def compute_asr_error_rate(\n    hyp_text_series: pd.Series,\n    ref_text_series: pd.Series,\n    lang: str,\n    whisper_normalize_text: bool = True,\n) -> Tuple[float, str]:\n    \"\"\"Wraps normalization functions and computes ASR WER/CER score\n    Args:\n        hyp_text_series (pd.Series): each line contains s2t model prediction or first pass prediction\n        ref_text_series (pd.Series): _description_",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "compute_corpus_metric_score",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "peekOfCode": "def compute_corpus_metric_score(\n    hyp_text_series: pd.Series,\n    ref_text_series: pd.Series,\n    lang: str,\n    whisper_normalize_text: bool = True,\n    metric: str = \"bleu\",\n) -> Tuple[Score, Signature]:\n    \"\"\"Wraps normalization functions and compute corpus-level BLEU/chrF++ score\n    Args:\n        hyp_text_series (pd.Series): each line contains s2t model prediction or first pass prediction",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "compute_quality_metrics",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "peekOfCode": "def compute_quality_metrics(\n    output_manifest_tsv_path: Path,\n    output_path: Path,\n    tgt_lang: str,\n    task: str,\n    device: Device,\n    whisper_model_name: str = \"large\",\n    whisper_normalize_text_output: bool = False,\n    ref_text_col_name: str = \"ref_tgt_text\",\n    pred_text_col_name: Optional[str] = \"pred_tgt_text\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef init_whisper_model(\n    device: Device,\n    whisper_model_name: str = \"large\",\n) -> Whisper:\n    return whisper.load_model(name=whisper_model_name, device=device)\ndef transcribe_series(\n    audio_paths_series: pd.Series,\n    asr_model: Whisper,\n    audio_lang: str,",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.compute_metrics",
        "documentation": {}
    },
    {
        "label": "LANG2_LANG3",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.lang_mapping",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.lang_mapping",
        "peekOfCode": "LANG2_LANG3 = {\n    \"en\": \"eng\",\n    \"ar\": \"arb\",\n    \"as\": \"asm\",\n    \"be\": \"bel\",\n    \"bg\": \"bul\",\n    \"bn\": \"ben\",\n    \"ca\": \"cat\",\n    \"ckb\": \"ckb\",\n    \"cs\": \"ces\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.lang_mapping",
        "documentation": {}
    },
    {
        "label": "LANG3_LANG2",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.lang_mapping",
        "description": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.lang_mapping",
        "peekOfCode": "LANG3_LANG2 = {v: k for k, v in LANG2_LANG3.items()}",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.eval_utils.lang_mapping",
        "documentation": {}
    },
    {
        "label": "multiprocess_map",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "peekOfCode": "def multiprocess_map(\n    a_list: list,\n    func: callable,\n    n_workers: Optional[int] = None,\n    chunksize: int = 1,\n    desc=None,\n):\n    if n_workers is None:\n        n_workers = mp.cpu_count()\n    n_workers = min(n_workers, mp.cpu_count())",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "documentation": {}
    },
    {
        "label": "convert_to_16khz_wav",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "peekOfCode": "def convert_to_16khz_wav(config: Tuple[str, str]) -> str:\n    input_audio, output_audio = config\n    input_wav, input_sr = torchaudio.load(input_audio)\n    effects = [\n        [\"rate\", \"16000\"],\n        [\"channels\", \"1\"],\n    ]\n    wav, _ = torchaudio.sox_effects.apply_effects_tensor(\n        input_wav, input_sr, effects=effects\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "documentation": {}
    },
    {
        "label": "build_en_manifest_from_oss",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "peekOfCode": "def build_en_manifest_from_oss(oss_root: Path, output_folder: Path) -> pd.DataFrame:\n    # We only open source the following styles\n    WHITELIST_STYLE = [\n        \"default\",\n        \"default_emphasis\",\n        \"default_essentials\",\n        \"confused\",\n        \"happy\",\n        \"sad\",\n        \"enunciated\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Prepare mExpresso Eng-XXX S2T manifest\"\n    )\n    parser.add_argument(\n        \"output_folder\",\n        type=lambda p: pathlib.Path(p).resolve(),  # always convert to absolute path\n        help=\"Output folder for the downsampled Expresso En audios and combined manifest. \"\n        \"The output folder path will be expanded to absolute path.\",\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef multiprocess_map(\n    a_list: list,\n    func: callable,\n    n_workers: Optional[int] = None,\n    chunksize: int = 1,\n    desc=None,\n):\n    if n_workers is None:\n        n_workers = mp.cpu_count()",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.data.prepare_mexpresso",
        "documentation": {}
    },
    {
        "label": "build_data_pipeline",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.evaluate",
        "peekOfCode": "def build_data_pipeline(\n    args: Namespace,\n    device: Device,\n    dtype: DataType,\n    gcmvn_mean: Tensor,\n    gcmvn_std: Tensor,\n) -> DataPipeline:\n    with open(args.data_file, \"r\") as f:\n        header = f.readline().strip(\"\\n\").split(\"\\t\")\n        assert (",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.evaluate",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(description=\"Running SeamlessExpressive inference\")\n    parser.add_argument(\n        \"data_file\", type=Path, help=\"Data file (.tsv) to be evaluated.\"\n    )\n    parser = add_inference_arguments(parser)\n    parser.add_argument(\n        \"--gated-model-dir\",\n        type=Path,\n        required=False,",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.evaluate",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef build_data_pipeline(\n    args: Namespace,\n    device: Device,\n    dtype: DataType,\n    gcmvn_mean: Tensor,\n    gcmvn_std: Tensor,\n) -> DataPipeline:\n    with open(args.data_file, \"r\") as f:\n        header = f.readline().strip(\"\\n\").split(\"\\t\")",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "get_pause",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.post_process_pauserate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.post_process_pauserate",
        "peekOfCode": "def get_pause(pause_data_tsv: str) -> Dict[str, float]:\n    utt_pause_align_data = pd.read_csv(\n        pause_data_tsv,\n        sep=\"\\t\",\n        quoting=csv.QUOTE_MINIMAL,\n    )\n    metrics = {}\n    pause_duration_weight = (\n        utt_pause_align_data.total_weight / utt_pause_align_data.total_weight.sum()\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.post_process_pauserate",
        "documentation": {}
    },
    {
        "label": "get_rate",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.post_process_pauserate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.post_process_pauserate",
        "peekOfCode": "def get_rate(target_speech_tsv: str, source_speech_tsv: str) -> float:\n    speech_unit = \"syllable\"\n    target_speech_df = pd.read_csv(\n        target_speech_tsv, sep=\"\\t\", quoting=csv.QUOTE_MINIMAL\n    ).set_index(\"id\")\n    source_speech_df = pd.read_csv(\n        source_speech_tsv, sep=\"\\t\", quoting=csv.QUOTE_MINIMAL\n    ).set_index(\"id\")\n    # using \"syllable\" speech unit for rate computation\n    src_speech_rate = source_speech_df[f\"speech_rate_{speech_unit}\"].to_numpy()",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.post_process_pauserate",
        "documentation": {}
    },
    {
        "label": "run_asr_bleu_expressive_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.run_asr_bleu",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.run_asr_bleu",
        "peekOfCode": "def run_asr_bleu_expressive_model(\n    generation_dir_path: str,\n    generate_tsv_filename: str,\n    tgt_lang: str,\n):\n    compute_quality_metrics(\n        f\"{generation_dir_path}/{generate_tsv_filename}\",\n        Path(generation_dir_path),\n        tgt_lang,\n        \"S2ST\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.evaluate.run_asr_bleu",
        "documentation": {}
    },
    {
        "label": "remove_prosody_tokens_from_text",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "peekOfCode": "def remove_prosody_tokens_from_text(text: str) -> str:\n    # filter out prosody tokens, there is only emphasis '*', and pause '='\n    text = text.replace(\"*\", \"\").replace(\"=\", \"\")\n    text = \" \".join(text.split())\n    return text\ndef main() -> None:\n    parser = argparse.ArgumentParser(description=\"Running SeamlessExpressive inference.\")\n    parser.add_argument(\"input\", type=str, help=\"Audio WAV file path.\")\n    parser = add_inference_arguments(parser)\n    parser.add_argument(",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(description=\"Running SeamlessExpressive inference.\")\n    parser.add_argument(\"input\", type=str, help=\"Audio WAV file path.\")\n    parser = add_inference_arguments(parser)\n    parser.add_argument(\n        \"--gated-model-dir\",\n        type=Path,\n        required=False,\n        help=\"SeamlessExpressive model directory.\",\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "documentation": {}
    },
    {
        "label": "AUDIO_SAMPLE_RATE",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "peekOfCode": "AUDIO_SAMPLE_RATE = 16000\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s %(levelname)s -- %(name)s: %(message)s\",\n)\nlogger = logging.getLogger(__name__)\ndef remove_prosody_tokens_from_text(text: str) -> str:\n    # filter out prosody tokens, there is only emphasis '*', and pause '='\n    text = text.replace(\"*\", \"\").replace(\"=\", \"\")\n    text = \" \".join(text.split())",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef remove_prosody_tokens_from_text(text: str) -> str:\n    # filter out prosody tokens, there is only emphasis '*', and pause '='\n    text = text.replace(\"*\", \"\").replace(\"=\", \"\")\n    text = \" \".join(text.split())\n    return text\ndef main() -> None:\n    parser = argparse.ArgumentParser(description=\"Running SeamlessExpressive inference.\")\n    parser.add_argument(\"input\", type=str, help=\"Audio WAV file path.\")\n    parser = add_inference_arguments(parser)",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.predict",
        "documentation": {}
    },
    {
        "label": "PretsselGenerator",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.pretssel_generator",
        "description": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.pretssel_generator",
        "peekOfCode": "class PretsselGenerator(Module):\n    def __init__(\n        self,\n        pretssel_name_or_card: str,\n        vocab_info: VocabularyInfo,\n        device: Device,\n        dtype: DataType = torch.float16,\n    ):\n        super().__init__()\n        # Load the model.",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.expressivity.predict.pretssel_generator",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.audio_to_units.audio_to_units",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.audio_to_units.audio_to_units",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        description=\"Convert raw audio to units (and optionally audio) using UnitExtractor.\"\n    )\n    parser.add_argument(\"audio\", type=str, help=\"Audio WAV file path.\")\n    parser.add_argument(\n        \"--kmeans_uri\",\n        type=str,\n        help=\"URL path to the K-Means model.\",\n        default=\"https://dl.fbaipublicfiles.com/seamlessM4T/models/unit_extraction/kmeans_10k.npy\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.audio_to_units.audio_to_units",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.audio_to_units.audio_to_units",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.audio_to_units.audio_to_units",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Convert raw audio to units (and optionally audio) using UnitExtractor.\"\n    )\n    parser.add_argument(\"audio\", type=str, help=\"Audio WAV file path.\")\n    parser.add_argument(\n        \"--kmeans_uri\",\n        type=str,\n        help=\"URL path to the K-Means model.\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.audio_to_units.audio_to_units",
        "documentation": {}
    },
    {
        "label": "EvalContext",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "peekOfCode": "class EvalContext:\n    task: str\n    \"\"\"String representing the task. Valid choices are\n    \"S2ST\", \"S2TT\", \"T2ST\", \"T2TT\", \"ASR\".\"\"\"\n    input_modality: Modality\n    \"\"\"The input modality of the task.\"\"\"\n    output_modality: Modality\n    \"\"\"The output modality of the task.\"\"\"\n    model_name: str\n    \"\"\"The name of the S2T UnitY model.\"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "count_lines",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "peekOfCode": "def count_lines(filename: Path) -> int:\n    result = subprocess.run([\"wc\", \"-l\", filename], stdout=subprocess.PIPE)\n    return int(result.stdout.decode().split()[0])\ndef build_data_pipeline(\n    ctx: EvalContext,\n    text_tokenizer: TextTokenizer,\n) -> DataPipeline:\n    with open(ctx.data_file, \"r\") as f:\n        header = f.readline().strip(\"\\n\").split(\"\\t\")\n        first_example = f.readline().strip(\"\\n\").split(\"\\t\")",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "build_data_pipeline",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "peekOfCode": "def build_data_pipeline(\n    ctx: EvalContext,\n    text_tokenizer: TextTokenizer,\n) -> DataPipeline:\n    with open(ctx.data_file, \"r\") as f:\n        header = f.readline().strip(\"\\n\").split(\"\\t\")\n        first_example = f.readline().strip(\"\\n\").split(\"\\t\")\n    # TODO: This will be soon auto-tuned. Right now hand-tuned for devfair.\n    n_parallel = 4\n    split_tsv = StrSplitter(names=header)",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "adjust_output_for_corrupted_inputs",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "peekOfCode": "def adjust_output_for_corrupted_inputs(\n    valid_sequences: Tensor,\n    text_output: List[StringLike],\n    speech_output: Optional[BatchedSpeechOutput],\n) -> Tuple[List[StringLike], Optional[BatchedSpeechOutput]]:\n    adjusted_text_output: List[StringLike] = []\n    adjusted_speech_output: Optional[BatchedSpeechOutput] = None\n    if speech_output is not None:\n        assert (\n            len(text_output)",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "run_eval",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "peekOfCode": "def run_eval(\n    translator: Translator,\n    text_tokenizer: TextTokenizer,\n    ctx: EvalContext,\n    whisper_model_name: str,\n) -> None:\n    pipeline = build_data_pipeline(ctx, text_tokenizer)\n    total_steps = count_lines(ctx.data_file) - 1\n    progress_bar = tqdm(total=total_steps)\n    output_path = ctx.output_path / ctx.data_file.stem",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "peekOfCode": "def main(optional_args: Optional[Dict[str, Any]] = None) -> None:\n    parser = argparse.ArgumentParser(\n        description=\"M4T evaluation for tasks supported by Translator.\"\n    )\n    parser.add_argument(\n        \"--data_file\", type=str, help=\"Data file (.tsv) to be evaluated.\"\n    )\n    parser = add_inference_arguments(parser)\n    parser.add_argument(\n        \"--batch_size\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass EvalContext:\n    task: str\n    \"\"\"String representing the task. Valid choices are\n    \"S2ST\", \"S2TT\", \"T2ST\", \"T2TT\", \"ASR\".\"\"\"\n    input_modality: Modality\n    \"\"\"The input modality of the task.\"\"\"\n    output_modality: Modality\n    \"\"\"The output modality of the task.\"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.evaluate.evaluate",
        "documentation": {}
    },
    {
        "label": "SeqsBatch",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "peekOfCode": "class SeqsBatch:\n    src_tokens: Optional[Tensor]\n    src_lengths: Optional[Tensor]\n    target_tokens: Optional[Tensor]\n    prev_output_tokens: Optional[Tensor]\n    target_lengths: Optional[Tensor]\n    def __del__(self) -> None:\n        \"\"\"Explicitly delete tensors\n        to force GPU memory cleanup\"\"\"\n        for tensor in [",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "documentation": {}
    },
    {
        "label": "MultimodalSeqsBatch",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "peekOfCode": "class MultimodalSeqsBatch:\n    speech_to_text: SeqsBatch\n    text_to_units: SeqsBatch\n    def __del__(self) -> None:\n        del self.speech_to_text\n        del self.text_to_units\n@dataclass\nclass BatchingConfig:\n    fbank_feats_pad_idx: int = 0\n    \"\"\"The pad index to use in fbanks batching.\"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "documentation": {}
    },
    {
        "label": "BatchingConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "peekOfCode": "class BatchingConfig:\n    fbank_feats_pad_idx: int = 0\n    \"\"\"The pad index to use in fbanks batching.\"\"\"\n    batch_size: int = 5\n    \"\"\"Fixed batch size to use\"\"\"\n    max_audio_length_sec: float = 15.0\n    \"\"\" Drop samples with source audio sample length above the threshold.\"\"\"\n    rank: int = 0\n    \"\"\"The rank of this worker in the process group.\"\"\"\n    world_size: int = 1",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "documentation": {}
    },
    {
        "label": "UnitYDataLoader",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "peekOfCode": "class UnitYDataLoader:\n    SAMPLE_RATE = 16_000\n    def __init__(\n        self,\n        text_tokenizer: NllbTokenizer,\n        unit_tokenizer: UnitTokenizer,\n        dataset_manifest_path: str,\n        batching_config: BatchingConfig,\n    ):\n        self.text_tokenizer = text_tokenizer",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "documentation": {}
    },
    {
        "label": "worker_init_fn",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "peekOfCode": "def worker_init_fn(worker_id: int) -> None:\n    np.random.seed(np.random.get_state()[1][0] + worker_id)  # type: ignore\nclass UnitYDataLoader:\n    SAMPLE_RATE = 16_000\n    def __init__(\n        self,\n        text_tokenizer: NllbTokenizer,\n        unit_tokenizer: UnitTokenizer,\n        dataset_manifest_path: str,\n        batching_config: BatchingConfig,",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass SeqsBatch:\n    src_tokens: Optional[Tensor]\n    src_lengths: Optional[Tensor]\n    target_tokens: Optional[Tensor]\n    prev_output_tokens: Optional[Tensor]\n    target_lengths: Optional[Tensor]\n    def __del__(self) -> None:\n        \"\"\"Explicitly delete tensors",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataloader",
        "documentation": {}
    },
    {
        "label": "UnitSpeechTokenizer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "peekOfCode": "class UnitSpeechTokenizer(SpeechTokenizer):\n    MODEL_NAME = \"xlsr2_1b_v2\"\n    KMEANS_MODEL_URI = \"https://dl.fbaipublicfiles.com/seamlessM4T/models/unit_extraction/kmeans_10k.npy\"\n    OUTPUT_LAYER_IDX = 34\n    def __init__(self, device: torch.device):\n        super().__init__()\n        self.device = device\n        self.unit_extractor = UnitExtractor(\n            model_name_or_card=self.MODEL_NAME,\n            kmeans_uri=self.KMEANS_MODEL_URI,",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "documentation": {}
    },
    {
        "label": "download_fleurs_dataset",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "peekOfCode": "def download_fleurs_dataset(\n    source_lang: str,\n    target_lang: str,\n    split: str,\n    save_directory: str,\n) -> str:\n    _check_lang_code_mapping(source_lang)\n    _check_lang_code_mapping(target_lang)\n    device = (\n        torch.device(\"cuda:0\") if torch.cuda.device_count() > 0 else torch.device(\"cpu\")",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "documentation": {}
    },
    {
        "label": "init_parser",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "peekOfCode": "def init_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(\n        description=(\n            \"Helper script to download training/evaluation dataset (FLEURS),\"\n            \"extract units from target audio and save the dataset as a manifest \"\n            \"consumable by `finetune.py`.\"\n        )\n    )\n    parser.add_argument(\n        \"--source_lang\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "peekOfCode": "def main() -> None:\n    args = init_parser().parse_args()\n    manifest_path = download_fleurs_dataset(\n        source_lang=args.source_lang,\n        target_lang=args.target_lang,\n        split=args.split,\n        save_directory=args.save_dir,\n    )\n    logger.info(f\"Manifest saved to: {manifest_path}\")\nif __name__ == \"__main__\":",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "peekOfCode": "logger = logging.getLogger(\"dataset\")\n# Full list of FLEURS langcodes is available at https://huggingface.co/datasets/google/fleurs\n# Full list of M4T langcodes is available\n# in paper \"SeamlessM4T—Massively Multilingual & Multimodal Machine Translation\" (Table 5)\nUNITY_TO_FLEURS_LANG_MAPPING = {\n    \"eng\": \"en_us\",\n    \"ita\": \"it_it\",\n    \"afr\": \"af_za\",\n    \"asm\": \"as_in\",\n    \"bel\": \"be_by\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "documentation": {}
    },
    {
        "label": "UNITY_TO_FLEURS_LANG_MAPPING",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "peekOfCode": "UNITY_TO_FLEURS_LANG_MAPPING = {\n    \"eng\": \"en_us\",\n    \"ita\": \"it_it\",\n    \"afr\": \"af_za\",\n    \"asm\": \"as_in\",\n    \"bel\": \"be_by\",\n    \"bul\": \"bg_bg\",\n    \"ben\": \"bn_in\",\n    \"cat\": \"ca_es\",\n    \"ces\": \"cs_cz\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dataset",
        "documentation": {}
    },
    {
        "label": "is_dist_initialized",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "peekOfCode": "def is_dist_initialized() -> bool:\n    if not dist.is_available():\n        return False\n    if not dist.is_initialized():\n        return False\n    return True\ndef get_rank() -> int:\n    if not is_dist_initialized():\n        return 0\n    return dist.get_rank()",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "documentation": {}
    },
    {
        "label": "get_rank",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "peekOfCode": "def get_rank() -> int:\n    if not is_dist_initialized():\n        return 0\n    return dist.get_rank()\ndef get_local_rank() -> int:\n    if not is_dist_initialized():\n        return 0\n    return int(os.environ[\"LOCAL_RANK\"])\ndef get_world_size() -> int:\n    if not is_dist_initialized():",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "documentation": {}
    },
    {
        "label": "get_local_rank",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "peekOfCode": "def get_local_rank() -> int:\n    if not is_dist_initialized():\n        return 0\n    return int(os.environ[\"LOCAL_RANK\"])\ndef get_world_size() -> int:\n    if not is_dist_initialized():\n        return 1\n    return dist.get_world_size()\ndef is_main_process() -> bool:\n    return get_rank() == 0",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "documentation": {}
    },
    {
        "label": "get_world_size",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "peekOfCode": "def get_world_size() -> int:\n    if not is_dist_initialized():\n        return 1\n    return dist.get_world_size()\ndef is_main_process() -> bool:\n    return get_rank() == 0\ndef init_distributed(loggers: List[logging.Logger]) -> None:\n    \"\"\"Initializes the distributed backend\"\"\"\n    torch.multiprocessing.set_start_method(\"spawn\")\n    if \"RANK\" not in os.environ:",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "documentation": {}
    },
    {
        "label": "is_main_process",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "peekOfCode": "def is_main_process() -> bool:\n    return get_rank() == 0\ndef init_distributed(loggers: List[logging.Logger]) -> None:\n    \"\"\"Initializes the distributed backend\"\"\"\n    torch.multiprocessing.set_start_method(\"spawn\")\n    if \"RANK\" not in os.environ:\n        logger.error(\n            \"Cannot init disributed context, as environment varaibles are not set.\"\n        )\n        return",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "documentation": {}
    },
    {
        "label": "init_distributed",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "peekOfCode": "def init_distributed(loggers: List[logging.Logger]) -> None:\n    \"\"\"Initializes the distributed backend\"\"\"\n    torch.multiprocessing.set_start_method(\"spawn\")\n    if \"RANK\" not in os.environ:\n        logger.error(\n            \"Cannot init disributed context, as environment varaibles are not set.\"\n        )\n        return\n    rank = int(os.environ[\"RANK\"])\n    world_size = int(os.environ[\"WORLD_SIZE\"])",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef is_dist_initialized() -> bool:\n    if not dist.is_available():\n        return False\n    if not dist.is_initialized():\n        return False\n    return True\ndef get_rank() -> int:\n    if not is_dist_initialized():\n        return 0",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.dist_utils",
        "documentation": {}
    },
    {
        "label": "init_parser",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.finetune",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.finetune",
        "peekOfCode": "def init_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(\n        description=\"Example finetuning script for M4T models\"\n    )\n    parser.add_argument(\n        \"--train_dataset\",\n        type=Path,\n        required=True,\n        help=\"Path to manifest with train samples\",\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.finetune",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.finetune",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.finetune",
        "peekOfCode": "def main() -> None:\n    args = init_parser().parse_args()\n    dist_utils.init_distributed([logger, trainer.logger])\n    device = torch.device(\"cuda\")\n    float_dtype = torch.float16\n    text_tokenizer: NllbTokenizer = load_unity_text_tokenizer(args.model_name)\n    unit_tokenizer: UnitTokenizer = load_unity_unit_tokenizer(args.model_name)\n    finetune_params = trainer.FinetuneParams(\n        finetune_mode=args.mode,\n        save_model_path=args.save_model_to,",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.finetune",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.finetune",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.finetune",
        "peekOfCode": "logger = logging.getLogger(\"finetune\")\ndef init_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(\n        description=\"Example finetuning script for M4T models\"\n    )\n    parser.add_argument(\n        \"--train_dataset\",\n        type=Path,\n        required=True,\n        help=\"Path to manifest with train samples\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.finetune",
        "documentation": {}
    },
    {
        "label": "FinetuneMode",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "peekOfCode": "class FinetuneMode(Enum):\n    SPEECH_TO_SPEECH = \"SPEECH_TO_SPEECH\"\n    SPEECH_TO_TEXT = \"SPEECH_TO_TEXT\"\n    TEXT_TO_SPEECH = \"TEXT_TO_SPEECH\"\n@dataclass\nclass FinetuneParams:\n    save_model_path: Path\n    \"\"\"Path were to save finetuned model.\"\"\"\n    finetune_mode: FinetuneMode = FinetuneMode.TEXT_TO_SPEECH\n    \"\"\"Allows to freeze S2T or T2U part of the model\"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "documentation": {}
    },
    {
        "label": "FinetuneParams",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "peekOfCode": "class FinetuneParams:\n    save_model_path: Path\n    \"\"\"Path were to save finetuned model.\"\"\"\n    finetune_mode: FinetuneMode = FinetuneMode.TEXT_TO_SPEECH\n    \"\"\"Allows to freeze S2T or T2U part of the model\"\"\"\n    max_epochs: int = 10\n    \"\"\" Maximum number of trainign epochs\"\"\"\n    label_smoothing: float = 0.2\n    \"\"\" Label smoothing coefficient for nll_loss \"\"\"\n    warmup_steps: int = 100",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "documentation": {}
    },
    {
        "label": "UnitYFinetuneWrapper",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "peekOfCode": "class UnitYFinetuneWrapper(nn.Module):\n    \"\"\"Convenience wrapper that does a forward pass\n    and returns S2T and T2U logits\"\"\"\n    def __init__(self, model: UnitYModel, mode: FinetuneMode, device: Device):\n        super().__init__()\n        self.model: UnitYModel = model\n        self.freeze_s2t: bool = mode == FinetuneMode.TEXT_TO_SPEECH\n        self.freeze_t2u: bool = mode == FinetuneMode.SPEECH_TO_TEXT\n        logger.info(f\"Freeze s2t: {self.freeze_s2t}, freeze t2u: {self.freeze_t2u}\")\n        self.device = device",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "documentation": {}
    },
    {
        "label": "CalcLoss",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "peekOfCode": "class CalcLoss:\n    \"\"\"Calculates negative log likelihood loss for S2T and T2U\"\"\"\n    def __init__(\n        self,\n        label_smoothing: float,\n        s2t_vocab_info: VocabularyInfo,\n        t2u_vocab_info: Optional[VocabularyInfo],\n    ):\n        self.label_smoothing = label_smoothing\n        self.s2t_vocab_info = s2t_vocab_info",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "documentation": {}
    },
    {
        "label": "LossCollector",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "peekOfCode": "class LossCollector:\n    \"\"\"Aggregrates loss history across nodes\"\"\"\n    def __init__(self, device: Optional[Device] = None, reduce_op: str = \"avg\"):\n        self.n_samples: float = 0\n        self.val_sum: float = 0.0\n        self.reduce_op = reduce_op\n        self.device = device\n        self.is_distributed = dist_utils.is_dist_initialized()\n    def reset(self) -> None:\n        self.n_samples = 0",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "documentation": {}
    },
    {
        "label": "UnitYFinetune",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "peekOfCode": "class UnitYFinetune:\n    def __init__(\n        self,\n        model: UnitYModel,\n        params: FinetuneParams,\n        train_data_loader: dataloader.UnitYDataLoader,\n        eval_data_loader: Optional[dataloader.UnitYDataLoader] = None,\n    ):\n        self.params = params\n        self.calc_loss = CalcLoss(",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass FinetuneMode(Enum):\n    SPEECH_TO_SPEECH = \"SPEECH_TO_SPEECH\"\n    SPEECH_TO_TEXT = \"SPEECH_TO_TEXT\"\n    TEXT_TO_SPEECH = \"TEXT_TO_SPEECH\"\n@dataclass\nclass FinetuneParams:\n    save_model_path: Path\n    \"\"\"Path were to save finetuned model.\"\"\"\n    finetune_mode: FinetuneMode = FinetuneMode.TEXT_TO_SPEECH",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.finetune.trainer",
        "documentation": {}
    },
    {
        "label": "add_inference_arguments",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "peekOfCode": "def add_inference_arguments(parser: argparse.ArgumentParser) -> argparse.ArgumentParser:\n    parser.add_argument(\"--task\", type=str, help=\"Task type\")\n    parser.add_argument(\n        \"--tgt_lang\", type=str, help=\"Target language to translate/transcribe into.\"\n    )\n    parser.add_argument(\n        \"--src_lang\",\n        type=str,\n        help=\"Source language, only required if input is text.\",\n        default=None,",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "documentation": {}
    },
    {
        "label": "set_generation_opts",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "peekOfCode": "def set_generation_opts(\n    args: Namespace,\n) -> Tuple[SequenceGeneratorOptions, SequenceGeneratorOptions]:\n    # Set text, unit generation opts.\n    text_generation_opts = SequenceGeneratorOptions(\n        beam_size=args.text_generation_beam_size,\n        soft_max_seq_len=(\n            args.text_generation_max_len_a,\n            args.text_generation_max_len_b,\n        ),",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"M4T inference on supported tasks using Translator.\"\n    )\n    parser.add_argument(\"input\", type=str, help=\"Audio WAV file path or text input.\")\n    parser = add_inference_arguments(parser)\n    args = parser.parse_args()\n    if not args.task or not args.tgt_lang:\n        raise Exception(\n            \"Please provide required arguments for evaluation -  task, tgt_lang\"",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "description": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef add_inference_arguments(parser: argparse.ArgumentParser) -> argparse.ArgumentParser:\n    parser.add_argument(\"--task\", type=str, help=\"Task type\")\n    parser.add_argument(\n        \"--tgt_lang\", type=str, help=\"Target language to translate/transcribe into.\"\n    )\n    parser.add_argument(\n        \"--src_lang\",\n        type=str,\n        help=\"Source language, only required if input is text.\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.m4t.predict.predict",
        "documentation": {}
    },
    {
        "label": "SeamlessQualityScorer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.streaming.scorers.seamless_quality_scorer",
        "description": "lib.seamless_communication.src.seamless_communication.cli.streaming.scorers.seamless_quality_scorer",
        "peekOfCode": "class SeamlessQualityScorer(QualityScorer):  # type: ignore\n    def __init__(\n        self,\n        tgt_lang: str,\n        task: str,\n        output_dir: str,\n        device: Device = \"cuda:0\",\n        whisper_model_name: str = \"large\",\n        whisper_normalize_text_output: Optional[bool] = None,\n        ref_text_col_name: str = \"ref_tgt_text\",",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.streaming.scorers.seamless_quality_scorer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.streaming.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.streaming.evaluate",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(\n        add_help=False,\n        description=\"Streaming evaluation of Seamless UnitY models\",\n        conflict_handler=\"resolve\",\n    )\n    parser.add_argument(\n        \"--task\",\n        choices=[\"s2st\", \"s2tt\", \"asr\"],\n        required=True,",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.streaming.evaluate",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.streaming.evaluate",
        "description": "lib.seamless_communication.src.seamless_communication.cli.streaming.evaluate",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        add_help=False,\n        description=\"Streaming evaluation of Seamless UnitY models\",\n        conflict_handler=\"resolve\",\n    )\n    parser.add_argument(\n        \"--task\",\n        choices=[\"s2st\", \"s2tt\", \"asr\"],",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.streaming.evaluate",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "description": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"ASR ETOX will compute the toxicity level of speech inputs.\"\n    )\n    parser.add_argument(\n        \"data_file\",\n        type=Path,\n        help=\"Path to the input TSV manifest that list the audio files.\",\n    )\n    parser.add_argument(",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "documentation": {}
    },
    {
        "label": "get_text",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "description": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "peekOfCode": "def get_text(\n    lang: str,\n    example: tp.Dict[str, tp.Any],\n    whisper_model: Whisper,\n    translator: Translator,\n    audio_column: str,\n):\n    if whisper_model:\n        with tempfile.NamedTemporaryFile(suffix=\".wav\") as temp:\n            torchaudio.save(",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "documentation": {}
    },
    {
        "label": "build_data_pipeline",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "description": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "peekOfCode": "def build_data_pipeline(\n    data_file: Path,\n    audio_root_dir: str,\n    batch_size: int,\n    is_whisper: bool,\n    device: Device,\n    dtype: DataType,\n    audio_column: str = \"audio\",\n    n_parallel: int = 4,\n) -> DataPipeline:",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "description": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"ASR ETOX will compute the toxicity level of speech inputs.\"\n    )\n    parser.add_argument(\n        \"data_file\",\n        type=Path,\n        help=\"Path to the input TSV manifest that list the audio files.\",\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.asr_etox",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.etox",
        "description": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.etox",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"ETOX will compute the toxicity level of text inputs (STDIN > STDOUT).\"\n    )\n    parser.add_argument(\n        \"lang\",\n        type=str,\n        help=\"Language, language of the speech to transcribe\",\n    )\n    parser.add_argument(",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.toxicity.etox.etox",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_speech",
        "description": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_speech",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Mutox speech will compute a toxicity score for each speech segment it is provided.\"\n    )\n    parser.add_argument(\n        \"data_file\",\n        type=Path,\n        help=\"Path to the input TSV manifest that list the audio files.\",\n    )\n    parser.add_argument(",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_speech",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_speech",
        "description": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_speech",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Mutox speech will compute a toxicity score for each speech segment it is provided.\"\n    )\n    parser.add_argument(\n        \"data_file\",\n        type=Path,\n        help=\"Path to the input TSV manifest that list the audio files.\",\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_speech",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_text",
        "description": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_text",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Mutox Text will compute a toxicity score for each sentence it is passed.\"\n    )\n    parser.add_argument(\n        \"lang\",\n        type=str,\n        help=\"Language of the input text, nllb format with script.\",\n    )\n    parser.add_argument(",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_text",
        "documentation": {}
    },
    {
        "label": "CPU_DEVICE",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_text",
        "description": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_text",
        "peekOfCode": "CPU_DEVICE = torch.device(\"cpu\")\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Mutox Text will compute a toxicity score for each sentence it is passed.\"\n    )\n    parser.add_argument(\n        \"lang\",\n        type=str,\n        help=\"Language of the input text, nllb format with script.\",\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.cli.toxicity.mutox.mutox_text",
        "documentation": {}
    },
    {
        "label": "MultimodalSample",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.datasets.datatypes",
        "description": "lib.seamless_communication.src.seamless_communication.datasets.datatypes",
        "peekOfCode": "class MultimodalSample:\n    id: int\n    lang: str\n    text: str\n    audio_local_path: Optional[str] = None\n    waveform: Optional[torch.Tensor] = None\n    sampling_rate: Optional[int] = None\n    units: Optional[List[int]] = None\n    @classmethod\n    def from_json(cls, js: Dict[str, Any]) -> \"MultimodalSample\":",
        "detail": "lib.seamless_communication.src.seamless_communication.datasets.datatypes",
        "documentation": {}
    },
    {
        "label": "LangPairSample",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.datasets.datatypes",
        "description": "lib.seamless_communication.src.seamless_communication.datasets.datatypes",
        "peekOfCode": "class LangPairSample:\n    source: MultimodalSample\n    target: MultimodalSample\n    @classmethod\n    def from_json(cls, js: Dict[str, Any]) -> \"LangPairSample\":\n        return cls(\n            source=MultimodalSample.from_json(js[\"source\"]),\n            target=MultimodalSample.from_json(js[\"target\"]),\n        )",
        "detail": "lib.seamless_communication.src.seamless_communication.datasets.datatypes",
        "documentation": {}
    },
    {
        "label": "SpeechTokenizer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.datasets.huggingface",
        "description": "lib.seamless_communication.src.seamless_communication.datasets.huggingface",
        "peekOfCode": "class SpeechTokenizer:\n    @abstractmethod\n    def encode(self, wav: torch.Tensor, sample_rate: int) -> torch.Tensor:\n        ...\nclass Speech2SpeechFleursDatasetBuilder:\n    \"\"\"Assembles speech2speech dataset from google/fleurs on HuggingFace\"\"\"\n    HF_FLEURS_DATASET_NAME = \"google/fleurs\"\n    def __init__(\n        self,\n        source_lang: str,",
        "detail": "lib.seamless_communication.src.seamless_communication.datasets.huggingface",
        "documentation": {}
    },
    {
        "label": "Speech2SpeechFleursDatasetBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.datasets.huggingface",
        "description": "lib.seamless_communication.src.seamless_communication.datasets.huggingface",
        "peekOfCode": "class Speech2SpeechFleursDatasetBuilder:\n    \"\"\"Assembles speech2speech dataset from google/fleurs on HuggingFace\"\"\"\n    HF_FLEURS_DATASET_NAME = \"google/fleurs\"\n    def __init__(\n        self,\n        source_lang: str,\n        target_lang: str,\n        split: str = \"test\",\n        skip_source_audio: bool = True,\n        skip_target_audio: bool = True,",
        "detail": "lib.seamless_communication.src.seamless_communication.datasets.huggingface",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.datasets.huggingface",
        "description": "lib.seamless_communication.src.seamless_communication.datasets.huggingface",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass SpeechTokenizer:\n    @abstractmethod\n    def encode(self, wav: torch.Tensor, sample_rate: int) -> torch.Tensor:\n        ...\nclass Speech2SpeechFleursDatasetBuilder:\n    \"\"\"Assembles speech2speech dataset from google/fleurs on HuggingFace\"\"\"\n    HF_FLEURS_DATASET_NAME = \"google/fleurs\"\n    def __init__(\n        self,",
        "detail": "lib.seamless_communication.src.seamless_communication.datasets.huggingface",
        "documentation": {}
    },
    {
        "label": "SequenceGeneratorOptions",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.generator",
        "description": "lib.seamless_communication.src.seamless_communication.inference.generator",
        "peekOfCode": "class SequenceGeneratorOptions:\n    \"\"\"Holds the options to pass to a sequence generator.\"\"\"\n    beam_size: int = 5\n    \"\"\"The beam size.\"\"\"\n    soft_max_seq_len: Tuple[int, int] = (1, 200)\n    \"\"\"The terms ``a`` and ``b`` of ``ax + b`` where ``x`` is the source\n    sequence length. The generated sequences (including prefix sequence) will\n    have the maximum length of ``min(hard_max_seq_len, ax + b)``. See also\n    ``hard_max_seq_len``.\"\"\"\n    hard_max_seq_len: int = 1024",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.generator",
        "documentation": {}
    },
    {
        "label": "UnitYGenerator",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.generator",
        "description": "lib.seamless_communication.src.seamless_communication.inference.generator",
        "peekOfCode": "class UnitYGenerator:\n    \"\"\"Generates text translations and speech units from a UnitY model.\"\"\"\n    model: UnitYModel\n    s2t_converter: SequenceToTextConverter\n    t2t_converter: Optional[SequenceToTextConverter]\n    unit_decoder: Optional[UnitTokenDecoder]\n    unit_prefix_indices: Optional[Tensor]\n    unit_generator: Optional[Seq2SeqGenerator]\n    def __init__(\n        self,",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.generator",
        "documentation": {}
    },
    {
        "label": "remove_consecutive_repeated_ngrams",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.generator",
        "description": "lib.seamless_communication.src.seamless_communication.inference.generator",
        "peekOfCode": "def remove_consecutive_repeated_ngrams(\n    sequence: List[int], min_size: int = 1, max_size: int = 40\n) -> List[int]:\n    assert 1 <= min_size <= max_size\n    drop_idx = set()  # indices that will be dropped from the sequence\n    # start from the beginning, check if an ngram of size k (for k=max..min) is\n    # followed by its copy, if so delete the first one, and start over after\n    # the deleted ngram.\n    start = 0\n    while start < len(sequence):",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.generator",
        "documentation": {}
    },
    {
        "label": "EncDecAttentionsCollect",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "description": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "peekOfCode": "class EncDecAttentionsCollect(AttentionWeightHook):\n    def __init__(self):\n        super().__init__()\n        self.attn_scores = []\n    def __call__(self, m, attn, attn_weights) -> None:\n        if attn_weights.shape[-2] > 1:\n            val = torch.clone(attn_weights).detach().sum(dim=0).squeeze(0).tolist()\n            self.attn_scores.extend(val)\n        else:\n            val = (",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "documentation": {}
    },
    {
        "label": "TranscriptionToken",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "description": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "peekOfCode": "class TranscriptionToken:\n    text: str\n    time_s: float\n    prob: float\n    def __init__(self, text: str, time_s: float, prob: float):\n        self.text = text\n        self.time_s = time_s\n        self.prob = prob\nclass Transcription:\n    text: str",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "documentation": {}
    },
    {
        "label": "Transcription",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "description": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "peekOfCode": "class Transcription:\n    text: str\n    tokens: List[TranscriptionToken]\n    def __init__(self, tokens: List[TranscriptionToken]):\n        self.text = \" \".join([t.text for t in tokens])\n        self.tokens = tokens\n    def __str__(self):\n        return self.text\n    def __repr__(self):\n        return self.text",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "documentation": {}
    },
    {
        "label": "Transcriber",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "description": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "peekOfCode": "class Transcriber(nn.Module):\n    def __init__(\n        self,\n        model_name_or_card: Union[str, AssetCard],\n        device: torch.device = torch.device(\"cpu\"),\n        dtype: torch.dtype = torch.float32,\n        encoder_layers: int = 6,\n        decoder_layers: int = 3,\n        embed_dim: int = 512,\n        depthwise_conv_kernel_size: int = 31,",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.transcriber",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "description": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "peekOfCode": "class Task(Enum):\n    S2ST = auto()\n    S2TT = auto()\n    T2ST = auto()\n    T2TT = auto()\n    ASR = auto()\nclass Modality(Enum):\n    SPEECH = \"speech\"\n    TEXT = \"text\"\n@dataclass",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "Modality",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "description": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "peekOfCode": "class Modality(Enum):\n    SPEECH = \"speech\"\n    TEXT = \"text\"\n@dataclass\nclass BatchedSpeechOutput:\n    units: List[List[int]]\n    \"\"\"The batched list of generated units.\"\"\"\n    audio_wavs: List[Tensor]\n    \"\"\"The batched list of audio waveforms.\"\"\"\n    sample_rate: int = 16000",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "BatchedSpeechOutput",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "description": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "peekOfCode": "class BatchedSpeechOutput:\n    units: List[List[int]]\n    \"\"\"The batched list of generated units.\"\"\"\n    audio_wavs: List[Tensor]\n    \"\"\"The batched list of audio waveforms.\"\"\"\n    sample_rate: int = 16000\n    \"\"\"Sample rate of the audio waveforms.\"\"\"\nclass Translator(nn.Module):\n    def __init__(\n        self,",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "Translator",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "description": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "peekOfCode": "class Translator(nn.Module):\n    def __init__(\n        self,\n        model_name_or_card: Union[str, AssetCard],\n        vocoder_name_or_card: Union[str, AssetCard, None],\n        device: Device,\n        text_tokenizer: Optional[TextTokenizer] = None,\n        apply_mintox: bool = False,\n        dtype: DataType = torch.float16,\n        input_modality: Optional[Modality] = None,",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "description": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass Task(Enum):\n    S2ST = auto()\n    S2TT = auto()\n    T2ST = auto()\n    T2TT = auto()\n    ASR = auto()\nclass Modality(Enum):\n    SPEECH = \"speech\"\n    TEXT = \"text\"",
        "detail": "lib.seamless_communication.src.seamless_communication.inference.translator",
        "documentation": {}
    },
    {
        "label": "AlignmentExtractor",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.alignment_extractor",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.alignment_extractor",
        "peekOfCode": "class AlignmentExtractor(nn.Module):\n    def __init__(\n        self,\n        aligner_model_name_or_card: str,\n        unit_extractor_model_name_or_card: Union[Any, str] = None,\n        unit_extractor_output_layer: Union[Any, int] = None,\n        unit_extractor_kmeans_model_uri: Union[Any, str] = None,\n        device: Device = Device(\"cpu\"),\n        dtype: DataType = torch.float32,\n    ):",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.alignment_extractor",
        "documentation": {}
    },
    {
        "label": "AlignmentEncoderConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "peekOfCode": "class AlignmentEncoderConfig:\n    model_dim: int\n    feat_dim: int\n    num_text_layers: int\n    num_feat_layers: int\n    dropout: float\n    temperature: float\n    reduction_factor: int\n@dataclass\nclass UnitY2AlignmentFrontendConfig:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentFrontendConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "peekOfCode": "class UnitY2AlignmentFrontendConfig:\n    unit_vocab_info: VocabularyInfo\n    text_vocab_size: int\n@dataclass\nclass UnitY2AlignmentConfig:\n    model_name_or_card: Union[str, AssetCard]\n    alignment_encoder_config: AlignmentEncoderConfig\n    alignment_frontend_config: UnitY2AlignmentFrontendConfig\naligner_archs = ArchitectureRegistry[UnitY2AlignmentConfig](\"unity2_aligner\")\naligner_arch = aligner_archs.decorator",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "peekOfCode": "class UnitY2AlignmentConfig:\n    model_name_or_card: Union[str, AssetCard]\n    alignment_encoder_config: AlignmentEncoderConfig\n    alignment_frontend_config: UnitY2AlignmentFrontendConfig\naligner_archs = ArchitectureRegistry[UnitY2AlignmentConfig](\"unity2_aligner\")\naligner_arch = aligner_archs.decorator\n@aligner_arch(\"nar_t2u_aligner\")\ndef _aligner_nar_t2u() -> UnitY2AlignmentConfig:\n    encoder_config = AlignmentEncoderConfig(\n        model_dim=1024,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "peekOfCode": "class UnitY2AlignmentBuilder:\n    config: UnitY2AlignmentConfig\n    device: Optional[Device]\n    dtype: DataType\n    def __init__(\n        self,\n        config: UnitY2AlignmentConfig,\n        *,\n        device: Optional[Device] = None,\n        dtype: DataType = torch.float32,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "create_unity2_alignment_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "peekOfCode": "def create_unity2_alignment_model(\n    config: UnitY2AlignmentConfig,\n    device: Optional[Device] = None,\n    dtype: DataType = torch.float32,\n) -> UnitY2AlignmentModel:\n    \"\"\"Create a UnitY model.\n    :param config:\n        The configuration to use.\n    :param device:\n        The device on which to initialize modules.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "aligner_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "peekOfCode": "aligner_archs = ArchitectureRegistry[UnitY2AlignmentConfig](\"unity2_aligner\")\naligner_arch = aligner_archs.decorator\n@aligner_arch(\"nar_t2u_aligner\")\ndef _aligner_nar_t2u() -> UnitY2AlignmentConfig:\n    encoder_config = AlignmentEncoderConfig(\n        model_dim=1024,\n        feat_dim=1024,\n        num_text_layers=2,\n        num_feat_layers=3,\n        dropout=0.1,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "aligner_arch",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "peekOfCode": "aligner_arch = aligner_archs.decorator\n@aligner_arch(\"nar_t2u_aligner\")\ndef _aligner_nar_t2u() -> UnitY2AlignmentConfig:\n    encoder_config = AlignmentEncoderConfig(\n        model_dim=1024,\n        feat_dim=1024,\n        num_text_layers=2,\n        num_feat_layers=3,\n        dropout=0.1,\n        temperature=1.0,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.builder",
        "documentation": {}
    },
    {
        "label": "convert_unity2_aligner_checkpoint",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.loader",
        "peekOfCode": "def convert_unity2_aligner_checkpoint(\n    checkpoint: Mapping[str, Any], config: UnitY2AlignmentConfig\n) -> Mapping[str, Any]:\n    if (\n        \"model\" in checkpoint\n        and \"alignment_encoder.t_conv.1.weight\" in checkpoint[\"model\"]\n    ):\n        return checkpoint\n    alignment_frontend_statedict = {}\n    text_emb_state_keymap = {\"weight\": \"alignment_frontend.embed_text.weight\"}",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.loader",
        "documentation": {}
    },
    {
        "label": "load_unity2_alignment_config",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.loader",
        "peekOfCode": "load_unity2_alignment_config = ConfigLoader[UnitY2AlignmentConfig](\n    asset_store, aligner_archs\n)\nload_unity2_alignment_model = ModelLoader[UnitY2AlignmentModel, UnitY2AlignmentConfig](\n    asset_store,\n    download_manager,\n    load_unity2_alignment_config,\n    create_unity2_alignment_model,\n    convert_unity2_aligner_checkpoint,\n    restrict_checkpoints=False,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.loader",
        "documentation": {}
    },
    {
        "label": "load_unity2_alignment_model",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.loader",
        "peekOfCode": "load_unity2_alignment_model = ModelLoader[UnitY2AlignmentModel, UnitY2AlignmentConfig](\n    asset_store,\n    download_manager,\n    load_unity2_alignment_config,\n    create_unity2_alignment_model,\n    convert_unity2_aligner_checkpoint,\n    restrict_checkpoints=False,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.loader",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentFrontend",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "peekOfCode": "class UnitY2AlignmentFrontend(Module):\n    def __init__(\n        self,\n        embed_text: StandardEmbedding,\n        embed_unit: StandardEmbedding,\n        text_tokenizer: CharTokenizer,\n        unit_tokenizer: UnitTokenizer,\n    ):\n        super().__init__()\n        self.embed_text = embed_text",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "documentation": {}
    },
    {
        "label": "Permute12",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "peekOfCode": "class Permute12(nn.Module):\n    def forward(self, x: Tensor) -> Tensor:\n        return x.transpose(1, 2)\nclass UnitY2AlignmentEncoder(Module):\n    \"\"\"\n    UnitY2 Aligner component\n    \"\"\"\n    def __init__(\n        self,\n        embed_dim: int,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentEncoder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "peekOfCode": "class UnitY2AlignmentEncoder(Module):\n    \"\"\"\n    UnitY2 Aligner component\n    \"\"\"\n    def __init__(\n        self,\n        embed_dim: int,\n        feat_dim: int,\n        text_layers: int,\n        feat_layers: int,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "documentation": {}
    },
    {
        "label": "UnitY2AlignmentModel",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "peekOfCode": "class UnitY2AlignmentModel(Module):\n    alignment_encoder: UnitY2AlignmentEncoder\n    alignment_frontend: UnitY2AlignmentFrontend\n    def __init__(\n        self,\n        alignment_frontend: UnitY2AlignmentFrontend,\n        alignment_encoder: UnitY2AlignmentEncoder,\n    ):\n        super().__init__()\n        self.alignment_frontend = alignment_frontend",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "documentation": {}
    },
    {
        "label": "viterbi_decode",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "peekOfCode": "def viterbi_decode(\n    attn_lprob: Tensor, text_lengths: Tensor, feat_lengths: Tensor\n) -> Tensor:\n    \"\"\"Extract duration from an attention probability matrix\n    Args:\n        attn_lprob (Tensor): Batched log probability of attention\n            matrix (B, T_feat, T_text).\n        text_lengths (Tensor): Text length tensor (B,).\n        feat_lengths (Tensor): Feature length tensor (B,).\n    Returns:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.aligner.model",
        "documentation": {}
    },
    {
        "label": "ShawRelativePositionSDPAConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "peekOfCode": "class ShawRelativePositionSDPAConfig:\n    \"\"\"Holds the configuration of the :class:ShawRelativePositionSDPA module.\"\"\"\n    max_left_rel_pos: int\n    \"\"\"The left clipping value for relative positions.\"\"\"\n    max_right_rel_pos: Optional[int]\n    \"\"\"The right clipping value for relative positions.\"\"\"\n    use_rel_pos_values: bool = False\n    \"\"\"If True, also uses relative position values to compute relative attention.\"\"\"\n@dataclass\nclass ConformerShawEncoderConfig(Wav2Vec2EncoderConfig):",
        "detail": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "documentation": {}
    },
    {
        "label": "ConformerShawEncoderConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "peekOfCode": "class ConformerShawEncoderConfig(Wav2Vec2EncoderConfig):\n    \"\"\"Holds the configuration of a conformer shaw encoder.\"\"\"\n    shaw_rel_pos_sdpa_config: Optional[ShawRelativePositionSDPAConfig]\n    \"\"\"The parameters for ShawRelativePositionSDPA.\"\"\"\nconformer_shaw_archs = ArchitectureRegistry[ConformerShawEncoderConfig](\n    \"conformer_shaw\"\n)\nconformer_shaw_arch = conformer_shaw_archs.decorator\n@conformer_shaw_arch(\"600m\")\ndef _conformer_shaw_600m_encoder() -> ConformerShawEncoderConfig:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "documentation": {}
    },
    {
        "label": "ConformerShawEncoderBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "peekOfCode": "class ConformerShawEncoderBuilder(Wav2Vec2EncoderBuilder):\n    \"\"\"\n    Builds modules of a `ConformerShawEncoderBuilder`.\n    This is a Conformer architecture with these differences:\n    - ShawRelativePositionSDPA as the SDPA.\n    - ConformerConvolution with causal depthwise convolution\n    and norm_type \"layer_norm\".\n    \"\"\"\n    config: ConformerShawEncoderConfig\n    def __init__(",
        "detail": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "documentation": {}
    },
    {
        "label": "create_conformer_shaw_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "peekOfCode": "def create_conformer_shaw_model(\n    config: Wav2Vec2Config,\n    *,\n    device: Optional[Device] = None,\n    dtype: Optional[DataType] = None,\n) -> Wav2Vec2Model:\n    \"\"\"Create a conformer shaw model.\n    :param config:\n        The configuration.\n    :param device:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "documentation": {}
    },
    {
        "label": "conformer_shaw_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "peekOfCode": "conformer_shaw_archs = ArchitectureRegistry[ConformerShawEncoderConfig](\n    \"conformer_shaw\"\n)\nconformer_shaw_arch = conformer_shaw_archs.decorator\n@conformer_shaw_arch(\"600m\")\ndef _conformer_shaw_600m_encoder() -> ConformerShawEncoderConfig:\n    w2vbert_config = w2vbert_archs.get_config(\"600m\")\n    w2v2_encoder_config = w2vbert_config.w2v2_config.encoder_config\n    sdpa_config = ShawRelativePositionSDPAConfig(\n        max_left_rel_pos=64,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "documentation": {}
    },
    {
        "label": "conformer_shaw_arch",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "peekOfCode": "conformer_shaw_arch = conformer_shaw_archs.decorator\n@conformer_shaw_arch(\"600m\")\ndef _conformer_shaw_600m_encoder() -> ConformerShawEncoderConfig:\n    w2vbert_config = w2vbert_archs.get_config(\"600m\")\n    w2v2_encoder_config = w2vbert_config.w2v2_config.encoder_config\n    sdpa_config = ShawRelativePositionSDPAConfig(\n        max_left_rel_pos=64,\n        max_right_rel_pos=8,\n        use_rel_pos_values=False,\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.builder",
        "documentation": {}
    },
    {
        "label": "convert_conformer_shaw_checkpoint",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.loader",
        "peekOfCode": "def convert_conformer_shaw_checkpoint(\n    checkpoint: Mapping[str, Any], config: Wav2Vec2Config\n) -> Mapping[str, Any]:\n    \"\"\"Convert a fairseq conformer shaw checkpoint to fairseq2.\"\"\"\n    state_dict = checkpoint[\"model\"]\n    # Check if we have a fairseq2 checkpoint.\n    if \"final_target_proj.weight\" in state_dict:\n        return checkpoint\n    for key in (\n        \"mlm_proj.weight\",",
        "detail": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.loader",
        "documentation": {}
    },
    {
        "label": "load_conformer_shaw_model",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.loader",
        "peekOfCode": "load_conformer_shaw_model = ModelLoader[Wav2Vec2Model, Wav2Vec2Config](\n    asset_store,\n    download_manager,\n    load_wav2vec2_config,\n    create_conformer_shaw_model,\n    convert_conformer_shaw_checkpoint,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.conformer_shaw.loader",
        "documentation": {}
    },
    {
        "label": "PretsselEncoderFrontendConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "peekOfCode": "class PretsselEncoderFrontendConfig:\n    prosody_encoder_config: EcapaTDNNConfig\n    dropout: float\n    lang_embed_dim: Optional[int] = None\n@dataclass\nclass FFTLayerConfig:\n    attention_heads: int\n    hidden_dim: int\n    kernel_size: int\n    dropout: float",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "FFTLayerConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "peekOfCode": "class FFTLayerConfig:\n    attention_heads: int\n    hidden_dim: int\n    kernel_size: int\n    dropout: float\n    conv1d_dropout: float\n    film_cond_dim: int\n    use_film: bool = False\n@dataclass\nclass PretsselDecoderFrontendConfig:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "PretsselDecoderFrontendConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "peekOfCode": "class PretsselDecoderFrontendConfig:\n    upsampling_type: Literal[\"gaussian\", \"hard\"]\n    variance_predictor_config: VariancePredictorConfig\n    add_variance_parallel: bool\n@dataclass\nclass VocoderConfig:\n    \"\"\"Holds the configuration of a Vocoder model.\"\"\"\n    encoder_frontend_config: PretsselEncoderFrontendConfig\n    fft_layer_config: FFTLayerConfig\n    decoder_frontend_config: PretsselDecoderFrontendConfig",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "VocoderConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "peekOfCode": "class VocoderConfig:\n    \"\"\"Holds the configuration of a Vocoder model.\"\"\"\n    encoder_frontend_config: PretsselEncoderFrontendConfig\n    fft_layer_config: FFTLayerConfig\n    decoder_frontend_config: PretsselDecoderFrontendConfig\n    pn_conv_dim: int\n    pn_layers: int\n    pn_conv_kernel_size: int\n    pn_dropout: float\n    vocab_info: VocabularyInfo",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "PretsselVocoderBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "peekOfCode": "class PretsselVocoderBuilder:\n    config: VocoderConfig\n    prosody_encoder_builder: EcapaTDNNBuilder\n    device: Optional[Device] = None\n    dtype: Optional[DataType] = None\n    def __init__(\n        self,\n        config: VocoderConfig,\n        prosody_encoder_builder: EcapaTDNNBuilder,\n        *,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "pretssel_config",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "peekOfCode": "def pretssel_config() -> (\n    Tuple[PretsselEncoderFrontendConfig, FFTLayerConfig, PretsselDecoderFrontendConfig]\n):\n    prosody_encoder_config = ecapa_tdnn_archs.get_config(\"base\")\n    encoder_frontend_config = PretsselEncoderFrontendConfig(\n        prosody_encoder_config=prosody_encoder_config,\n        dropout=0.2,\n        lang_embed_dim=64,\n    )\n    fft_layer_config = FFTLayerConfig(",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "create_vocoder_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "peekOfCode": "def create_vocoder_model(\n    config: VocoderConfig,\n    device: Optional[Device] = None,\n    dtype: Optional[DataType] = None,\n) -> PretsselVocoder:\n    prosody_encoder_builder = EcapaTDNNBuilder(\n        config.encoder_frontend_config.prosody_encoder_config,\n        device=device,\n        dtype=dtype,\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "vocoder_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "peekOfCode": "vocoder_archs = ArchitectureRegistry[VocoderConfig](\"vocoder_pretssel\")\nvocoder_arch = vocoder_archs.decorator\ndef pretssel_config() -> (\n    Tuple[PretsselEncoderFrontendConfig, FFTLayerConfig, PretsselDecoderFrontendConfig]\n):\n    prosody_encoder_config = ecapa_tdnn_archs.get_config(\"base\")\n    encoder_frontend_config = PretsselEncoderFrontendConfig(\n        prosody_encoder_config=prosody_encoder_config,\n        dropout=0.2,\n        lang_embed_dim=64,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "vocoder_arch",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "peekOfCode": "vocoder_arch = vocoder_archs.decorator\ndef pretssel_config() -> (\n    Tuple[PretsselEncoderFrontendConfig, FFTLayerConfig, PretsselDecoderFrontendConfig]\n):\n    prosody_encoder_config = ecapa_tdnn_archs.get_config(\"base\")\n    encoder_frontend_config = PretsselEncoderFrontendConfig(\n        prosody_encoder_config=prosody_encoder_config,\n        dropout=0.2,\n        lang_embed_dim=64,\n    )",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.builder",
        "documentation": {}
    },
    {
        "label": "ECAPA_TDNN",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "peekOfCode": "class ECAPA_TDNN(Module):\n    \"\"\"\n    Represents the ECAPA-TDNN model described in paper:\n    :cite:t`https://doi.org/10.48550/arxiv.2005.07143`.\n    Arguments\n    ---------\n    :param channels:\n        Output channels for TDNN/SERes2Net layer.\n    :param kernel_sizes:\n        List of kernel sizes for each layer.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "TDNNBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "peekOfCode": "class TDNNBlock(Module):\n    \"\"\"An implementation of TDNN.\n    Arguments\n    ----------\n    :param in_channels : int\n        Number of input channels.\n    :param out_channels : int\n        The number of output channels.\n    :param kernel_size : int\n        The kernel size of the TDNN blocks.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "Res2NetBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "peekOfCode": "class Res2NetBlock(Module):\n    \"\"\"An implementation of Res2NetBlock w/ dilation.\n    Arguments\n    ---------\n    :param in_channels : int\n        The number of channels expected in the input.\n    :param out_channels : int\n        The number of output channels.\n    :param scale : int\n        The scale of the Res2Net block.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "SEBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "peekOfCode": "class SEBlock(Module):\n    \"\"\"An implementation of squeeze-and-excitation block.\n    Arguments\n    ---------\n    in_channels : int\n        The number of input channels.\n    se_channels : int\n        The number of output channels after squeeze.\n    out_channels : int\n        The number of output channels.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "AttentiveStatisticsPooling",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "peekOfCode": "class AttentiveStatisticsPooling(Module):\n    \"\"\"This class implements an attentive statistic pooling layer for each channel.\n    It returns the concatenated mean and std of the input tensor.\n    Arguments\n    ---------\n    channels: int\n        The number of input channels.\n    attention_channels: int\n        The number of attention channels.\n    \"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "SERes2NetBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "peekOfCode": "class SERes2NetBlock(Module):\n    \"\"\"An implementation of building block in ECAPA-TDNN, i.e.,\n    TDNN-Res2Net-TDNN-SEBlock.\n    Arguments\n    ----------\n    out_channels: int\n        The number of output channels.\n    res2net_scale: int\n        The scale of the Res2Net block.\n    kernel_size: int",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "EcapaTDNNConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "peekOfCode": "class EcapaTDNNConfig:\n    channels: List[int]\n    kernel_sizes: List[int]\n    dilations: List[int]\n    attention_channels: int\n    res2net_scale: int\n    se_channels: int\n    global_context: bool\n    groups: List[int]\n    embed_dim: int",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "EcapaTDNNBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "peekOfCode": "class EcapaTDNNBuilder:\n    \"\"\"\n    Builder module for ECAPA_TDNN model\n    \"\"\"\n    config: EcapaTDNNConfig\n    device: Optional[Device]\n    dtype: Optional[DataType]\n    def __init__(\n        self,\n        config: EcapaTDNNConfig,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "create_ecapa_tdnn_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "peekOfCode": "def create_ecapa_tdnn_model(\n    config: EcapaTDNNConfig,\n    device: Optional[Device] = None,\n    dtype: Optional[DataType] = None,\n) -> ECAPA_TDNN:\n    \"\"\"Create a ECAPA_TDNN model.\n    :param config:\n        The configuration to use.\n    :param device:\n        The device on which to initialize modules.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "ecapa_tdnn_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "peekOfCode": "ecapa_tdnn_archs = ArchitectureRegistry[EcapaTDNNConfig](\"ecapa_tdnn\")\necapa_tdnn_arch = ecapa_tdnn_archs.decorator\n@ecapa_tdnn_arch(\"base\")\ndef _base_ecapa_tdnn() -> EcapaTDNNConfig:\n    return EcapaTDNNConfig(\n        channels=[512, 512, 512, 512, 1536],\n        kernel_sizes=[5, 3, 3, 3, 1],\n        dilations=[1, 2, 3, 4, 1],\n        attention_channels=128,\n        res2net_scale=8,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "ecapa_tdnn_arch",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "peekOfCode": "ecapa_tdnn_arch = ecapa_tdnn_archs.decorator\n@ecapa_tdnn_arch(\"base\")\ndef _base_ecapa_tdnn() -> EcapaTDNNConfig:\n    return EcapaTDNNConfig(\n        channels=[512, 512, 512, 512, 1536],\n        kernel_sizes=[5, 3, 3, 3, 1],\n        dilations=[1, 2, 3, 4, 1],\n        attention_channels=128,\n        res2net_scale=8,\n        se_channels=128,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "load_pretssel_vocoder_config",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.loader",
        "peekOfCode": "load_pretssel_vocoder_config = ConfigLoader[VocoderConfig](asset_store, vocoder_archs)\nload_pretssel_vocoder_model = ModelLoader[PretsselVocoder, VocoderConfig](\n    asset_store,\n    download_manager,\n    load_pretssel_vocoder_config,\n    create_vocoder_model,\n    restrict_checkpoints=False,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.loader",
        "documentation": {}
    },
    {
        "label": "load_pretssel_vocoder_model",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.loader",
        "peekOfCode": "load_pretssel_vocoder_model = ModelLoader[PretsselVocoder, VocoderConfig](\n    asset_store,\n    download_manager,\n    load_pretssel_vocoder_config,\n    create_vocoder_model,\n    restrict_checkpoints=False,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.loader",
        "documentation": {}
    },
    {
        "label": "NormConv1d",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "class NormConv1d(Module):\n    \"\"\"Wrapper around Conv1d and normalization applied to this conv\n    to provide a uniform interface across normalization approaches.\n    \"\"\"\n    def __init__(\n        self,\n        in_channels: int,\n        out_channels: int,\n        kernel_size: int,\n        stride: int = 1,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "NormConvTranspose1d",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "class NormConvTranspose1d(Module):\n    \"\"\"Wrapper around ConvTranspose1d and normalization applied to this conv\n    to provide a uniform interface across normalization approaches.\n    \"\"\"\n    def __init__(  # type: ignore[no-untyped-def]\n        self,\n        in_channels: int,\n        out_channels: int,\n        kernel_size: int,\n        stride: int = 1,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "StreamableConv1d",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "class StreamableConv1d(Module):\n    \"\"\"Conv1d with some builtin handling of asymmetric or causal padding\n    and normalization.\n    \"\"\"\n    def __init__(\n        self,\n        in_channels: int,\n        out_channels: int,\n        kernel_size: int,\n        stride: int = 1,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "StreamableConvTranspose1d",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "class StreamableConvTranspose1d(Module):\n    \"\"\"ConvTranspose1d with some builtin handling of asymmetric or causal padding\n    and normalization.\n    \"\"\"\n    def __init__(\n        self,\n        in_channels: int,\n        out_channels: int,\n        kernel_size: int,\n        stride: int = 1,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "StreamableLSTM",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "class StreamableLSTM(Module):\n    \"\"\"LSTM without worrying about the hidden state, nor the layout of the data.\n    Expects input as convolutional layout.\n    \"\"\"\n    def __init__(\n        self,\n        dimension: int,\n        num_layers: int = 2,\n        skip: bool = True,\n        device: Optional[Device] = None,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "StreamableResnetBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "class StreamableResnetBlock(Module):\n    \"\"\"custom Residual block model with streamable convnet.\n    Args:\n        dim (int): Dimension of the input/output.\n        kernel_sizes (list): List of kernel sizes for the convolutions.\n        dilations (list): List of dilations for the convolutions.\n        activation_params (dict): Parameters to provide to the (ELU) activation function.\n        norm (str): Normalization method.\n        norm_params (dict): Parameters to provide to the underlying normalization used along with the convolution.\n        causal (bool): Whether to use fully causal convolution.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "apply_parametrization_norm",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "def apply_parametrization_norm(\n    module: Module,\n    norm: Literal[\"none\", \"weight_norm\", \"spectral_norm\", \"time_group_norm\"] = \"none\",\n) -> Module:\n    if norm == \"weight_norm\":\n        return weight_norm(module)\n    elif norm == \"spectral_norm\":\n        return spectral_norm(module)\n    else:\n        # We already check was in CONV_NORMALIZATION, so any other choice",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "get_norm_module",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "def get_norm_module(  # type: ignore[no-untyped-def]\n    module: Module,\n    causal: bool = False,\n    norm: Literal[\"none\", \"weight_norm\", \"spectral_norm\", \"time_group_norm\"] = \"none\",\n    **norm_kwargs,\n) -> Module:\n    \"\"\"Return the proper normalization module. If causal is True, this will ensure the returned\n    module is causal, or return an error if the normalization doesn't support causal evaluation.\n    \"\"\"\n    assert norm in CONV_NORMALIZATIONS",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "get_extra_padding_for_conv1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "def get_extra_padding_for_conv1d(\n    x: torch.Tensor, kernel_size: int, stride: int, padding_total: int = 0\n) -> int:\n    \"\"\"See `pad_for_conv1d`.\"\"\"\n    length = x.shape[-1]\n    n_frames = (length - kernel_size + padding_total) / stride + 1\n    ideal_length = (math.ceil(n_frames) - 1) * stride + (kernel_size - padding_total)\n    return ideal_length - length\ndef pad_for_conv1d(\n    x: torch.Tensor, kernel_size: int, stride: int, padding_total: int = 0",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "pad_for_conv1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "def pad_for_conv1d(\n    x: torch.Tensor, kernel_size: int, stride: int, padding_total: int = 0\n) -> torch.Tensor:\n    \"\"\"Pad for a convolution to make sure that the last window is full.\n    Extra padding is added at the end. This is required to ensure that we can rebuild\n    an output of the same length, as otherwise, even with padding, some time steps\n    might get removed.\n    For instance, with total padding = 4, kernel size = 4, stride = 2:\n        0 0 1 2 3 4 5 0 0   # (0s are padding)\n        1   2   3           # (output frames of a convolution, last 0 is never used)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "pad1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "def pad1d(\n    x: torch.Tensor,\n    paddings: Tuple[int, int],\n    mode: str = \"constant\",\n    value: float = 0.0,\n) -> torch.Tensor:\n    \"\"\"Tiny wrapper around F.pad, just to allow for reflect padding on small input.\n    If this is the case, we insert extra 0 padding to the right before the reflection happen.\n    \"\"\"\n    length = x.shape[-1]",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "unpad1d",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "def unpad1d(x: torch.Tensor, paddings: Tuple[int, int]) -> torch.Tensor:\n    \"\"\"Remove padding from x, handling properly zero padding. Only for 1d!\"\"\"\n    padding_left, padding_right = paddings\n    assert padding_left >= 0 and padding_right >= 0, (padding_left, padding_right)\n    assert (padding_left + padding_right) <= x.shape[-1]\n    end = x.shape[-1] - padding_right\n    return x[..., padding_left:end]\nclass NormConv1d(Module):\n    \"\"\"Wrapper around Conv1d and normalization applied to this conv\n    to provide a uniform interface across normalization approaches.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "CONV_NORMALIZATIONS",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "peekOfCode": "CONV_NORMALIZATIONS = frozenset(\n    [\"none\", \"weight_norm\", \"spectral_norm\", \"time_group_norm\"]\n)\ndef apply_parametrization_norm(\n    module: Module,\n    norm: Literal[\"none\", \"weight_norm\", \"spectral_norm\", \"time_group_norm\"] = \"none\",\n) -> Module:\n    if norm == \"weight_norm\":\n        return weight_norm(module)\n    elif norm == \"spectral_norm\":",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.streamable",
        "documentation": {}
    },
    {
        "label": "PretsselEncoderFrontend",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.vocoder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.vocoder",
        "peekOfCode": "class PretsselEncoderFrontend(Module):\n    \"\"\"\n    Represent Encoder frontend, including the prosody encoder and language embedding\n    \"\"\"\n    prosody_encoder: ECAPA_TDNN\n    embed_tokens: Embedding\n    embed_positions: PositionEncoder\n    pos_emb_alpha: Parameter\n    embed_lang: Embedding\n    dropout: Dropout",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.vocoder",
        "documentation": {}
    },
    {
        "label": "PretsselDecoderFrontend",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.vocoder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.vocoder",
        "peekOfCode": "class PretsselDecoderFrontend(Module):\n    \"\"\"Represent Decoder frontend, including VarianceAdaptor & Positional embedding\"\"\"\n    variance_adaptor: VarianceAdaptor\n    embed_positions: PositionEncoder\n    pos_emb_alpha: Parameter\n    def __init__(\n        self,\n        variance_adaptor: VarianceAdaptor,\n        embed_positions: PositionEncoder,\n        device: Optional[Device] = None,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.vocoder",
        "documentation": {}
    },
    {
        "label": "PretsselVocoder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.generator.vocoder",
        "description": "lib.seamless_communication.src.seamless_communication.models.generator.vocoder",
        "peekOfCode": "class PretsselVocoder(Module):\n    \"\"\"The expressivity-preserving vocoder\"\"\"\n    encoder_frontend: PretsselEncoderFrontend\n    encoder: FeedForwardTransformer\n    decoder_frontend: PretsselDecoderFrontend\n    decoder: FeedForwardTransformer\n    final_proj: Projection\n    def __init__(  # type: ignore[no-untyped-def]\n        self,\n        encoder_frontend: PretsselEncoderFrontend,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.generator.vocoder",
        "documentation": {}
    },
    {
        "label": "MonotonicDecoderConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "peekOfCode": "class MonotonicDecoderConfig:\n    \"\"\"Holds the configuration of an Monotonic Decoder model.\"\"\"\n    model_dim: int\n    \"\"\"The dimensionality of the model.\"\"\"\n    max_seq_len: int\n    \"\"\"The expected maximum sequence length.\"\"\"\n    vocab_info: VocabularyInfo\n    \"\"\"The vocabulary information.\"\"\"\n    num_decoder_layers: int\n    \"\"\"The number of Transformer decoder layers.\"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "documentation": {}
    },
    {
        "label": "MonotonicDecoderBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "peekOfCode": "class MonotonicDecoderBuilder:\n    \"\"\"Builds modules of a Monotonic Decoder.\n    To tweak the architecture, you can derive from this class and override the\n    corresponding methods.\n    \"\"\"\n    config: MonotonicDecoderConfig\n    device: Optional[Device]\n    dtype: Optional[DataType]\n    def __init__(\n        self,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "documentation": {}
    },
    {
        "label": "create_monotonic_decoder_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "peekOfCode": "def create_monotonic_decoder_model(\n    config: MonotonicDecoderConfig,\n    *,\n    device: Optional[Device] = None,\n    dtype: Optional[DataType] = None,\n) -> MonotonicDecoderModel:\n    \"\"\"Create an Monotonic Decoder model.\n    :param config:\n        The configuration to use.\n    :param device:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "documentation": {}
    },
    {
        "label": "monotonic_decoder_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "peekOfCode": "monotonic_decoder_archs = ArchitectureRegistry[MonotonicDecoderConfig](\n    \"monotonic_decoder\"\n)\nmonotonic_decoder_arch = monotonic_decoder_archs.decorator\n@monotonic_decoder_arch(\"dense_1b\")\ndef _dense_1b() -> MonotonicDecoderConfig:\n    return MonotonicDecoderConfig(\n        model_dim=1024,\n        max_seq_len=4096,\n        vocab_info=VocabularyInfo(",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "documentation": {}
    },
    {
        "label": "monotonic_decoder_arch",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "peekOfCode": "monotonic_decoder_arch = monotonic_decoder_archs.decorator\n@monotonic_decoder_arch(\"dense_1b\")\ndef _dense_1b() -> MonotonicDecoderConfig:\n    return MonotonicDecoderConfig(\n        model_dim=1024,\n        max_seq_len=4096,\n        vocab_info=VocabularyInfo(\n            size=256102, unk_idx=1, bos_idx=2, eos_idx=3, pad_idx=0\n        ),\n        num_decoder_layers=24,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.builder",
        "documentation": {}
    },
    {
        "label": "convert_monotonic_checkpoint",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.loader",
        "peekOfCode": "def convert_monotonic_checkpoint(\n    checkpoint: Mapping[str, Any], config: MonotonicDecoderConfig\n) -> Mapping[str, Any]:\n    state_dict = checkpoint[\"model\"]\n    # Check if we have a fairseq2 checkpoint.\n    if \"text_decoder.layers.0.self_attn.k_proj.weight\" in state_dict:\n        return checkpoint\n    key_map = {\n        # fmt: off\n        r\"^decoder\\.embed_tokens\\.\":                                            r\"text_decoder_frontend.embed.\",",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.loader",
        "documentation": {}
    },
    {
        "label": "load_monotonic_decoder_config",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.loader",
        "peekOfCode": "load_monotonic_decoder_config = ConfigLoader[MonotonicDecoderConfig](\n    asset_store, monotonic_decoder_archs\n)\nload_monotonic_decoder_model = ModelLoader[\n    MonotonicDecoderModel, MonotonicDecoderConfig\n](\n    asset_store,\n    download_manager,\n    load_monotonic_decoder_config,\n    create_monotonic_decoder_model,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.loader",
        "documentation": {}
    },
    {
        "label": "load_monotonic_decoder_model",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.loader",
        "peekOfCode": "load_monotonic_decoder_model = ModelLoader[\n    MonotonicDecoderModel, MonotonicDecoderConfig\n](\n    asset_store,\n    download_manager,\n    load_monotonic_decoder_config,\n    create_monotonic_decoder_model,\n    convert_monotonic_checkpoint,\n    restrict_checkpoints=False,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.loader",
        "documentation": {}
    },
    {
        "label": "MonotonicDecoderModel",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.model",
        "peekOfCode": "class MonotonicDecoderModel(Module):\n    text_decoder_frontend: TransformerFrontend\n    text_decoder: MonotonicTransformerDecoder\n    final_proj: Projection\n    def __init__(\n        self,\n        text_decoder_frontend: TransformerFrontend,\n        text_decoder: MonotonicTransformerDecoder,\n        final_proj: Projection,\n    ) -> None:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.model",
        "documentation": {}
    },
    {
        "label": "MonotonicTransformerDecoder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.monotonic_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.monotonic_decoder",
        "peekOfCode": "class MonotonicTransformerDecoder(Module):\n    \"\"\"Represents a Monotonic Transformer decoder.\"\"\"\n    model_dim: int\n    self_attn_mask_factory: AttentionMaskFactory\n    layers: ModuleList\n    layer_norm: LayerNorm\n    def __init__(\n        self,\n        layers: Iterable[MonotonicTransformerDecoderLayer],\n        *,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.monotonic_decoder",
        "documentation": {}
    },
    {
        "label": "MonotonicTransformerDecoderLayer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.monotonic_decoder_layer",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.monotonic_decoder_layer",
        "peekOfCode": "class MonotonicTransformerDecoderLayer(Module):\n    \"\"\"Represents a Monotonic Transformer decoder layer.\"\"\"\n    self_attn: MultiheadAttention\n    self_attn_dropout: Optional[Dropout]\n    self_attn_layer_norm: LayerNorm\n    encoder_decoder_attn: MultiheadAttention\n    encoder_decoder_attn_dropout: Optional[Dropout]\n    encoder_decoder_attn_layer_norm: LayerNorm\n    p_choose_layer: PChooseLayer\n    ffn: FeedForwardNetwork",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.monotonic_decoder_layer",
        "documentation": {}
    },
    {
        "label": "EnergyProjection",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.p_choose",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.p_choose",
        "peekOfCode": "class EnergyProjection(Module):\n    def __init__(\n        self,\n        model_dim: int,\n        num_layers: int,\n        bias: bool = True,\n        device: Optional[Device] = None,\n        dtype: Optional[DataType] = None,\n    ) -> None:\n        super().__init__()",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.p_choose",
        "documentation": {}
    },
    {
        "label": "PChooseLayer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.p_choose",
        "description": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.p_choose",
        "peekOfCode": "class PChooseLayer(Module):\n    \"\"\"Represents a PChoose layer.\"\"\"\n    model_dim: int\n    num_heads: int\n    energy_bias: Parameter\n    monotonic_temperature: float\n    q_energy_proj: EnergyProjection\n    k_energy_proj: EnergyProjection\n    keys_pooling: AvgPool1d\n    def __init__(",
        "detail": "lib.seamless_communication.src.seamless_communication.models.monotonic_decoder.p_choose",
        "documentation": {}
    },
    {
        "label": "ECAPA_TDNN",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "peekOfCode": "class ECAPA_TDNN(Module):\n    \"\"\"\n    Represents the ECAPA-TDNN model described in paper:\n    :cite:t`https://doi.org/10.48550/arxiv.2005.07143`.\n    Arguments\n    ---------\n    :param channels:\n        Output channels for TDNN/SERes2Net layer.\n    :param kernel_sizes:\n        List of kernel sizes for each layer.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "TDNNBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "peekOfCode": "class TDNNBlock(Module):\n    \"\"\"An implementation of TDNN.\n    Arguments\n    ----------\n    :param in_channels : int\n        Number of input channels.\n    :param out_channels : int\n        The number of output channels.\n    :param kernel_size : int\n        The kernel size of the TDNN blocks.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "Res2NetBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "peekOfCode": "class Res2NetBlock(Module):\n    \"\"\"An implementation of Res2NetBlock w/ dilation.\n    Arguments\n    ---------\n    :param in_channels : int\n        The number of channels expected in the input.\n    :param out_channels : int\n        The number of output channels.\n    :param scale : int\n        The scale of the Res2Net block.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "SEBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "peekOfCode": "class SEBlock(Module):\n    \"\"\"An implementation of squeeze-and-excitation block.\n    Arguments\n    ---------\n    in_channels : int\n        The number of input channels.\n    se_channels : int\n        The number of output channels after squeeze.\n    out_channels : int\n        The number of output channels.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "AttentiveStatisticsPooling",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "peekOfCode": "class AttentiveStatisticsPooling(Module):\n    \"\"\"This class implements an attentive statistic pooling layer for each channel.\n    It returns the concatenated mean and std of the input tensor.\n    Arguments\n    ---------\n    channels: int\n        The number of input channels.\n    attention_channels: int\n        The number of attention channels.\n    \"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "SERes2NetBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "peekOfCode": "class SERes2NetBlock(Module):\n    \"\"\"An implementation of building block in ECAPA-TDNN, i.e.,\n    TDNN-Res2Net-TDNN-SEBlock.\n    Arguments\n    ----------\n    out_channels: int\n        The number of output channels.\n    res2net_scale: int\n        The scale of the Res2Net block.\n    kernel_size: int",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn",
        "documentation": {}
    },
    {
        "label": "EcapaTDNNConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "peekOfCode": "class EcapaTDNNConfig:\n    channels: List[int]\n    kernel_sizes: List[int]\n    dilations: List[int]\n    attention_channels: int\n    res2net_scale: int\n    se_channels: int\n    global_context: bool\n    groups: List[int]\n    embed_dim: int",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "EcapaTDNNBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "peekOfCode": "class EcapaTDNNBuilder:\n    \"\"\"\n    Builder module for ECAPA_TDNN model\n    \"\"\"\n    config: EcapaTDNNConfig\n    device: Optional[Device]\n    dtype: Optional[DataType]\n    def __init__(\n        self,\n        config: EcapaTDNNConfig,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "create_ecapa_tdnn_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "peekOfCode": "def create_ecapa_tdnn_model(\n    config: EcapaTDNNConfig,\n    device: Optional[Device] = None,\n    dtype: Optional[DataType] = None,\n) -> ECAPA_TDNN:\n    \"\"\"Create a ECAPA_TDNN model.\n    :param config:\n        The configuration to use.\n    :param device:\n        The device on which to initialize modules.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "ecapa_tdnn_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "peekOfCode": "ecapa_tdnn_archs = ArchitectureRegistry[EcapaTDNNConfig](\"ecapa_tdnn\")\necapa_tdnn_arch = ecapa_tdnn_archs.decorator\n@ecapa_tdnn_arch(\"base\")\ndef _base_ecapa_tdnn() -> EcapaTDNNConfig:\n    return EcapaTDNNConfig(\n        channels=[512, 512, 512, 512, 1536],\n        kernel_sizes=[5, 3, 3, 3, 1],\n        dilations=[1, 2, 3, 4, 1],\n        attention_channels=128,\n        res2net_scale=8,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "ecapa_tdnn_arch",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "peekOfCode": "ecapa_tdnn_arch = ecapa_tdnn_archs.decorator\n@ecapa_tdnn_arch(\"base\")\ndef _base_ecapa_tdnn() -> EcapaTDNNConfig:\n    return EcapaTDNNConfig(\n        channels=[512, 512, 512, 512, 1536],\n        kernel_sizes=[5, 3, 3, 3, 1],\n        dilations=[1, 2, 3, 4, 1],\n        attention_channels=128,\n        res2net_scale=8,\n        se_channels=128,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.pretssel.ecapa_tdnn_builder",
        "documentation": {}
    },
    {
        "label": "KmeansModel",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.kmeans",
        "description": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.kmeans",
        "peekOfCode": "class KmeansModel(nn.Module):\n    def __init__(self, kmeans_uri: str, device: Device, dtype: DataType):\n        super().__init__()\n        km_path = download_manager.download_checkpoint(kmeans_uri, kmeans_uri)\n        km_model = np.load(km_path)\n        centroids_numpy = km_model.transpose()\n        centroids = torch.from_numpy(centroids_numpy)\n        self.centroids = centroids.to(device=device, dtype=dtype)\n        self.centroid_norm = (self.centroids**2).sum(0, keepdims=True)\n    def forward(self, x: Tensor) -> Tensor:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.kmeans",
        "documentation": {}
    },
    {
        "label": "UnitExtractor",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.unit_extractor",
        "description": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.unit_extractor",
        "peekOfCode": "class UnitExtractor(nn.Module):\n    \"\"\"Unit Extractor which converts raw audio into units.\"\"\"\n    def __init__(\n        self,\n        model_name_or_card: Union[str, AssetCard],\n        kmeans_uri: str,\n        device: Device,\n        dtype: DataType = torch.float32,\n    ):\n        super().__init__()",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.unit_extractor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.unit_extractor",
        "description": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.unit_extractor",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass UnitExtractor(nn.Module):\n    \"\"\"Unit Extractor which converts raw audio into units.\"\"\"\n    def __init__(\n        self,\n        model_name_or_card: Union[str, AssetCard],\n        kmeans_uri: str,\n        device: Device,\n        dtype: DataType = torch.float32,\n    ):",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.unit_extractor",
        "documentation": {}
    },
    {
        "label": "Wav2Vec2LayerOutputModel",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.wav2vec2_layer_output",
        "description": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.wav2vec2_layer_output",
        "peekOfCode": "class Wav2Vec2LayerOutputModel(nn.Module):\n    encoder_frontend: Wav2Vec2Frontend\n    encoder: TransformerEncoder\n    def __init__(self, w2v2: Wav2Vec2Model):\n        super().__init__()\n        self.encoder_frontend = w2v2.encoder_frontend\n        self.encoder = w2v2.encoder\n    @torch.inference_mode()\n    def forward(self, batch: SequenceBatch, out_layer_idx: int) -> Tensor:\n        \"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unit_extractor.wav2vec2_layer_output",
        "documentation": {}
    },
    {
        "label": "UnitYEncoderAdaptor",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.adaptor_block",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.adaptor_block",
        "peekOfCode": "class UnitYEncoderAdaptor(TransformerEncoder):\n    \"\"\"Represents a Transformer encoder that wraps a speech encoder and adapts\n    it to be used with the UnitY architecture.\"\"\"\n    inner: TransformerEncoder\n    inner_layer_norm: Optional[LayerNorm]\n    proj1: Linear\n    activation: ReLU\n    proj2: Linear\n    adaptor_layers: ModuleList\n    layer_norm: LayerNorm",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.adaptor_block",
        "documentation": {}
    },
    {
        "label": "UnitYTransformerAdaptorLayer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.adaptor_block",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.adaptor_block",
        "peekOfCode": "class UnitYTransformerAdaptorLayer(TransformerEncoderLayer):\n    \"\"\"Represents a variant of M-Adaptor layer described in\n    :cite:t`https://doi.org/10.48550/arxiv.2207.00952`.\n    The main difference from the paper is that pooling is applied to multi-head\n    attention input rather than projected Q, K, V.\n    \"\"\"\n    kernel_size: int\n    stride: int\n    residual_layer_norm: LayerNorm\n    residual_conv: Conv1d",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.adaptor_block",
        "documentation": {}
    },
    {
        "label": "UnitYConformerAdaptorLayer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.adaptor_block",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.adaptor_block",
        "peekOfCode": "class UnitYConformerAdaptorLayer(TransformerEncoderLayer):\n    \"\"\"Represents a variant of M-Adaptor layer described in\n    :cite:t`https://doi.org/10.48550/arxiv.2207.00952`.\n    The main difference from the paper is that this variant uses a Conformer\n    block which empirically showed better performance when used with Conformer-\n    based speech encoder architectures such as w2v-BERT.\n    \"\"\"\n    kernel_size: int\n    stride: int\n    layer_norm: Optional[LayerNorm]",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.adaptor_block",
        "documentation": {}
    },
    {
        "label": "UnitYConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "peekOfCode": "class UnitYConfig:\n    \"\"\"Holds the configuration of a UnitY model as described in\n    :cite:t`https://doi.org/10.48550/arxiv.2212.08055`\"\"\"\n    model_dim: int\n    \"\"\"The dimensionality of the model.\"\"\"\n    w2v2_encoder_config: Wav2Vec2EncoderConfig\n    \"\"\"The configuration of the underlying wav2vec 2.0 encoder.\"\"\"\n    mt_model_config: NllbConfig\n    \"\"\"The configuration of the underlying MT text encoder-decoder.\"\"\"\n    t2u_config: Optional[UnitYT2UConfig]",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "documentation": {}
    },
    {
        "label": "UnitYBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "peekOfCode": "class UnitYBuilder:\n    \"\"\"Builds modules of a UnitY model.\n    To tweak the architecture, you can derive from this class and override the\n    corresponding methods.\n    \"\"\"\n    config: UnitYConfig\n    w2v2_encoder_builder: Wav2Vec2EncoderBuilder\n    mt_model_builder: NllbBuilder\n    t2u_builder: Union[UnitYT2UBuilder, UnitYNART2UBuilder, None]\n    prosody_encoder_builder: Optional[EcapaTDNNBuilder]",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "documentation": {}
    },
    {
        "label": "NllbWithGELUBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "peekOfCode": "class NllbWithGELUBuilder(NllbBuilder):\n    @override\n    def build_ffn(self) -> FeedForwardNetwork:\n        return StandardFeedForwardNetwork(\n            self.config.model_dim,\n            self.config.ffn_inner_dim,\n            bias=True,\n            inner_activation=GELU(),\n            norm_order=TransformerNormOrder.PRE,\n            device=self.device,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "documentation": {}
    },
    {
        "label": "create_unity_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "peekOfCode": "def create_unity_model(\n    config: UnitYConfig,\n    device: Optional[Device] = None,\n    dtype: Optional[DataType] = None,\n) -> UnitYModel:\n    \"\"\"Create a UnitY model.\n    :param config:\n        The configuration to use.\n    :param device:\n        The device on which to initialize modules.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "documentation": {}
    },
    {
        "label": "unity_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "peekOfCode": "unity_archs = ArchitectureRegistry[UnitYConfig](\"unity\")\nunity_arch = unity_archs.decorator\n@unity_arch(\"base\")\ndef _base() -> UnitYConfig:\n    w2vbert_config = w2vbert_archs.get_config(\"600m\")\n    mt_model_config: NllbConfig = nllb_archs.get_config(\"dense_1b\")\n    mt_model_config.vocab_info.size = 256102  # NLLB-100\n    t2u_config = unity_t2u_archs.get_config(\"base\")\n    return UnitYConfig(\n        model_dim=1024,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "documentation": {}
    },
    {
        "label": "unity_arch",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "peekOfCode": "unity_arch = unity_archs.decorator\n@unity_arch(\"base\")\ndef _base() -> UnitYConfig:\n    w2vbert_config = w2vbert_archs.get_config(\"600m\")\n    mt_model_config: NllbConfig = nllb_archs.get_config(\"dense_1b\")\n    mt_model_config.vocab_info.size = 256102  # NLLB-100\n    t2u_config = unity_t2u_archs.get_config(\"base\")\n    return UnitYConfig(\n        model_dim=1024,\n        w2v2_encoder_config=w2vbert_config.w2v2_config.encoder_config,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.builder",
        "documentation": {}
    },
    {
        "label": "CharTokenizer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.char_tokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.char_tokenizer",
        "peekOfCode": "class CharTokenizer(TextTokenizer):\n    \"\"\"A character-level tokenizer used during non-autoregressive T2U decoding.\"\"\"\n    model: SentencePieceModel\n    def __init__(self, pathname: PathLike) -> None:\n        \"\"\"\n        :param pathname:\n            The pathname of the SentencePiece model file.\n        \"\"\"\n        self.model = SentencePieceModel(pathname)\n        vocab_info = vocab_info_from_sentencepiece(self.model)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.char_tokenizer",
        "documentation": {}
    },
    {
        "label": "UnitYCharTokenizerLoader",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.char_tokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.char_tokenizer",
        "peekOfCode": "class UnitYCharTokenizerLoader:\n    \"\"\"Loads character-level tokenizers of UnitY models.\"\"\"\n    def __init__(\n        self, asset_store: AssetStore, download_manager: AssetDownloadManager\n    ) -> None:\n        \"\"\"\n        :param asset_store:\n            The asset store to retrieve the model information.\n        :param download_manager:\n            The download manager to use.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.char_tokenizer",
        "documentation": {}
    },
    {
        "label": "load_unity_char_tokenizer",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.char_tokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.char_tokenizer",
        "peekOfCode": "load_unity_char_tokenizer = UnitYCharTokenizerLoader(asset_store, download_manager)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.char_tokenizer",
        "documentation": {}
    },
    {
        "label": "FeedForwardTransformer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.fft_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.fft_decoder",
        "peekOfCode": "class FeedForwardTransformer(Module):\n    \"\"\"Represents a Feedforward Transformer decoder.\"\"\"\n    model_dim: int\n    layer_norm: Optional[LayerNorm]\n    norm_order: TransformerNormOrder\n    def __init__(\n        self,\n        layers: Iterable[FeedForwardTransformerLayer],\n        *,\n        norm_order: TransformerNormOrder = TransformerNormOrder.POST,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.fft_decoder",
        "documentation": {}
    },
    {
        "label": "Conv1dBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.fft_decoder_layer",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.fft_decoder_layer",
        "peekOfCode": "class Conv1dBlock(Module):\n    \"\"\"Represents the Conv1d block within the FFT Block as described in\n    :cite:t:`https://arxiv.org/pdf/1905.09263.pdf`.\"\"\"\n    conv1: Conv1d\n    activation: ReLU\n    conv2: Conv1d\n    def __init__(\n        self,\n        model_dim: int,\n        inner_dim: int,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.fft_decoder_layer",
        "documentation": {}
    },
    {
        "label": "FeedForwardTransformerLayer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.fft_decoder_layer",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.fft_decoder_layer",
        "peekOfCode": "class FeedForwardTransformerLayer(Module):\n    \"\"\"Represents the FFT Block as described in\n    :cite:t:`https://arxiv.org/pdf/1905.09263.pdf`.\"\"\"\n    model_dim: int\n    self_attn: MultiheadAttention\n    self_attn_dropout: Optional[Dropout]\n    self_attn_layer_norm: LayerNorm\n    conv1d: Conv1dBlock\n    conv1d_dropout: Optional[Dropout]\n    conv1d_layer_norm: LayerNorm",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.fft_decoder_layer",
        "documentation": {}
    },
    {
        "label": "FiLM",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.film",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.film",
        "peekOfCode": "class FiLM(Module):\n    \"\"\"\n    A Feature-wise Linear Modulation Layer from\n    'FiLM: Visual Reasoning with a General Conditioning Layer'\n    \"\"\"\n    proj: Linear\n    s_gamma: Parameter\n    s_beta: Parameter\n    def __init__(\n        self,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.film",
        "documentation": {}
    },
    {
        "label": "HardUpsampling",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "peekOfCode": "class HardUpsampling(Module):\n    \"\"\"Upsamples sequences in a deterministic way as governed by durations.\"\"\"\n    def forward(self, seqs: Tensor, durations: Tensor) -> Tuple[Tensor, Tensor]:\n        # seqs: (N, S, M), durations: (N, S)\n        if durations.dtype not in (torch.int16, torch.int32, torch.int64):\n            raise TypeError(\"The durations tensor should have an integer dtype.\")\n        upsampled_seq_lens = durations.sum(dim=1)\n        max_len = int(upsampled_seq_lens.max().item())\n        N, _, M = seqs.shape\n        upsampled_seqs = seqs.new_zeros((N, max_len, M))",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "GaussianUpsampling",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "peekOfCode": "class GaussianUpsampling(Module):\n    \"\"\"Gaussian upsampling with fixed temperature as in:\n    https://arxiv.org/abs/2010.04301\n    \"\"\"\n    def __init__(self, delta: float = 0.1):\n        super().__init__()\n        self.delta = delta\n    def forward(\n        self,\n        x: Tensor,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "VariancePredictor",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "peekOfCode": "class VariancePredictor(Module):\n    \"\"\"Represents the duration/pitch/energy predictor as described in\n    :cite:t:`https://arxiv.org/pdf/2006.04558.pdf`\"\"\"\n    conv1: Sequential\n    ln1: LayerNorm\n    dropout_module: Dropout\n    conv2: Sequential\n    ln2: LayerNorm\n    proj: Linear\n    film: Optional[FiLM]",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "VarianceAdaptor",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "peekOfCode": "class VarianceAdaptor(Module):\n    \"\"\"Represent the Variance adaptor as described in\n    :cite:t:`https://arxiv.org/pdf/2006.04558.pdf`\"\"\"\n    duration_predictor: Optional[VariancePredictor]\n    pitch_predictor: Optional[VariancePredictor]\n    vuv_predictor: Optional[VariancePredictor]\n    energy_predictor: Optional[VariancePredictor]\n    length_regulator: Union[HardUpsampling, GaussianUpsampling]\n    def __init__(\n        self,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.length_regulator",
        "documentation": {}
    },
    {
        "label": "UnitYUnitTokenizerLoader",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "peekOfCode": "class UnitYUnitTokenizerLoader:\n    \"\"\"Loads speech unit tokenizers of UnitY models.\"\"\"\n    def __init__(self, asset_store: AssetStore) -> None:\n        \"\"\"\n        :param asset_store:\n            The asset store to retrieve the model information.\n        \"\"\"\n        self.asset_store = asset_store\n    def __call__(self, model_name_or_card: Union[str, AssetCard]) -> UnitTokenizer:\n        \"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "documentation": {}
    },
    {
        "label": "GcmvnStatsLoader",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "peekOfCode": "class GcmvnStatsLoader:\n    \"\"\"Loads GCMVN stats (mean & std) for ProsodyUnitY.\"\"\"\n    def __init__(self, asset_store: AssetStore) -> None:\n        \"\"\"\n        :param asset_store:\n            The asset store to retrieve the model information.\n        \"\"\"\n        self.asset_store = asset_store\n    def __call__(\n        self, model_name_or_card: Union[str, AssetCard]",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "documentation": {}
    },
    {
        "label": "convert_unity_checkpoint",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "peekOfCode": "def convert_unity_checkpoint(\n    checkpoint: Mapping[str, Any], config: UnitYConfig\n) -> Mapping[str, Any]:\n    state_dict = checkpoint[\"model\"]\n    # Check if we have a fairseq2 checkpoint.\n    if \"speech_encoder.inner.layers.0.self_attn_layer_norm.weight\" in state_dict:\n        return checkpoint\n    key_map = _fairseq_key_map(config)\n    checkpoint = convert_fairseq_checkpoint(checkpoint, key_map)\n    state_dict = checkpoint[\"model\"]",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "documentation": {}
    },
    {
        "label": "load_unity_config",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "peekOfCode": "load_unity_config = ConfigLoader[UnitYConfig](asset_store, unity_archs)\nload_unity_model = ModelLoader[UnitYModel, UnitYConfig](\n    asset_store,\n    download_manager,\n    load_unity_config,\n    create_unity_model,\n    convert_unity_checkpoint,\n    restrict_checkpoints=False,\n)\nload_unity_text_tokenizer = NllbTokenizerLoader(asset_store, download_manager)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "documentation": {}
    },
    {
        "label": "load_unity_model",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "peekOfCode": "load_unity_model = ModelLoader[UnitYModel, UnitYConfig](\n    asset_store,\n    download_manager,\n    load_unity_config,\n    create_unity_model,\n    convert_unity_checkpoint,\n    restrict_checkpoints=False,\n)\nload_unity_text_tokenizer = NllbTokenizerLoader(asset_store, download_manager)\nclass UnitYUnitTokenizerLoader:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "documentation": {}
    },
    {
        "label": "load_unity_text_tokenizer",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "peekOfCode": "load_unity_text_tokenizer = NllbTokenizerLoader(asset_store, download_manager)\nclass UnitYUnitTokenizerLoader:\n    \"\"\"Loads speech unit tokenizers of UnitY models.\"\"\"\n    def __init__(self, asset_store: AssetStore) -> None:\n        \"\"\"\n        :param asset_store:\n            The asset store to retrieve the model information.\n        \"\"\"\n        self.asset_store = asset_store\n    def __call__(self, model_name_or_card: Union[str, AssetCard]) -> UnitTokenizer:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "documentation": {}
    },
    {
        "label": "load_unity_unit_tokenizer",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "peekOfCode": "load_unity_unit_tokenizer = UnitYUnitTokenizerLoader(asset_store)\nclass GcmvnStatsLoader:\n    \"\"\"Loads GCMVN stats (mean & std) for ProsodyUnitY.\"\"\"\n    def __init__(self, asset_store: AssetStore) -> None:\n        \"\"\"\n        :param asset_store:\n            The asset store to retrieve the model information.\n        \"\"\"\n        self.asset_store = asset_store\n    def __call__(",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "documentation": {}
    },
    {
        "label": "load_gcmvn_stats",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "peekOfCode": "load_gcmvn_stats = GcmvnStatsLoader(asset_store)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.loader",
        "documentation": {}
    },
    {
        "label": "UnitYModel",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "peekOfCode": "class UnitYModel(EncoderDecoderModel):\n    \"\"\"Represents a UnitY model as described in\n    :cite:t`https://doi.org/10.48550/arxiv.2212.08055`.\n    Note that this implementation is augmented with a text encoder to enable\n    translating from text.\n    \"\"\"\n    model_dim: int\n    input_modality: str\n    speech_encoder_frontend: TransformerFrontend\n    speech_encoder: TransformerEncoder",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYX2TModel",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "peekOfCode": "class UnitYX2TModel(EncoderDecoderModel):\n    model_dim: int\n    encoder_frontend: TransformerFrontend\n    encoder: TransformerEncoder\n    decoder_frontend: TransformerFrontend\n    decoder: TransformerDecoder\n    final_proj: Projection\n    def __init__(\n        self,\n        encoder_frontend: TransformerFrontend,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYT2UModel",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "peekOfCode": "class UnitYT2UModel(EncoderDecoderModel):\n    \"\"\"Represents a UnitY T2U model as described in\n    :cite:t`https://doi.org/10.48550/arxiv.2212.08055`.\"\"\"\n    encoder: Optional[TransformerEncoder]\n    decoder_frontend: TransformerFrontend\n    decoder: TransformerDecoder\n    final_proj: Projection\n    def __init__(\n        self,\n        encoder: Optional[TransformerEncoder],",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYNART2UModel",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "peekOfCode": "class UnitYNART2UModel(Module):\n    \"\"\"Represents a non-autoregressive UnitY T2U model.\"\"\"\n    model_dim: int\n    encoder: Optional[TransformerEncoder]\n    decoder_frontend: NARDecoderFrontend\n    decoder: FeedForwardTransformer\n    final_proj: Projection\n    target_vocab_info: VocabularyInfo\n    prosody_proj: Optional[Projection]\n    def __init__(",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "UnitYOutput",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "peekOfCode": "class UnitYOutput:\n    \"\"\"Holds the output of a UnitY model.\"\"\"\n    s2t_output: SequenceModelOutput\n    \"\"\"The S2T output of the multitask model.\"\"\"\n    mt_output: SequenceModelOutput\n    \"\"\"The MT output of the multitask model.\"\"\"\n    t2u_output: SequenceModelOutput\n    \"\"\"The output of the T2U model.\"\"\"\n    def compute_loss(\n        self, targets: Tensor, ignore_prefix_size: int = 0, label_smoothing: float = 0.0",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.model",
        "documentation": {}
    },
    {
        "label": "TagManager",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.nar_decoder_frontend",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.nar_decoder_frontend",
        "peekOfCode": "class TagManager:\n    def __init__(self, vocab_info: VocabularyInfo):\n        self.vocab_info = vocab_info\n    def preprocess_text_seqs(self, text_seqs: Tensor) -> Tensor:\n        # Remove EOS, lang tokens as per NLLB \"target\" tokenizer mode.\n        text_seqs = text_seqs[:, 2:]\n        assert self.vocab_info.pad_idx is not None\n        text_seqs.masked_fill_(\n            text_seqs == self.vocab_info.eos_idx, self.vocab_info.pad_idx\n        )",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.nar_decoder_frontend",
        "documentation": {}
    },
    {
        "label": "NARDecoderFrontend",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.nar_decoder_frontend",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.nar_decoder_frontend",
        "peekOfCode": "class NARDecoderFrontend(Module):\n    \"\"\"Represents a Non-autoregressive decoder front-end.\"\"\"\n    char_pos_encoder: PositionEncoder\n    pos_emb_alpha_char: Parameter\n    unit_pos_encoder: PositionEncoder\n    pos_emb_alpha: Parameter\n    scale: float\n    char_length_regulator: HardUpsampling\n    variance_adaptor: VarianceAdaptor\n    layer_norm: Optional[LayerNorm]",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.nar_decoder_frontend",
        "documentation": {}
    },
    {
        "label": "SPACE",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.nar_decoder_frontend",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.nar_decoder_frontend",
        "peekOfCode": "SPACE = \"▁\"\nclass TagManager:\n    def __init__(self, vocab_info: VocabularyInfo):\n        self.vocab_info = vocab_info\n    def preprocess_text_seqs(self, text_seqs: Tensor) -> Tensor:\n        # Remove EOS, lang tokens as per NLLB \"target\" tokenizer mode.\n        text_seqs = text_seqs[:, 2:]\n        assert self.vocab_info.pad_idx is not None\n        text_seqs.masked_fill_(\n            text_seqs == self.vocab_info.eos_idx, self.vocab_info.pad_idx",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.nar_decoder_frontend",
        "documentation": {}
    },
    {
        "label": "VariancePredictorConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "peekOfCode": "class VariancePredictorConfig:\n    var_pred_hidden_dim: int\n    var_pred_kernel_size: int\n    var_pred_dropout: float\n    use_film: bool\n    film_cond_dim: int\n@dataclass\nclass NARDecoderFrontendConfig:\n    subword_to_unit_upsampling_type: Literal[\"gaussian\", \"hard\"]\n    duration_predictor_config: VariancePredictorConfig",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "NARDecoderFrontendConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "peekOfCode": "class NARDecoderFrontendConfig:\n    subword_to_unit_upsampling_type: Literal[\"gaussian\", \"hard\"]\n    duration_predictor_config: VariancePredictorConfig\n    pitch_predictor_config: Optional[VariancePredictorConfig]\n    energy_predictor_config: Optional[VariancePredictorConfig]\n@dataclass\nclass NARDecoderConfig:\n    model_name_or_card: Union[str, AssetCard]\n    char_vocabulary_size: int\n    char_max_seq_len: int",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "NARDecoderConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "peekOfCode": "class NARDecoderConfig:\n    model_name_or_card: Union[str, AssetCard]\n    char_vocabulary_size: int\n    char_max_seq_len: int\n    conv1d_kernel_size: int\n    conv1d_inner_dim: int\n    conv1d_dropout_p: float\n    use_film: bool\n    film_cond_dim: int\n@dataclass",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "UnitYT2UConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "peekOfCode": "class UnitYT2UConfig:\n    \"\"\"Holds the configuration of a UnitY T2U model as described in\n    :cite:t`https://doi.org/10.48550/arxiv.2212.08055`\"\"\"\n    model_dim: int\n    \"\"\"The dimensionality of the model.\"\"\"\n    unit_max_seq_len: int\n    \"\"\"The expected maximum unit sequence length.\"\"\"\n    target_vocab_info: VocabularyInfo\n    \"\"\"The target vocabulary information.\"\"\"\n    num_encoder_layers: int",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "UnitYT2UBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "peekOfCode": "class UnitYT2UBuilder:\n    \"\"\"Builds modules of an autoregressive UnitY T2U model.\n    To tweak the architecture, you can derive from this class and override the\n    corresponding methods.\n    \"\"\"\n    config: UnitYT2UConfig\n    device: Optional[Device]\n    dtype: Optional[DataType]\n    def __init__(\n        self,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "UnitYNART2UBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "peekOfCode": "class UnitYNART2UBuilder:\n    \"\"\"Builds modules of an NAR UnitY T2U model.\n    To tweak the architecture, you can derive from this class and override the\n    corresponding methods.\n    \"\"\"\n    config: UnitYT2UConfig\n    device: Optional[Device]\n    dtype: Optional[DataType]\n    def __init__(\n        self,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "create_unity_t2u_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "peekOfCode": "def create_unity_t2u_model(\n    config: UnitYT2UConfig,\n    device: Optional[Device] = None,\n    dtype: Optional[DataType] = None,\n) -> Union[UnitYT2UModel, UnitYNART2UModel]:\n    \"\"\"Create a UnitY T2U model.\n    :param config:\n        The configuration to use.\n    :param device:\n        The device on which to initialize modules.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "unity_t2u_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "peekOfCode": "unity_t2u_archs = ArchitectureRegistry[UnitYT2UConfig](\"unity_t2u\")\nunity_t2u_arch = unity_t2u_archs.decorator\n@unity_t2u_arch(\"base\")\ndef _base_t2u() -> UnitYT2UConfig:\n    return UnitYT2UConfig(\n        model_dim=1024,\n        unit_max_seq_len=2048,\n        target_vocab_info=VocabularyInfo(\n            size=10082, unk_idx=3, bos_idx=0, eos_idx=2, pad_idx=1\n        ),",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "unity_t2u_arch",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "peekOfCode": "unity_t2u_arch = unity_t2u_archs.decorator\n@unity_t2u_arch(\"base\")\ndef _base_t2u() -> UnitYT2UConfig:\n    return UnitYT2UConfig(\n        model_dim=1024,\n        unit_max_seq_len=2048,\n        target_vocab_info=VocabularyInfo(\n            size=10082, unk_idx=3, bos_idx=0, eos_idx=2, pad_idx=1\n        ),\n        num_encoder_layers=6,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.t2u_builder",
        "documentation": {}
    },
    {
        "label": "UnitTokenizer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.unit_tokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.unit_tokenizer",
        "peekOfCode": "class UnitTokenizer:\n    \"\"\"Represents a tokenizer to encode and decode UnitY speech units.\"\"\"\n    num_units: int\n    langs: Sequence[str]\n    lang_map: Dict[str, int]\n    def __init__(self, num_units: int, langs: Sequence[str], model_arch: str) -> None:\n        \"\"\"\n        :param num_units:\n            The number of speech units.\n        :param langs:",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "UnitTokenEncoder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.unit_tokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.unit_tokenizer",
        "peekOfCode": "class UnitTokenEncoder:\n    \"\"\"Encodes speech units into token indices.\"\"\"\n    tokenizer: UnitTokenizer\n    eos_idx: int\n    unk_idx: int\n    lang_idx: int\n    prefix_indices: Optional[Tensor]\n    def __init__(\n        self,\n        tokenizer: UnitTokenizer,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "UnitTokenDecoder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.unity.unit_tokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.models.unity.unit_tokenizer",
        "peekOfCode": "class UnitTokenDecoder:\n    \"\"\"Decodes speech units from token indices.\"\"\"\n    eos_idx: int\n    pad_idx: int\n    def __init__(self, tokenizer: UnitTokenizer, is_nar_decoder: bool) -> None:\n        \"\"\"\n        :param tokenizer:\n            The unit tokenizer to use.\n        :param is_nar_decoder:\n            If True, the unit decoder is non-autoregressive.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.unity.unit_tokenizer",
        "documentation": {}
    },
    {
        "label": "VocoderConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "peekOfCode": "class VocoderConfig:\n    \"\"\"Holds the configuration of a Vocoder model.\"\"\"\n    upsample_rates: List[int]\n    upsample_kernel_sizes: List[int]\n    upsample_initial_channel: int\n    resblock_kernel_sizes: List[int]\n    resblock_dilation_sizes: List[List[int]]\n    model_in_dim: int\n    num_embeddings: int\n    embedding_dim: int",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "documentation": {}
    },
    {
        "label": "VocoderBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "peekOfCode": "class VocoderBuilder:\n    \"\"\"Builds modules of a vocoder model (Code Hifigan) as described in\n    :cite:t`https://github.com/facebookresearch/speech-resynthesis`.\n    To tweak the architecture, you can derive from this class and override the\n    corresponding methods.\n    \"\"\"\n    config: VocoderConfig\n    device: Optional[Device]\n    dtype: Optional[DataType]\n    def __init__(",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "documentation": {}
    },
    {
        "label": "create_vocoder_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "peekOfCode": "def create_vocoder_model(\n    config: VocoderConfig,\n    device: Optional[Device] = None,\n    dtype: Optional[DataType] = None,\n) -> Vocoder:\n    \"\"\"Create a Vocoder model.\n    :param config:\n        The configuration to use.\n    :param device:\n        The device on which to initialize modules.",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "documentation": {}
    },
    {
        "label": "vocoder_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "peekOfCode": "vocoder_archs = ArchitectureRegistry[VocoderConfig](\"vocoder_code_hifigan\")\nvocoder_arch = vocoder_archs.decorator\n@vocoder_arch(\"base\")\ndef _base_vocoder() -> VocoderConfig:\n    return VocoderConfig(\n        upsample_rates=[5, 4, 4, 2, 2],\n        upsample_kernel_sizes=[11, 8, 8, 4, 4],\n        upsample_initial_channel=512,\n        resblock_kernel_sizes=[3, 7, 11],\n        resblock_dilation_sizes=[[1, 3, 5], [1, 3, 5], [1, 3, 5]],",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "documentation": {}
    },
    {
        "label": "vocoder_arch",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "peekOfCode": "vocoder_arch = vocoder_archs.decorator\n@vocoder_arch(\"base\")\ndef _base_vocoder() -> VocoderConfig:\n    return VocoderConfig(\n        upsample_rates=[5, 4, 4, 2, 2],\n        upsample_kernel_sizes=[11, 8, 8, 4, 4],\n        upsample_initial_channel=512,\n        resblock_kernel_sizes=[3, 7, 11],\n        resblock_dilation_sizes=[[1, 3, 5], [1, 3, 5], [1, 3, 5]],\n        model_in_dim=1792,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.builder",
        "documentation": {}
    },
    {
        "label": "CodeGenerator",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.codehifigan",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.codehifigan",
        "peekOfCode": "class CodeGenerator(Generator):\n    def __init__(\n        self,\n        upsample_rates: List[int],\n        upsample_kernel_sizes: List[int],\n        upsample_initial_channel: int,\n        resblock_kernel_sizes: List[int],\n        resblock_dilation_sizes: List[List[int]],\n        model_in_dim: Optional[int],\n        num_embeddings: int,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.codehifigan",
        "documentation": {}
    },
    {
        "label": "ResBlock",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "peekOfCode": "class ResBlock(Module):\n    def __init__(\n        self, channels: int, kernel_size: int = 3, dilation: List[int] = [1, 3, 5]\n    ):\n        super(ResBlock, self).__init__()\n        self.convs1 = ModuleList(\n            [\n                weight_norm(\n                    Conv1d(\n                        channels,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "Generator",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "peekOfCode": "class Generator(Module):\n    def __init__(\n        self,\n        upsample_rates: List[int],\n        upsample_kernel_sizes: List[int],\n        upsample_initial_channel: int,\n        resblock_kernel_sizes: List[int],\n        resblock_dilation_sizes: List[List[int]],\n        model_in_dim: Optional[int],\n        add_ups_out_pad: bool = False,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "init_weights",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "peekOfCode": "def init_weights(m, mean: float = 0.0, std: float = 0.01) -> None:  # type: ignore\n    classname = m.__class__.__name__\n    if classname.find(\"Conv\") != -1:\n        m.weight.data.normal_(mean, std)\ndef get_padding(kernel_size: int, dilation: int = 1) -> int:\n    return (kernel_size * dilation - dilation) // 2\nclass ResBlock(Module):\n    def __init__(\n        self, channels: int, kernel_size: int = 3, dilation: List[int] = [1, 3, 5]\n    ):",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "get_padding",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "peekOfCode": "def get_padding(kernel_size: int, dilation: int = 1) -> int:\n    return (kernel_size * dilation - dilation) // 2\nclass ResBlock(Module):\n    def __init__(\n        self, channels: int, kernel_size: int = 3, dilation: List[int] = [1, 3, 5]\n    ):\n        super(ResBlock, self).__init__()\n        self.convs1 = ModuleList(\n            [\n                weight_norm(",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "LRELU_SLOPE",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "peekOfCode": "LRELU_SLOPE = 0.1\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s %(levelname)s -- %(name)s: %(message)s\",\n)\nlogger = logging.getLogger(__name__)\ndef init_weights(m, mean: float = 0.0, std: float = 0.01) -> None:  # type: ignore\n    classname = m.__class__.__name__\n    if classname.find(\"Conv\") != -1:\n        m.weight.data.normal_(mean, std)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef init_weights(m, mean: float = 0.0, std: float = 0.01) -> None:  # type: ignore\n    classname = m.__class__.__name__\n    if classname.find(\"Conv\") != -1:\n        m.weight.data.normal_(mean, std)\ndef get_padding(kernel_size: int, dilation: int = 1) -> int:\n    return (kernel_size * dilation - dilation) // 2\nclass ResBlock(Module):\n    def __init__(\n        self, channels: int, kernel_size: int = 3, dilation: List[int] = [1, 3, 5]",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.hifigan",
        "documentation": {}
    },
    {
        "label": "convert_vocoder_checkpoint",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.loader",
        "peekOfCode": "def convert_vocoder_checkpoint(\n    checkpoint: Mapping[str, Any], config: VocoderConfig\n) -> Mapping[str, Any]:\n    if (\n        \"model\" in checkpoint\n        and \"code_generator.resblocks.0.convs1.0.weight_g\" in checkpoint[\"model\"]\n    ):\n        return checkpoint\n    old_state_dict = checkpoint[\"generator\"]\n    new_state_dict = {}",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.loader",
        "documentation": {}
    },
    {
        "label": "load_vocoder_config",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.loader",
        "peekOfCode": "load_vocoder_config = ConfigLoader[VocoderConfig](asset_store, vocoder_archs)\nload_vocoder_model = ModelLoader[Vocoder, VocoderConfig](\n    asset_store,\n    download_manager,\n    load_vocoder_config,\n    create_vocoder_model,\n    convert_vocoder_checkpoint,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.loader",
        "documentation": {}
    },
    {
        "label": "load_vocoder_model",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.loader",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.loader",
        "peekOfCode": "load_vocoder_model = ModelLoader[Vocoder, VocoderConfig](\n    asset_store,\n    download_manager,\n    load_vocoder_config,\n    create_vocoder_model,\n    convert_vocoder_checkpoint,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.loader",
        "documentation": {}
    },
    {
        "label": "Vocoder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.vocoder.vocoder",
        "description": "lib.seamless_communication.src.seamless_communication.models.vocoder.vocoder",
        "peekOfCode": "class Vocoder(Module):\n    def __init__(\n        self,\n        code_generator: CodeGenerator,\n        lang_spkr_idx_map: Dict[str, Any],\n    ):\n        super().__init__()\n        self.code_generator = code_generator\n        self.lang_spkr_idx_map = lang_spkr_idx_map\n    def forward(",
        "detail": "lib.seamless_communication.src.seamless_communication.models.vocoder.vocoder",
        "documentation": {}
    },
    {
        "label": "SPMTokenizer",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.models.tokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.models.tokenizer",
        "peekOfCode": "class SPMTokenizer(TextTokenizer):\n    \"\"\"Represents standard SPM-based tokenizer used in MT tasks\"\"\"\n    model: SentencePieceModel\n    langs: Set[str]\n    prepend_target_langtok_to_target: bool\n    def __init__(\n        self,\n        pathname: PathLike,\n        langs: Sequence[str],\n        prepend_target_langtok_to_target: bool = True,",
        "detail": "lib.seamless_communication.src.seamless_communication.models.tokenizer",
        "documentation": {}
    },
    {
        "label": "EarlyStoppingMixin",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.common",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.common",
        "peekOfCode": "class EarlyStoppingMixin:\n    def reset_early(self) -> None:\n        \"\"\"\n        Implement to override for different behavior on a reset that\n        happens before EOS\n        \"\"\"\n        raise NotImplementedError()\nclass AgentStates(AgentStatesOrig):  # type: ignore\n    def update_target(self, segment: Segment) -> None:\n        \"\"\"An AgentStates impl which doesn't update states.target\"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "AgentStates",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.common",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.common",
        "peekOfCode": "class AgentStates(AgentStatesOrig):  # type: ignore\n    def update_target(self, segment: Segment) -> None:\n        \"\"\"An AgentStates impl which doesn't update states.target\"\"\"\n        self.target_finished = segment.finished\nclass NoUpdateTargetMixin:\n    \"\"\"A shortcut to make agents default to the AgentStates impl above\"\"\"\n    def build_states(self) -> AgentStates:\n        return AgentStates()",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "NoUpdateTargetMixin",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.common",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.common",
        "peekOfCode": "class NoUpdateTargetMixin:\n    \"\"\"A shortcut to make agents default to the AgentStates impl above\"\"\"\n    def build_states(self) -> AgentStates:\n        return AgentStates()",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.common",
        "documentation": {}
    },
    {
        "label": "DetokenizerAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.detokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.detokenizer",
        "peekOfCode": "class DetokenizerAgent(NoUpdateTargetMixin, TextToTextAgent):  # type: ignore\n    def __init__(self, args: Namespace):\n        super().__init__(args)\n        self.detokenize_only = args.detokenize_only\n    @classmethod\n    def from_args(cls, args: Namespace, **kwargs: Dict[str, Any]) -> DetokenizerAgent:\n        return cls(args)\n    def add_args(parser: ArgumentParser) -> None:\n        parser.add_argument(\n            \"--detokenize-only\",",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.detokenizer",
        "documentation": {}
    },
    {
        "label": "UnitYDetokenizerAgentStates",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.detokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.detokenizer",
        "peekOfCode": "class UnitYDetokenizerAgentStates(AgentStates):\n    def update_source(self, segment: Segment) -> None:\n        \"\"\"\n        Extract tokens from UnitYTextDecoderOutput\n        \"\"\"\n        self.source_finished = segment.finished\n        if isinstance(segment, EmptySegment):\n            return\n        # TextSegment\n        segment_content: UnitYTextDecoderOutput = segment.content",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.detokenizer",
        "documentation": {}
    },
    {
        "label": "UnitYDetokenizerAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.detokenizer",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.detokenizer",
        "peekOfCode": "class UnitYDetokenizerAgent(DetokenizerAgent):\n    def build_states(self) -> UnitYDetokenizerAgentStates:\n        return UnitYDetokenizerAgentStates()",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.detokenizer",
        "documentation": {}
    },
    {
        "label": "DualVocoderStates",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.dual_vocoder_agent",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.dual_vocoder_agent",
        "peekOfCode": "class DualVocoderStates(AgentStates):\n    def __init__(\n        self, vocoder_states: AgentStates, expr_vocoder_states: AgentStates\n    ) -> None:\n        self.vocoder_states = vocoder_states\n        self.expr_vocoder_states = expr_vocoder_states\n        self.config: Dict[str, Any] = {}\n    @property\n    def target_finished(self):  # type: ignore\n        return (",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.dual_vocoder_agent",
        "documentation": {}
    },
    {
        "label": "DualVocoderAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.dual_vocoder_agent",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.dual_vocoder_agent",
        "peekOfCode": "class DualVocoderAgent(TextToSpeechAgent):  # type: ignore\n    def __init__(\n        self,\n        args: Namespace,\n        vocoder: VocoderAgent,\n        expr_vocoder: PretsselVocoderAgent,\n    ) -> None:\n        self.vocoder = vocoder\n        self.expr_vocoder = expr_vocoder\n        super().__init__(args)",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.dual_vocoder_agent",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.dual_vocoder_agent",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.dual_vocoder_agent",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass DualVocoderStates(AgentStates):\n    def __init__(\n        self, vocoder_states: AgentStates, expr_vocoder_states: AgentStates\n    ) -> None:\n        self.vocoder_states = vocoder_states\n        self.expr_vocoder_states = expr_vocoder_states\n        self.config: Dict[str, Any] = {}\n    @property\n    def target_finished(self):  # type: ignore",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.dual_vocoder_agent",
        "documentation": {}
    },
    {
        "label": "OfflineWav2VecBertEncoderAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "peekOfCode": "class OfflineWav2VecBertEncoderAgent(NoUpdateTargetMixin, SpeechToSpeechAgent):  # type: ignore\n    \"\"\"\n    Incremental encoding of an wav2vec encoder output\n    It update the whole encoder states every time when there is a new incoming segment.\n    \"\"\"\n    def __init__(\n        self,\n        unity_model: UnitYModel,\n        w2v2_encoder_config: Wav2Vec2EncoderConfig,\n        text_tokenizer: TextTokenizer,",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.offline_w2v_bert_encoder",
        "documentation": {}
    },
    {
        "label": "FeatureStates",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "peekOfCode": "class FeatureStates(AgentStates):  # type: ignore\n    def reset(self) -> None:\n        super().reset()\n        self.previous_residual_samples: List[float] = []\n        self.tgt_lang = None\n    def update_source(self, segment: Segment) -> None:\n        \"\"\"\n        Update states from input segment\n        Args:\n            segment (~simuleval.agents.segments.Segment): input segment",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "documentation": {}
    },
    {
        "label": "OnlineFeatureExtractorAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "peekOfCode": "class OnlineFeatureExtractorAgent(SpeechToSpeechAgent):  # type: ignore\n    \"\"\"\n    Extract speech features on the fly.\n    \"\"\"\n    def __init__(self, args: Namespace):\n        super().__init__(args)\n        self.shift_size = args.shift_size\n        self.window_size = args.window_size\n        assert self.window_size >= self.shift_size\n        self.sample_rate = args.sample_rate",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "documentation": {}
    },
    {
        "label": "SHIFT_SIZE",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "peekOfCode": "SHIFT_SIZE = 10\nWINDOW_SIZE = 25\nSAMPLE_RATE = 16000\nFEATURE_DIM = 80\nclass FeatureStates(AgentStates):  # type: ignore\n    def reset(self) -> None:\n        super().reset()\n        self.previous_residual_samples: List[float] = []\n        self.tgt_lang = None\n    def update_source(self, segment: Segment) -> None:",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "documentation": {}
    },
    {
        "label": "WINDOW_SIZE",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "peekOfCode": "WINDOW_SIZE = 25\nSAMPLE_RATE = 16000\nFEATURE_DIM = 80\nclass FeatureStates(AgentStates):  # type: ignore\n    def reset(self) -> None:\n        super().reset()\n        self.previous_residual_samples: List[float] = []\n        self.tgt_lang = None\n    def update_source(self, segment: Segment) -> None:\n        \"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "documentation": {}
    },
    {
        "label": "SAMPLE_RATE",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "peekOfCode": "SAMPLE_RATE = 16000\nFEATURE_DIM = 80\nclass FeatureStates(AgentStates):  # type: ignore\n    def reset(self) -> None:\n        super().reset()\n        self.previous_residual_samples: List[float] = []\n        self.tgt_lang = None\n    def update_source(self, segment: Segment) -> None:\n        \"\"\"\n        Update states from input segment",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "documentation": {}
    },
    {
        "label": "FEATURE_DIM",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "peekOfCode": "FEATURE_DIM = 80\nclass FeatureStates(AgentStates):  # type: ignore\n    def reset(self) -> None:\n        super().reset()\n        self.previous_residual_samples: List[float] = []\n        self.tgt_lang = None\n    def update_source(self, segment: Segment) -> None:\n        \"\"\"\n        Update states from input segment\n        Args:",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_feature_extractor",
        "documentation": {}
    },
    {
        "label": "DecoderAgentStates",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "peekOfCode": "class DecoderAgentStates(AgentStates):  # type: ignore\n    def reset(self) -> None:\n        self.source_len = 0\n        self.target_indices: List[int] = []\n        self.tgt_lang = None\n        self.ngram_block_count = 0\n        super().reset()\n    def update_source(self, segment: Segment) -> None:\n        \"\"\"\n        Update states from input segment",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "OnlineTextDecoderAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "peekOfCode": "class OnlineTextDecoderAgent(GenericAgent):  # type: ignore\n    \"\"\"\n    Online text decoder\n    \"\"\"\n    target_type = \"text\"\n    def __init__(\n        self,\n        model: MonotonicDecoderModel,\n        config: MonotonicDecoderConfig,\n        text_tokenizer: NllbTokenizer,",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "MMATextDecoderAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "peekOfCode": "class MMATextDecoderAgent(OnlineTextDecoderAgent):  # type: ignore\n    def __init__(\n        self,\n        model: MonotonicDecoderModel,\n        config: MonotonicDecoderConfig,\n        text_tokenizer: NllbTokenizer,\n        args: Namespace,\n    ) -> None:\n        super().__init__(model, config, text_tokenizer, args=args)\n        self.num_decoder_layers = self.config.num_decoder_layers",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "MMASpeechToTextDecoderAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "peekOfCode": "class MMASpeechToTextDecoderAgent(MMATextDecoderAgent):\n    source_type = \"speech\"\n@dataclass\nclass UnitYTextDecoderOutput:\n    decoder_features: Tensor\n    tokens: List[str]\n    target_indices: Optional[Tensor] = None\nclass UnitYMMATextDecoderAgent(MMASpeechToTextDecoderAgent):\n    \"\"\"\n    MMA UnitY text decoder agent which just prepares the decoder",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "UnitYTextDecoderOutput",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "peekOfCode": "class UnitYTextDecoderOutput:\n    decoder_features: Tensor\n    tokens: List[str]\n    target_indices: Optional[Tensor] = None\nclass UnitYMMATextDecoderAgent(MMASpeechToTextDecoderAgent):\n    \"\"\"\n    MMA UnitY text decoder agent which just prepares the decoder\n    output for the downstream agent.\n    \"\"\"\n    def postprocess(",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "UnitYMMATextDecoderAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "peekOfCode": "class UnitYMMATextDecoderAgent(MMASpeechToTextDecoderAgent):\n    \"\"\"\n    MMA UnitY text decoder agent which just prepares the decoder\n    output for the downstream agent.\n    \"\"\"\n    def postprocess(\n        self,\n        states: DecoderAgentStates,\n        pred_indices: List[int],\n        finished: bool,",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_text_decoder",
        "documentation": {}
    },
    {
        "label": "NARUnitDecoderAgentStates",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_unit_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_unit_decoder",
        "peekOfCode": "class NARUnitDecoderAgentStates(AgentStates):  # type: ignore\n    def reset(self) -> None:\n        self.source_token_list: List[str] = []\n        self.source_indices: Optional[torch.Tensor] = None\n        self.duration_start_index: int = 0\n        self.tgt_lang = None\n        super().reset()\n    def update_source(self, segment: Segment) -> None:\n        \"\"\"\n        Update states from input segment",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_unit_decoder",
        "documentation": {}
    },
    {
        "label": "NARUnitYUnitDecoderAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_unit_decoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_unit_decoder",
        "peekOfCode": "class NARUnitYUnitDecoderAgent(GenericAgent):  # type: ignore\n    \"\"\"Non-autoregressive unit decoder\"\"\"\n    source_type = \"text\"\n    target_type = \"text\"\n    def __init__(\n        self, model: UnitYNART2UModel, tokenizer: UnitTokenizer, args: Namespace\n    ) -> None:\n        self.model = model\n        self.tokenizer = tokenizer\n        self.min_unit_chunk_size = args.min_unit_chunk_size",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_unit_decoder",
        "documentation": {}
    },
    {
        "label": "VocoderAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_vocoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_vocoder",
        "peekOfCode": "class VocoderAgent(TextToSpeechAgent):  # type: ignore\n    def __init__(self, args: Namespace) -> None:\n        super().__init__(args)\n        logger.info(\n            f\"Loading the Vocoder model: {args.vocoder_name} on device={args.device}, dtype={args.dtype}\"\n        )\n        self.vocoder = load_vocoder_model(\n            args.vocoder_name, device=args.device, dtype=args.dtype\n        )\n        self.vocoder.eval()",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_vocoder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_vocoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_vocoder",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VocoderAgent(TextToSpeechAgent):  # type: ignore\n    def __init__(self, args: Namespace) -> None:\n        super().__init__(args)\n        logger.info(\n            f\"Loading the Vocoder model: {args.vocoder_name} on device={args.device}, dtype={args.dtype}\"\n        )\n        self.vocoder = load_vocoder_model(\n            args.vocoder_name, device=args.device, dtype=args.dtype\n        )",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.online_vocoder",
        "documentation": {}
    },
    {
        "label": "PretsselVocoderAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.pretssel_vocoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.pretssel_vocoder",
        "peekOfCode": "class PretsselVocoderAgent(NoUpdateTargetMixin, TextToSpeechAgent):  # type: ignore\n    def __init__(self, args: Namespace) -> None:\n        super().__init__(args)\n        if args.gated_model_dir:\n            add_gated_assets(args.gated_model_dir)\n        logger.info(\n            f\"Loading the Vocoder model: {args.vocoder_name} on device={args.device}, dtype={args.dtype}\"\n        )\n        assert \"pretssel\" in args.vocoder_name\n        self.vocoder = load_pretssel_vocoder_model(",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.pretssel_vocoder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.pretssel_vocoder",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.pretssel_vocoder",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass PretsselVocoderAgent(NoUpdateTargetMixin, TextToSpeechAgent):  # type: ignore\n    def __init__(self, args: Namespace) -> None:\n        super().__init__(args)\n        if args.gated_model_dir:\n            add_gated_assets(args.gated_model_dir)\n        logger.info(\n            f\"Loading the Vocoder model: {args.vocoder_name} on device={args.device}, dtype={args.dtype}\"\n        )\n        assert \"pretssel\" in args.vocoder_name",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.pretssel_vocoder",
        "documentation": {}
    },
    {
        "label": "SeamlessS2STAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_s2st",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_s2st",
        "peekOfCode": "class SeamlessS2STAgent(UnitYAgentPipeline):\n    pipeline = [\n        OnlineFeatureExtractorAgent,\n        OfflineWav2VecBertEncoderAgent,\n        UnitYMMATextDecoderAgent,\n        NARUnitYUnitDecoderAgent,\n        PretsselVocoderAgent,\n    ]\nclass SeamlessS2STJointVADAgent(UnitYAgentTreePipeline):\n    pipeline = {",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_s2st",
        "documentation": {}
    },
    {
        "label": "SeamlessS2STJointVADAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_s2st",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_s2st",
        "peekOfCode": "class SeamlessS2STJointVADAgent(UnitYAgentTreePipeline):\n    pipeline = {\n        SileroVADAgent: [OnlineFeatureExtractorAgent],\n        OnlineFeatureExtractorAgent: [OfflineWav2VecBertEncoderAgent],\n        OfflineWav2VecBertEncoderAgent: [UnitYMMATextDecoderAgent],\n        UnitYMMATextDecoderAgent: [UnitYDetokenizerAgent, NARUnitYUnitDecoderAgent],\n        UnitYDetokenizerAgent: [],\n        NARUnitYUnitDecoderAgent: [PretsselVocoderAgent],\n        PretsselVocoderAgent: [],\n    }",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_s2st",
        "documentation": {}
    },
    {
        "label": "SeamlessS2STDualVocoderVADAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_s2st",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_s2st",
        "peekOfCode": "class SeamlessS2STDualVocoderVADAgent(UnitYAgentTreePipeline):\n    pipeline = {\n        SileroVADAgent: [OnlineFeatureExtractorAgent],\n        OnlineFeatureExtractorAgent: [OfflineWav2VecBertEncoderAgent],\n        OfflineWav2VecBertEncoderAgent: [UnitYMMATextDecoderAgent],\n        UnitYMMATextDecoderAgent: [UnitYDetokenizerAgent, NARUnitYUnitDecoderAgent],\n        UnitYDetokenizerAgent: [],\n        NARUnitYUnitDecoderAgent: [DualVocoderAgent],\n        DualVocoderAgent: [],\n    }",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_s2st",
        "documentation": {}
    },
    {
        "label": "SeamlessStreamingS2STAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2st",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2st",
        "peekOfCode": "class SeamlessStreamingS2STAgent(UnitYAgentPipeline):\n    pipeline = [\n        OnlineFeatureExtractorAgent,\n        OfflineWav2VecBertEncoderAgent,\n        UnitYMMATextDecoderAgent,\n        NARUnitYUnitDecoderAgent,\n        VocoderAgent,\n    ]\nclass SeamlessStreamingS2STVADAgent(UnitYAgentPipeline):\n    pipeline = [",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2st",
        "documentation": {}
    },
    {
        "label": "SeamlessStreamingS2STVADAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2st",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2st",
        "peekOfCode": "class SeamlessStreamingS2STVADAgent(UnitYAgentPipeline):\n    pipeline = [\n        SileroVADAgent,\n        OnlineFeatureExtractorAgent,\n        OfflineWav2VecBertEncoderAgent,\n        UnitYMMATextDecoderAgent,\n        NARUnitYUnitDecoderAgent,\n        VocoderAgent,\n    ]\nclass SeamlessStreamingS2STJointVADAgent(UnitYAgentTreePipeline):",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2st",
        "documentation": {}
    },
    {
        "label": "SeamlessStreamingS2STJointVADAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2st",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2st",
        "peekOfCode": "class SeamlessStreamingS2STJointVADAgent(UnitYAgentTreePipeline):\n    pipeline = {\n        SileroVADAgent: [OnlineFeatureExtractorAgent],\n        OnlineFeatureExtractorAgent: [OfflineWav2VecBertEncoderAgent],\n        OfflineWav2VecBertEncoderAgent: [UnitYMMATextDecoderAgent],\n        UnitYMMATextDecoderAgent: [UnitYDetokenizerAgent, NARUnitYUnitDecoderAgent],\n        UnitYDetokenizerAgent: [],\n        NARUnitYUnitDecoderAgent: [VocoderAgent],\n        VocoderAgent: [],\n    }",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2st",
        "documentation": {}
    },
    {
        "label": "SeamlessStreamingS2TDetokAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2t",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2t",
        "peekOfCode": "class SeamlessStreamingS2TDetokAgent(UnitYAgentPipeline):\n    pipeline = [\n        OnlineFeatureExtractorAgent,\n        OfflineWav2VecBertEncoderAgent,\n        MMASpeechToTextDecoderAgent,\n        DetokenizerAgent,\n    ]\nclass SeamlessStreamingS2TAgent(UnitYAgentPipeline):\n    pipeline = [\n        OnlineFeatureExtractorAgent,",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2t",
        "documentation": {}
    },
    {
        "label": "SeamlessStreamingS2TAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2t",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2t",
        "peekOfCode": "class SeamlessStreamingS2TAgent(UnitYAgentPipeline):\n    pipeline = [\n        OnlineFeatureExtractorAgent,\n        OfflineWav2VecBertEncoderAgent,\n        MMASpeechToTextDecoderAgent,\n    ]\nclass SeamlessStreamingS2TVADAgent(UnitYAgentPipeline):\n    pipeline = [\n        SileroVADAgent,\n        OnlineFeatureExtractorAgent,",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2t",
        "documentation": {}
    },
    {
        "label": "SeamlessStreamingS2TVADAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2t",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2t",
        "peekOfCode": "class SeamlessStreamingS2TVADAgent(UnitYAgentPipeline):\n    pipeline = [\n        SileroVADAgent,\n        OnlineFeatureExtractorAgent,\n        OfflineWav2VecBertEncoderAgent,\n        MMASpeechToTextDecoderAgent,\n        DetokenizerAgent,\n    ]",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.seamless_streaming_s2t",
        "documentation": {}
    },
    {
        "label": "SileroVADStates",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "peekOfCode": "class SileroVADStates(EarlyStoppingMixin, AgentStates):  # type: ignore\n    def __init__(self, args: Namespace) -> None:\n        self.model, utils = torch.hub.load(\n            repo_or_dir=\"snakers4/silero-vad\",\n            model=\"silero_vad\",\n            force_reload=False,\n            onnx=False,\n        )\n        (\n            self.get_speech_timestamps,",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "documentation": {}
    },
    {
        "label": "SileroVADAgent",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "peekOfCode": "class SileroVADAgent(SpeechToSpeechAgent):  # type: ignore\n    def __init__(self, args: Namespace) -> None:\n        super().__init__(args)\n        self.chunk_size_samples = args.chunk_size_samples\n        self.args = args\n    @staticmethod\n    def add_args(parser: ArgumentParser) -> None:\n        parser.add_argument(\n            \"--window-size-samples\",\n            default=512,  # sampling_rate // 1000 * 32 => 32 ms at 16000 sample rate",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "peekOfCode": "logger = logging.getLogger(__name__)\nSPEECH_PROB_THRESHOLD = 0.6\nclass SileroVADStates(EarlyStoppingMixin, AgentStates):  # type: ignore\n    def __init__(self, args: Namespace) -> None:\n        self.model, utils = torch.hub.load(\n            repo_or_dir=\"snakers4/silero-vad\",\n            model=\"silero_vad\",\n            force_reload=False,\n            onnx=False,\n        )",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "documentation": {}
    },
    {
        "label": "SPEECH_PROB_THRESHOLD",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "peekOfCode": "SPEECH_PROB_THRESHOLD = 0.6\nclass SileroVADStates(EarlyStoppingMixin, AgentStates):  # type: ignore\n    def __init__(self, args: Namespace) -> None:\n        self.model, utils = torch.hub.load(\n            repo_or_dir=\"snakers4/silero-vad\",\n            model=\"silero_vad\",\n            force_reload=False,\n            onnx=False,\n        )\n        (",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.silero_vad",
        "documentation": {}
    },
    {
        "label": "UnitYPipelineMixin",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "peekOfCode": "class UnitYPipelineMixin:\n    \"\"\"\n    Mixin for UnitY pipeline which works with both AgentPipeline\n    and TreeAgentPipeline\n    \"\"\"\n    @classmethod\n    def add_args(cls, parser: ArgumentParser) -> None:\n        super().add_args(parser)  # type: ignore\n        parser.add_argument(\"--task\", type=str, help=\"Task type\")\n        parser.add_argument(",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "UnitYAgentPipeline",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "peekOfCode": "class UnitYAgentPipeline(UnitYPipelineMixin, AgentPipeline):  # type: ignore\n    pipeline: List[GenericAgent] = []\n    def __init__(self, args: Namespace):\n        models_and_configs = self.load_model(args)\n        module_list = []\n        for p in self.pipeline:\n            module_list.append(\n                p.from_args(\n                    args,\n                    **models_and_configs,",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "UnitYAgentTreePipeline",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "peekOfCode": "class UnitYAgentTreePipeline(UnitYPipelineMixin, TreeAgentPipeline):  # type: ignore\n    pipeline: Any = {}\n    def __init__(self, args: Namespace):\n        models_and_configs = self.load_model(args)\n        assert len(self.pipeline) > 0\n        module_dict = {}\n        for module_class, children in self.pipeline.items():\n            module_dict[module_class.from_args(args, **models_and_configs)] = children\n        super().__init__(module_dict, args)\n    @classmethod",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "maybe_reset_states",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "peekOfCode": "def maybe_reset_states(states: Optional[List[Optional[AgentStates]]]) -> None:\n    assert states is not None\n    for s in states:\n        if s is not None:\n            if isinstance(s, EarlyStoppingMixin):\n                s.reset_early()\n            else:\n                s.reset()\nclass UnitYPipelineMixin:\n    \"\"\"",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef maybe_reset_states(states: Optional[List[Optional[AgentStates]]]) -> None:\n    assert states is not None\n    for s in states:\n        if s is not None:\n            if isinstance(s, EarlyStoppingMixin):\n                s.reset_early()\n            else:\n                s.reset()\nclass UnitYPipelineMixin:",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.agents.unity_pipeline",
        "documentation": {}
    },
    {
        "label": "SoundFileInfo",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "peekOfCode": "class SoundFileInfo:\n    samplerate: float\n    path: str\n    def __repr__(self) -> str:\n        return \"\\n\".join([f\"samplerate: {str(self.samplerate)}\", f\"path: {self.path}\"])\ndef count_lines(filename: Path) -> int:\n    result = subprocess.run([\"wc\", \"-l\", filename], stdout=subprocess.PIPE)\n    return int(result.stdout.decode().split()[0]) - 1\nclass SileroVADSilenceRemover:\n    def __init__(self, sample_rate: int = 16000) -> None:",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "documentation": {}
    },
    {
        "label": "SileroVADSilenceRemover",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "peekOfCode": "class SileroVADSilenceRemover:\n    def __init__(self, sample_rate: int = 16000) -> None:\n        self.sample_rate = sample_rate\n        self.model, self.utils = torch.hub.load(\n            repo_or_dir=\"snakers4/silero-vad\",\n            model=\"silero_vad\",\n            # force_reload=True,\n            onnx=False,\n        )\n    def __call__(self, sample: torch.Tensor, is_standardized: bool) -> List[float]:",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "documentation": {}
    },
    {
        "label": "SimulEvalSpeechToTextDataloader",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "peekOfCode": "class SimulEvalSpeechToTextDataloader(SpeechToTextDataloader, IterableDataloader):  # type: ignore\n    def __init__(\n        self, data_pipeline: DataPipeline, is_standardized: bool, args: Namespace\n    ) -> None:\n        self.args = args\n        self.data_file: Path = Path(getattr(self.args, \"data_file\", \"\"))\n        if not self.data_file.exists():\n            raise ValueError(f\"data_file: {self.data_file} does not exist.\")\n        self.start_index: int = getattr(self.args, \"start_index\", 0)\n        self.end_index: int = getattr(self.args, \"end_index\", -1)",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "documentation": {}
    },
    {
        "label": "count_lines",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "peekOfCode": "def count_lines(filename: Path) -> int:\n    result = subprocess.run([\"wc\", \"-l\", filename], stdout=subprocess.PIPE)\n    return int(result.stdout.decode().split()[0]) - 1\nclass SileroVADSilenceRemover:\n    def __init__(self, sample_rate: int = 16000) -> None:\n        self.sample_rate = sample_rate\n        self.model, self.utils = torch.hub.load(\n            repo_or_dir=\"snakers4/silero-vad\",\n            model=\"silero_vad\",\n            # force_reload=True,",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "description": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass SoundFileInfo:\n    samplerate: float\n    path: str\n    def __repr__(self) -> str:\n        return \"\\n\".join([f\"samplerate: {str(self.samplerate)}\", f\"path: {self.path}\"])\ndef count_lines(filename: Path) -> int:\n    result = subprocess.run([\"wc\", \"-l\", filename], stdout=subprocess.PIPE)\n    return int(result.stdout.decode().split()[0]) - 1",
        "detail": "lib.seamless_communication.src.seamless_communication.streaming.dataloaders.s2tt",
        "documentation": {}
    },
    {
        "label": "MutoxClassifierBuilder",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.builder",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.builder",
        "peekOfCode": "class MutoxClassifierBuilder:\n    \"\"\"\n    Builder module for MutoxClassifier model\n    \"\"\"\n    config: MutoxConfig\n    device: tp.Optional[Device]\n    dtype: tp.Optional[DataType]\n    def __init__(\n        self,\n        config: MutoxConfig,",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.builder",
        "documentation": {}
    },
    {
        "label": "create_mutox_model",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.builder",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.builder",
        "peekOfCode": "def create_mutox_model(\n    config: MutoxConfig,\n    device: tp.Optional[Device] = None,\n    dtype: tp.Optional[DataType] = None,\n) -> MutoxClassifier:\n    \"\"\"Create a Mutox Classifier model.\n    :param config:\n        The configuration to use.\n    :param device:\n        The device on which to initialize modules.",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.builder",
        "documentation": {}
    },
    {
        "label": "MutoxClassifier",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.classifier",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.classifier",
        "peekOfCode": "class MutoxClassifier(nn.Module):\n    def __init__(\n        self,\n        model_all,\n    ):\n        super().__init__()\n        self.model_all = model_all\n    def forward(self, inputs: torch.Tensor) -> torch.Tensor:\n        return self.model_all(inputs)\n@dataclass",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "MutoxConfig",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.classifier",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.classifier",
        "peekOfCode": "class MutoxConfig:\n    \"\"\"Holds the configuration of a Mutox Classifier model.\"\"\"\n    # size of the input embedding supported by this model\n    input_size: int\nmutox_archs = ArchitectureRegistry[MutoxConfig](\"mutox_classifier\")",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "mutox_archs",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.classifier",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.classifier",
        "peekOfCode": "mutox_archs = ArchitectureRegistry[MutoxConfig](\"mutox_classifier\")",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.classifier",
        "documentation": {}
    },
    {
        "label": "convert_mutox_checkpoint",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.loader",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.loader",
        "peekOfCode": "def convert_mutox_checkpoint(\n    checkpoint: tp.Mapping[str, tp.Any], config: MutoxConfig\n) -> tp.Mapping[str, tp.Any]:\n    new_dict = {}\n    for key in checkpoint:\n        if key.startswith(\"model_all.\"):\n            new_dict[key] = checkpoint[key]\n    return {\"model\": new_dict}\nload_mutox_config = ConfigLoader[MutoxConfig](asset_store, mutox_archs)\nload_mutox_model = ModelLoader[MutoxClassifier, MutoxConfig](",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.loader",
        "documentation": {}
    },
    {
        "label": "load_mutox_config",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.loader",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.loader",
        "peekOfCode": "load_mutox_config = ConfigLoader[MutoxConfig](asset_store, mutox_archs)\nload_mutox_model = ModelLoader[MutoxClassifier, MutoxConfig](\n    asset_store,\n    download_manager,\n    load_mutox_config,\n    create_mutox_model,\n    convert_mutox_checkpoint,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.loader",
        "documentation": {}
    },
    {
        "label": "load_mutox_model",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.loader",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.loader",
        "peekOfCode": "load_mutox_model = ModelLoader[MutoxClassifier, MutoxConfig](\n    asset_store,\n    download_manager,\n    load_mutox_config,\n    create_mutox_model,\n    convert_mutox_checkpoint,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.loader",
        "documentation": {}
    },
    {
        "label": "MutoxSpeechClassifierPipeline",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.speech_pipeline",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.speech_pipeline",
        "peekOfCode": "class MutoxSpeechClassifierPipeline(SpeechToEmbeddingPipeline):\n    def __init__(\n        self,\n        mutox_classifier: Union[str, MutoxClassifier],\n        encoder: Union[str, SonarEncoderModel],\n        device: Device = CPU_DEVICE,\n    ) -> None:\n        super().__init__(encoder)\n        self.model.to(device).eval()\n        self.mutox_classifier = mutox_classifier.to(device).eval()",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.speech_pipeline",
        "documentation": {}
    },
    {
        "label": "CPU_DEVICE",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.speech_pipeline",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.speech_pipeline",
        "peekOfCode": "CPU_DEVICE = torch.device(\"cpu\")\nclass MutoxSpeechClassifierPipeline(SpeechToEmbeddingPipeline):\n    def __init__(\n        self,\n        mutox_classifier: Union[str, MutoxClassifier],\n        encoder: Union[str, SonarEncoderModel],\n        device: Device = CPU_DEVICE,\n    ) -> None:\n        super().__init__(encoder)\n        self.model.to(device).eval()",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mutox.speech_pipeline",
        "documentation": {}
    },
    {
        "label": "ETOXBadWordChecker",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.etox_bad_word_checker",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.etox_bad_word_checker",
        "peekOfCode": "class ETOXBadWordChecker:\n    bad_words: Dict[str, List[str]]\n    bad_word_variants: Dict[str, Dict[str, List[str]]]\n    sp_encoder: SentencePieceEncoder\n    sp_langs: Set[str]\n    def __init__(\n        self,\n        bad_words: Dict[str, List[str]],\n        bad_word_variants: Dict[str, Dict[str, List[str]]],\n        sp_encoder: SentencePieceEncoder,",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.etox_bad_word_checker",
        "documentation": {}
    },
    {
        "label": "ETOXBadWordCheckerLoader",
        "kind": 6,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.etox_bad_word_checker",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.etox_bad_word_checker",
        "peekOfCode": "class ETOXBadWordCheckerLoader:\n    asset_store: AssetStore\n    download_manager: AssetDownloadManager\n    def __init__(\n        self,\n        asset_store: AssetStore,\n        download_manager: AssetDownloadManager,\n    ) -> None:\n        self.asset_store = asset_store\n        self.download_manager = download_manager",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.etox_bad_word_checker",
        "documentation": {}
    },
    {
        "label": "load_etox_bad_word_checker",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.etox_bad_word_checker",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.etox_bad_word_checker",
        "peekOfCode": "load_etox_bad_word_checker = ETOXBadWordCheckerLoader(\n    base_asset_store,\n    base_download_manager,\n)",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.etox_bad_word_checker",
        "documentation": {}
    },
    {
        "label": "mintox_pipeline",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mintox",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mintox",
        "peekOfCode": "def mintox_pipeline(\n    model: UnitYModel,\n    text_tokenizer: TextTokenizer,\n    unit_tokenizer: UnitTokenizer,\n    device: Device,\n    src_lang: str,\n    tgt_lang: str,\n    model_input: SequenceData,\n    input_modality: \"Modality\",\n    output_modality: \"Modality\",",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mintox",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lib.seamless_communication.src.seamless_communication.toxicity.mintox",
        "description": "lib.seamless_communication.src.seamless_communication.toxicity.mintox",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef _extract_bad_words_with_batch_indices(\n    source_texts: List[StringLike],\n    target_texts: List[StringLike],\n    source_lang: str,\n    target_lang: str,\n    bad_word_checker: ETOXBadWordChecker,\n) -> Tuple[List[str], List[int]]:\n    all_bad_words, batch_indices = [], []\n    for idx, (source_text, target_text) in enumerate(zip(source_texts, target_texts)):",
        "detail": "lib.seamless_communication.src.seamless_communication.toxicity.mintox",
        "documentation": {}
    },
    {
        "label": "add_gated_assets",
        "kind": 2,
        "importPath": "lib.seamless_communication.src.seamless_communication.store",
        "description": "lib.seamless_communication.src.seamless_communication.store",
        "peekOfCode": "def add_gated_assets(model_dir: Path) -> None:\n    asset_store.env_resolvers.append(lambda: \"gated\")\n    model_dir = model_dir.resolve()\n    gated_metadata = [\n        {\n            \"name\": \"seamless_expressivity@gated\",\n            \"checkpoint\": model_dir.joinpath(\"m2m_expressive_unity.pt\"),\n        },\n        {\n            \"name\": \"vocoder_pretssel@gated\",",
        "detail": "lib.seamless_communication.src.seamless_communication.store",
        "documentation": {}
    },
    {
        "label": "bad_words_checker",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.integration.inference.test_mintox",
        "description": "lib.seamless_communication.tests.integration.inference.test_mintox",
        "peekOfCode": "def bad_words_checker() -> ETOXBadWordChecker:\n    return load_etox_bad_word_checker(\"mintox\")\ndef test_mintox_s2tt(bad_words_checker: ETOXBadWordChecker):\n    model_name = \"seamlessM4T_v2_large\"\n    vocoder_name = \"vocoder_v2\"\n    src_text = \"The strategy proved effective, cutting off vital military and civilian supplies, although this blockade violated generally accepted international law codified by several international agreements of the past two centuries.\"\n    src_lang = \"eng\"\n    tgt_lang = \"fra\"\n    task = \"s2tt\"\n    sample_rate = 16_000",
        "detail": "lib.seamless_communication.tests.integration.inference.test_mintox",
        "documentation": {}
    },
    {
        "label": "test_mintox_s2tt",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.integration.inference.test_mintox",
        "description": "lib.seamless_communication.tests.integration.inference.test_mintox",
        "peekOfCode": "def test_mintox_s2tt(bad_words_checker: ETOXBadWordChecker):\n    model_name = \"seamlessM4T_v2_large\"\n    vocoder_name = \"vocoder_v2\"\n    src_text = \"The strategy proved effective, cutting off vital military and civilian supplies, although this blockade violated generally accepted international law codified by several international agreements of the past two centuries.\"\n    src_lang = \"eng\"\n    tgt_lang = \"fra\"\n    task = \"s2tt\"\n    sample_rate = 16_000\n    test_wav_uri = \"https://dl.fbaipublicfiles.com/seamlessM4T/inference/mintox/mintox_s2t_test_file.wav\"\n    input_wav = str(download_manager.download_checkpoint(test_wav_uri, test_wav_uri))",
        "detail": "lib.seamless_communication.tests.integration.inference.test_mintox",
        "documentation": {}
    },
    {
        "label": "test_mintox_t2tt",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.integration.inference.test_mintox",
        "description": "lib.seamless_communication.tests.integration.inference.test_mintox",
        "peekOfCode": "def test_mintox_t2tt(bad_words_checker: ETOXBadWordChecker):\n    model_name = \"seamlessM4T_v2_large\"\n    vocoder_name = \"vocoder_v2\"\n    src_text = \"I wonder what it'd be like to be a doff parent.\"\n    src_lang = \"eng\"\n    tgt_lang = \"fra\"\n    task = \"t2tt\"\n    dtype = get_default_dtype()\n    translator_without_mintox = Translator(\n        model_name, vocoder_name, device, dtype=dtype",
        "detail": "lib.seamless_communication.tests.integration.inference.test_mintox",
        "documentation": {}
    },
    {
        "label": "test_seamless_m4t_large_t2tt",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.integration.inference.test_translator",
        "description": "lib.seamless_communication.tests.integration.inference.test_translator",
        "peekOfCode": "def test_seamless_m4t_large_t2tt() -> None:\n    model_name = \"seamlessM4T_large\"\n    src_lang = \"eng\"\n    tgt_lang = \"deu\"\n    dtype = get_default_dtype()\n    translator = Translator(model_name, \"vocoder_36langs\", device, dtype=dtype)\n    text_output, _ = translator.predict(\n        ENG_SENTENCE,\n        \"t2tt\",\n        tgt_lang,",
        "detail": "lib.seamless_communication.tests.integration.inference.test_translator",
        "documentation": {}
    },
    {
        "label": "test_seamless_m4t_v2_large_t2tt",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.integration.inference.test_translator",
        "description": "lib.seamless_communication.tests.integration.inference.test_translator",
        "peekOfCode": "def test_seamless_m4t_v2_large_t2tt() -> None:\n    model_name = \"seamlessM4T_v2_large\"\n    src_lang = \"eng\"\n    tgt_lang = \"deu\"\n    dtype = get_default_dtype()\n    translator = Translator(model_name, \"vocoder_v2\", device, dtype=dtype)\n    text_output, _ = translator.predict(\n        ENG_SENTENCE,\n        \"t2tt\",\n        tgt_lang,",
        "detail": "lib.seamless_communication.tests.integration.inference.test_translator",
        "documentation": {}
    },
    {
        "label": "test_seamless_m4t_v2_large_multiple_tasks",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.integration.inference.test_translator",
        "description": "lib.seamless_communication.tests.integration.inference.test_translator",
        "peekOfCode": "def test_seamless_m4t_v2_large_multiple_tasks() -> None:\n    model_name = \"seamlessM4T_v2_large\"\n    english_text = \"Hello! I hope you're all doing well.\"\n    ref_spanish_text = \"Hola, espero que todo se esté haciendo bien.\"\n    ref_spanish_asr_text = \"Hola, espero que todo se esté haciendo bien.\"\n    dtype = get_default_dtype()\n    translator = Translator(model_name, \"vocoder_v2\", device, dtype=dtype)\n    # Generate english speech for the english text.\n    _, english_speech_output = translator.predict(\n        english_text,",
        "detail": "lib.seamless_communication.tests.integration.inference.test_translator",
        "documentation": {}
    },
    {
        "label": "test_conformer_shaw_600m",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.integration.models.test_conformer_shaw",
        "description": "lib.seamless_communication.tests.integration.models.test_conformer_shaw",
        "peekOfCode": "def test_conformer_shaw_600m(example_rate16k_audio: AudioDecoderOutput) -> None:\n    dtype = get_default_dtype()\n    audio_dict = example_rate16k_audio\n    src = convert_to_collated_fbank(audio_dict, dtype=dtype)\n    seqs, padding_mask = get_seqs_and_padding_mask(src)\n    model = load_conformer_shaw_model(\"conformer_shaw\", device=device, dtype=dtype)\n    model.eval()\n    with torch.inference_mode():\n        seqs, padding_mask = model.encoder_frontend(seqs, padding_mask)\n        seqs, _ = model.encoder(seqs, padding_mask)",
        "detail": "lib.seamless_communication.tests.integration.models.test_conformer_shaw",
        "documentation": {}
    },
    {
        "label": "test_aligner",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.integration.models.test_unity2_aligner",
        "description": "lib.seamless_communication.tests.integration.models.test_unity2_aligner",
        "peekOfCode": "def test_aligner(example_rate16k_audio: AudioDecoderOutput) -> None:\n    aligner_name = \"nar_t2u_aligner\"\n    unit_extractor_name = \"xlsr2_1b_v2\"\n    unit_extractor_output_layer_n = 35\n    unit_extractor_kmeans_uri = \"https://dl.fbaipublicfiles.com/seamlessM4T/models/unit_extraction/kmeans_10k.npy\"\n    dtype = get_default_dtype()\n    if dtype == torch.float32:\n        ref_tensor = REF_DURATIONS_FP32\n    else:\n        ref_tensor = REF_DURATIONS_FP16",
        "detail": "lib.seamless_communication.tests.integration.models.test_unity2_aligner",
        "documentation": {}
    },
    {
        "label": "REF_TEXT",
        "kind": 5,
        "importPath": "lib.seamless_communication.tests.integration.models.test_unity2_aligner",
        "description": "lib.seamless_communication.tests.integration.models.test_unity2_aligner",
        "peekOfCode": "REF_TEXT = \"the examination and testimony of the experts enabled the commision to conclude that five shots may have been fired\"\n# fmt: off\nREF_DURATIONS_FP16: Final = [[ 1,  1,  2,  1,  1,  5,  5,  6,  4,  3,  2,  3,  4,  4,  2,  2,  2,  1,\n          1,  1,  3,  3,  3,  4,  3,  3,  3,  4,  4,  3,  2,  2,  1,  1,  1,  1,\n          2,  4,  6,  5,  4,  3,  4,  5,  5, 16,  6,  3,  5,  5,  3,  3,  1,  2,\n          1,  1,  1,  2,  3,  2,  3,  1,  3,  3,  3,  2,  2,  4,  2,  2,  2,  3,\n          2,  4,  5,  4,  5,  8,  3, 17,  2,  2,  3,  2,  5,  4,  6,  3,  1,  1,\n          4,  4,  3,  5,  3,  3,  2,  2,  2,  2,  2,  2,  2,  1,  2,  2,  1,  1,\n          2,  6,  4,  5,  9,  5,  1, 12]]\n# fmt: on",
        "detail": "lib.seamless_communication.tests.integration.models.test_unity2_aligner",
        "documentation": {}
    },
    {
        "label": "TestUnitTokenizer",
        "kind": 6,
        "importPath": "lib.seamless_communication.tests.unit.models.unity.test_unity",
        "description": "lib.seamless_communication.tests.unit.models.unity.test_unity",
        "peekOfCode": "class TestUnitTokenizer:\n    def test_init_works(self) -> None:\n        tokenizer = UnitTokenizer(\n            num_units=100, langs=[\"eng\", \"deu\", \"fra\"], model_arch=\"seamlessM4T_large\"\n        )\n        assert tokenizer.num_units == 100\n        assert tokenizer.lang_map == {\"eng\": 0, \"deu\": 1, \"fra\": 2}\n        assert tokenizer.vocab_info.size == 112\n    def test_lang_to_index_works(self) -> None:\n        tokenizer = UnitTokenizer(",
        "detail": "lib.seamless_communication.tests.unit.models.unity.test_unity",
        "documentation": {}
    },
    {
        "label": "TestUnitEncoder",
        "kind": 6,
        "importPath": "lib.seamless_communication.tests.unit.models.unity.test_unity",
        "description": "lib.seamless_communication.tests.unit.models.unity.test_unity",
        "peekOfCode": "class TestUnitEncoder:\n    def test_init_raises_error_when_lang_is_not_supported(self) -> None:\n        tokenizer = UnitTokenizer(\n            num_units=100, langs=[\"eng\", \"deu\", \"fra\"], model_arch=\"seamlessM4T_large\"\n        )\n        with pytest.raises(\n            ValueError,\n            match=r\"^`lang` must be one of the supported languages\\, but is 'xyz' instead\\. Supported languages: eng, deu, fra$\",\n        ):\n            tokenizer.create_encoder(lang=\"xyz\", device=device)",
        "detail": "lib.seamless_communication.tests.unit.models.unity.test_unity",
        "documentation": {}
    },
    {
        "label": "TestUnitDecoder",
        "kind": 6,
        "importPath": "lib.seamless_communication.tests.unit.models.unity.test_unity",
        "description": "lib.seamless_communication.tests.unit.models.unity.test_unity",
        "peekOfCode": "class TestUnitDecoder:\n    def test_call_works(self) -> None:\n        tokenizer = UnitTokenizer(\n            num_units=100, langs=[\"eng\", \"deu\", \"fra\"], model_arch=\"seamlessM4T_large\"\n        )\n        encoder = tokenizer.create_encoder(lang=\"deu\", device=device)\n        decoder = tokenizer.create_decoder()\n        assert tokenizer.vocab_info.eos_idx is not None\n        assert tokenizer.vocab_info.pad_idx is not None\n        units1 = torch.ones((6, 4), device=device, dtype=torch.int64)",
        "detail": "lib.seamless_communication.tests.unit.models.unity.test_unity",
        "documentation": {}
    },
    {
        "label": "assert_close",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.common",
        "description": "lib.seamless_communication.tests.common",
        "peekOfCode": "def assert_close(\n    a: Tensor,\n    b: Union[Tensor, List[Any]],\n    rtol: Optional[float] = None,\n    atol: Optional[float] = None,\n) -> None:\n    \"\"\"Assert that ``a`` and ``b`` are element-wise equal within a tolerance.\"\"\"\n    if not isinstance(b, Tensor):\n        b = torch.tensor(b, device=device, dtype=a.dtype)\n    torch.testing.assert_close(a, b, rtol=rtol, atol=atol)  # type: ignore[attr-defined]",
        "detail": "lib.seamless_communication.tests.common",
        "documentation": {}
    },
    {
        "label": "assert_equal",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.common",
        "description": "lib.seamless_communication.tests.common",
        "peekOfCode": "def assert_equal(a: Tensor, b: Union[Tensor, List[Any]]) -> None:\n    \"\"\"Assert that ``a`` and ``b`` are element-wise equal.\"\"\"\n    if not isinstance(b, Tensor):\n        b = torch.tensor(b, device=device, dtype=a.dtype)\n    torch.testing.assert_close(a, b, rtol=0, atol=0)  # type: ignore[attr-defined]\ndef assert_unit_close(\n    a: Tensor,\n    b: Union[Tensor, List[Any]],\n    num_unit_tol: int = 1,\n    percent_unit_tol: float = 0.0,",
        "detail": "lib.seamless_communication.tests.common",
        "documentation": {}
    },
    {
        "label": "assert_unit_close",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.common",
        "description": "lib.seamless_communication.tests.common",
        "peekOfCode": "def assert_unit_close(\n    a: Tensor,\n    b: Union[Tensor, List[Any]],\n    num_unit_tol: int = 1,\n    percent_unit_tol: float = 0.0,\n) -> None:\n    \"\"\"Assert two unit sequence are equal within a tolerance\"\"\"\n    if not isinstance(b, Tensor):\n        b = torch.tensor(b, device=device, dtype=a.dtype)\n    assert (",
        "detail": "lib.seamless_communication.tests.common",
        "documentation": {}
    },
    {
        "label": "has_no_inf",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.common",
        "description": "lib.seamless_communication.tests.common",
        "peekOfCode": "def has_no_inf(a: Tensor) -> bool:\n    \"\"\"Return ``True`` if ``a`` has no positive or negative infinite element.\"\"\"\n    return not torch.any(torch.isinf(a))\ndef has_no_nan(a: Tensor) -> bool:\n    \"\"\"Return ``True`` if ``a`` has no NaN element.\"\"\"\n    return not torch.any(torch.isnan(a))\n@contextmanager\ndef tmp_rng_seed(device: Device, seed: int = 0) -> Generator[None, None, None]:\n    \"\"\"Set a temporary manual RNG seed.\n    The RNG is reset to its original state once the block is exited.",
        "detail": "lib.seamless_communication.tests.common",
        "documentation": {}
    },
    {
        "label": "has_no_nan",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.common",
        "description": "lib.seamless_communication.tests.common",
        "peekOfCode": "def has_no_nan(a: Tensor) -> bool:\n    \"\"\"Return ``True`` if ``a`` has no NaN element.\"\"\"\n    return not torch.any(torch.isnan(a))\n@contextmanager\ndef tmp_rng_seed(device: Device, seed: int = 0) -> Generator[None, None, None]:\n    \"\"\"Set a temporary manual RNG seed.\n    The RNG is reset to its original state once the block is exited.\n    \"\"\"\n    device = Device(device)\n    if device.type == \"cuda\":",
        "detail": "lib.seamless_communication.tests.common",
        "documentation": {}
    },
    {
        "label": "tmp_rng_seed",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.common",
        "description": "lib.seamless_communication.tests.common",
        "peekOfCode": "def tmp_rng_seed(device: Device, seed: int = 0) -> Generator[None, None, None]:\n    \"\"\"Set a temporary manual RNG seed.\n    The RNG is reset to its original state once the block is exited.\n    \"\"\"\n    device = Device(device)\n    if device.type == \"cuda\":\n        devices = [device]\n    else:\n        devices = []\n    with torch.random.fork_rng(devices):",
        "detail": "lib.seamless_communication.tests.common",
        "documentation": {}
    },
    {
        "label": "get_default_dtype",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.common",
        "description": "lib.seamless_communication.tests.common",
        "peekOfCode": "def get_default_dtype() -> DataType:\n    if device == Device(\"cpu\"):\n        dtype = torch.float32\n    else:\n        dtype = torch.float16\n    return dtype\ndef convert_to_collated_fbank(audio_dict: WaveformToFbankInput, dtype: DataType) -> Any:\n    convert_to_fbank = WaveformToFbankConverter(\n        num_mel_bins=80,\n        waveform_scale=2**15,",
        "detail": "lib.seamless_communication.tests.common",
        "documentation": {}
    },
    {
        "label": "convert_to_collated_fbank",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.common",
        "description": "lib.seamless_communication.tests.common",
        "peekOfCode": "def convert_to_collated_fbank(audio_dict: WaveformToFbankInput, dtype: DataType) -> Any:\n    convert_to_fbank = WaveformToFbankConverter(\n        num_mel_bins=80,\n        waveform_scale=2**15,\n        channel_last=True,\n        standardize=True,\n        device=device,\n        dtype=dtype,\n    )\n    collater = Collater(pad_value=1)",
        "detail": "lib.seamless_communication.tests.common",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "lib.seamless_communication.tests.common",
        "description": "lib.seamless_communication.tests.common",
        "peekOfCode": "device = Device(\"cpu\")\ndef assert_close(\n    a: Tensor,\n    b: Union[Tensor, List[Any]],\n    rtol: Optional[float] = None,\n    atol: Optional[float] = None,\n) -> None:\n    \"\"\"Assert that ``a`` and ``b`` are element-wise equal within a tolerance.\"\"\"\n    if not isinstance(b, Tensor):\n        b = torch.tensor(b, device=device, dtype=a.dtype)",
        "detail": "lib.seamless_communication.tests.common",
        "documentation": {}
    },
    {
        "label": "parse_device_arg",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.conftest",
        "description": "lib.seamless_communication.tests.conftest",
        "peekOfCode": "def parse_device_arg(value: str) -> Device:\n    try:\n        return Device(value)\n    except RuntimeError:\n        raise ArgumentTypeError(f\"'{value}' is not a valid device name.\")\ndef pytest_addoption(parser: pytest.Parser) -> None:\n    # fmt: off\n    parser.addoption(\n        \"--device\", default=\"cpu\", type=parse_device_arg,\n        help=\"device on which to run tests (default: %(default)s)\",",
        "detail": "lib.seamless_communication.tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.conftest",
        "description": "lib.seamless_communication.tests.conftest",
        "peekOfCode": "def pytest_addoption(parser: pytest.Parser) -> None:\n    # fmt: off\n    parser.addoption(\n        \"--device\", default=\"cpu\", type=parse_device_arg,\n        help=\"device on which to run tests (default: %(default)s)\",\n    )\n    # fmt: on\ndef pytest_sessionstart(session: pytest.Session) -> None:\n    tests.common.device = cast(Device, session.config.getoption(\"device\"))\n@pytest.fixture(scope=\"module\")",
        "detail": "lib.seamless_communication.tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_sessionstart",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.conftest",
        "description": "lib.seamless_communication.tests.conftest",
        "peekOfCode": "def pytest_sessionstart(session: pytest.Session) -> None:\n    tests.common.device = cast(Device, session.config.getoption(\"device\"))\n@pytest.fixture(scope=\"module\")\ndef example_rate16k_audio() -> AudioDecoderOutput:\n    url = \"https://dl.fbaipublicfiles.com/seamlessM4T/LJ037-0171_sr16k.wav\"\n    audio_decoder = AudioDecoder(dtype=torch.float32, device=tests.common.device)\n    with tempfile.NamedTemporaryFile() as f:\n        urlretrieve(url, f.name)\n        with open(f.name, \"rb\") as fb:\n            block = MemoryBlock(fb.read())",
        "detail": "lib.seamless_communication.tests.conftest",
        "documentation": {}
    },
    {
        "label": "example_rate16k_audio",
        "kind": 2,
        "importPath": "lib.seamless_communication.tests.conftest",
        "description": "lib.seamless_communication.tests.conftest",
        "peekOfCode": "def example_rate16k_audio() -> AudioDecoderOutput:\n    url = \"https://dl.fbaipublicfiles.com/seamlessM4T/LJ037-0171_sr16k.wav\"\n    audio_decoder = AudioDecoder(dtype=torch.float32, device=tests.common.device)\n    with tempfile.NamedTemporaryFile() as f:\n        urlretrieve(url, f.name)\n        with open(f.name, \"rb\") as fb:\n            block = MemoryBlock(fb.read())\n        decoded_audio = audio_decoder(block)\n    return decoded_audio",
        "detail": "lib.seamless_communication.tests.conftest",
        "documentation": {}
    },
    {
        "label": "allowed_file",
        "kind": 2,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "def allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\nswagger = Swagger(app)\n@app.route(\"/video/<filename>\")\ndef get_video(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n@app.route(\"/\")\ndef home():\n    return redirect(url_for('flasgger.apidocs'))\n@app.route('/api', methods=['POST'])",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "get_video",
        "kind": 2,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "def get_video(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n@app.route(\"/\")\ndef home():\n    return redirect(url_for('flasgger.apidocs'))\n@app.route('/api', methods=['POST'])\ndef extractvoicetext():\n    \"\"\"\n    Extracts text from audio file.\n    ---",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "def home():\n    return redirect(url_for('flasgger.apidocs'))\n@app.route('/api', methods=['POST'])\ndef extractvoicetext():\n    \"\"\"\n    Extracts text from audio file.\n    ---\n    parameters:\n      - name: file\n        in: formData",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "extractvoicetext",
        "kind": 2,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "def extractvoicetext():\n    \"\"\"\n    Extracts text from audio file.\n    ---\n    parameters:\n      - name: file\n        in: formData\n        type: file\n        required: no\n        description: The audio file to process (MP3 or WAV).",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "log_request_info",
        "kind": 2,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "def log_request_info():\n    app.logger.info('Request Headers: %s', request.headers)\n    app.logger.info('Request Method: %s', request.method)\n    app.logger.info('Request URL: %s', request.url)\n    app.logger.info('Request Data: %s', request.data)\nif __name__ == '__main__':\n    Detect = AudioOfficial(\n        # audio_path=\"./models/seamless-m4t-v2-large/\",\n        down_nmodel_path = \"./models/\" ,\n        model = \"large-v3\",",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "app = Flask(__name__)\nUPLOAD_FOLDER = './run/uploads/'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\nALLOWED_EXTENSIONS = set(['mp3', 'wav'])\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\nswagger = Swagger(app)\n@app.route(\"/video/<filename>\")\ndef get_video(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "UPLOAD_FOLDER",
        "kind": 5,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "UPLOAD_FOLDER = './run/uploads/'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\nALLOWED_EXTENSIONS = set(['mp3', 'wav'])\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\nswagger = Swagger(app)\n@app.route(\"/video/<filename>\")\ndef get_video(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n@app.route(\"/\")",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "app.config['UPLOAD_FOLDER']",
        "kind": 5,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\nALLOWED_EXTENSIONS = set(['mp3', 'wav'])\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\nswagger = Swagger(app)\n@app.route(\"/video/<filename>\")\ndef get_video(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n@app.route(\"/\")\ndef home():",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "ALLOWED_EXTENSIONS",
        "kind": 5,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "ALLOWED_EXTENSIONS = set(['mp3', 'wav'])\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\nswagger = Swagger(app)\n@app.route(\"/video/<filename>\")\ndef get_video(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n@app.route(\"/\")\ndef home():\n    return redirect(url_for('flasgger.apidocs'))",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "swagger",
        "kind": 5,
        "importPath": "pythontemp.app2",
        "description": "pythontemp.app2",
        "peekOfCode": "swagger = Swagger(app)\n@app.route(\"/video/<filename>\")\ndef get_video(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n@app.route(\"/\")\ndef home():\n    return redirect(url_for('flasgger.apidocs'))\n@app.route('/api', methods=['POST'])\ndef extractvoicetext():\n    \"\"\"",
        "detail": "pythontemp.app2",
        "documentation": {}
    },
    {
        "label": "MODEL_ID",
        "kind": 5,
        "importPath": "pythontemp.test",
        "description": "pythontemp.test",
        "peekOfCode": "MODEL_ID = \"vinai/PhoWhisper-large\"\npipe = pipeline(task=\"automatic-speech-recognition\", model=MODEL_ID)\npipe = pipeline(\n    task=\"automatic-speech-recognition\",\n    model=MODEL_ID,\n    chunk_length_s=30, \n    stride_length_s=(5,5), \n    return_timestamps=True,\n)\nres = pipe('converted_file.wav', )",
        "detail": "pythontemp.test",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 5,
        "importPath": "pythontemp.test",
        "description": "pythontemp.test",
        "peekOfCode": "pipe = pipeline(task=\"automatic-speech-recognition\", model=MODEL_ID)\npipe = pipeline(\n    task=\"automatic-speech-recognition\",\n    model=MODEL_ID,\n    chunk_length_s=30, \n    stride_length_s=(5,5), \n    return_timestamps=True,\n)\nres = pipe('converted_file.wav', )\nprint(res)",
        "detail": "pythontemp.test",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 5,
        "importPath": "pythontemp.test",
        "description": "pythontemp.test",
        "peekOfCode": "pipe = pipeline(\n    task=\"automatic-speech-recognition\",\n    model=MODEL_ID,\n    chunk_length_s=30, \n    stride_length_s=(5,5), \n    return_timestamps=True,\n)\nres = pipe('converted_file.wav', )\nprint(res)",
        "detail": "pythontemp.test",
        "documentation": {}
    },
    {
        "label": "res",
        "kind": 5,
        "importPath": "pythontemp.test",
        "description": "pythontemp.test",
        "peekOfCode": "res = pipe('converted_file.wav', )\nprint(res)",
        "detail": "pythontemp.test",
        "documentation": {}
    },
    {
        "label": "PEFT_MODEL_ID",
        "kind": 5,
        "importPath": "pythontemp.test2",
        "description": "pythontemp.test2",
        "peekOfCode": "PEFT_MODEL_ID = \"doof-ferb/whisper-large-peft-lora-vi\"\nBASE_MODEL_ID = PeftConfig.from_pretrained(PEFT_MODEL_ID).base_model_name_or_path\nFEATURE_EXTRACTOR = WhisperFeatureExtractor.from_pretrained(BASE_MODEL_ID)\nTOKENIZER = WhisperTokenizer.from_pretrained(BASE_MODEL_ID)\nMODEL = PeftModel.from_pretrained(\n    WhisperForConditionalGeneration.from_pretrained(BASE_MODEL_ID, torch_dtype=torch.float16).to(\"cuda:0\"),\n    PEFT_MODEL_ID\n).merge_and_unload(progressbar=True)\nDECODER_ID = torch.tensor(\n    TOKENIZER.convert_tokens_to_ids([\"<|startoftranscript|>\", \"<|vi|>\", \"<|transcribe|>\", \"<|notimestamps|>\"]),",
        "detail": "pythontemp.test2",
        "documentation": {}
    },
    {
        "label": "BASE_MODEL_ID",
        "kind": 5,
        "importPath": "pythontemp.test2",
        "description": "pythontemp.test2",
        "peekOfCode": "BASE_MODEL_ID = PeftConfig.from_pretrained(PEFT_MODEL_ID).base_model_name_or_path\nFEATURE_EXTRACTOR = WhisperFeatureExtractor.from_pretrained(BASE_MODEL_ID)\nTOKENIZER = WhisperTokenizer.from_pretrained(BASE_MODEL_ID)\nMODEL = PeftModel.from_pretrained(\n    WhisperForConditionalGeneration.from_pretrained(BASE_MODEL_ID, torch_dtype=torch.float16).to(\"cuda:0\"),\n    PEFT_MODEL_ID\n).merge_and_unload(progressbar=True)\nDECODER_ID = torch.tensor(\n    TOKENIZER.convert_tokens_to_ids([\"<|startoftranscript|>\", \"<|vi|>\", \"<|transcribe|>\", \"<|notimestamps|>\"]),\n    device=MODEL.device",
        "detail": "pythontemp.test2",
        "documentation": {}
    },
    {
        "label": "FEATURE_EXTRACTOR",
        "kind": 5,
        "importPath": "pythontemp.test2",
        "description": "pythontemp.test2",
        "peekOfCode": "FEATURE_EXTRACTOR = WhisperFeatureExtractor.from_pretrained(BASE_MODEL_ID)\nTOKENIZER = WhisperTokenizer.from_pretrained(BASE_MODEL_ID)\nMODEL = PeftModel.from_pretrained(\n    WhisperForConditionalGeneration.from_pretrained(BASE_MODEL_ID, torch_dtype=torch.float16).to(\"cuda:0\"),\n    PEFT_MODEL_ID\n).merge_and_unload(progressbar=True)\nDECODER_ID = torch.tensor(\n    TOKENIZER.convert_tokens_to_ids([\"<|startoftranscript|>\", \"<|vi|>\", \"<|transcribe|>\", \"<|notimestamps|>\"]),\n    device=MODEL.device\n).unsqueeze(dim=0)",
        "detail": "pythontemp.test2",
        "documentation": {}
    },
    {
        "label": "TOKENIZER",
        "kind": 5,
        "importPath": "pythontemp.test2",
        "description": "pythontemp.test2",
        "peekOfCode": "TOKENIZER = WhisperTokenizer.from_pretrained(BASE_MODEL_ID)\nMODEL = PeftModel.from_pretrained(\n    WhisperForConditionalGeneration.from_pretrained(BASE_MODEL_ID, torch_dtype=torch.float16).to(\"cuda:0\"),\n    PEFT_MODEL_ID\n).merge_and_unload(progressbar=True)\nDECODER_ID = torch.tensor(\n    TOKENIZER.convert_tokens_to_ids([\"<|startoftranscript|>\", \"<|vi|>\", \"<|transcribe|>\", \"<|notimestamps|>\"]),\n    device=MODEL.device\n).unsqueeze(dim=0)\nwaveform, sampling_rate = torchaudio.load(\"1.mp3\")",
        "detail": "pythontemp.test2",
        "documentation": {}
    },
    {
        "label": "MODEL",
        "kind": 5,
        "importPath": "pythontemp.test2",
        "description": "pythontemp.test2",
        "peekOfCode": "MODEL = PeftModel.from_pretrained(\n    WhisperForConditionalGeneration.from_pretrained(BASE_MODEL_ID, torch_dtype=torch.float16).to(\"cuda:0\"),\n    PEFT_MODEL_ID\n).merge_and_unload(progressbar=True)\nDECODER_ID = torch.tensor(\n    TOKENIZER.convert_tokens_to_ids([\"<|startoftranscript|>\", \"<|vi|>\", \"<|transcribe|>\", \"<|notimestamps|>\"]),\n    device=MODEL.device\n).unsqueeze(dim=0)\nwaveform, sampling_rate = torchaudio.load(\"1.mp3\")\nif waveform.size(0) > 1:  # convert dual to mono channel",
        "detail": "pythontemp.test2",
        "documentation": {}
    },
    {
        "label": "DECODER_ID",
        "kind": 5,
        "importPath": "pythontemp.test2",
        "description": "pythontemp.test2",
        "peekOfCode": "DECODER_ID = torch.tensor(\n    TOKENIZER.convert_tokens_to_ids([\"<|startoftranscript|>\", \"<|vi|>\", \"<|transcribe|>\", \"<|notimestamps|>\"]),\n    device=MODEL.device\n).unsqueeze(dim=0)\nwaveform, sampling_rate = torchaudio.load(\"1.mp3\")\nif waveform.size(0) > 1:  # convert dual to mono channel\n    waveform = waveform.mean(dim=0, keepdim=True)\ninputs = FEATURE_EXTRACTOR(waveform, sampling_rate=sampling_rate, return_tensors=\"pt\").to(MODEL.device)\nwith torch.inference_mode(), torch.autocast(device_type=\"cuda\"):  # required by PEFT\n    predicted_ids = MODEL.generate(input_features=inputs.input_features, decoder_input_ids=DECODER_ID)",
        "detail": "pythontemp.test2",
        "documentation": {}
    },
    {
        "label": "inputs",
        "kind": 5,
        "importPath": "pythontemp.test2",
        "description": "pythontemp.test2",
        "peekOfCode": "inputs = FEATURE_EXTRACTOR(waveform, sampling_rate=sampling_rate, return_tensors=\"pt\").to(MODEL.device)\nwith torch.inference_mode(), torch.autocast(device_type=\"cuda\"):  # required by PEFT\n    predicted_ids = MODEL.generate(input_features=inputs.input_features, decoder_input_ids=DECODER_ID)\nTOKENIZER.batch_decode(predicted_ids, skip_special_tokens=True)[0]",
        "detail": "pythontemp.test2",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "pythontemp.test3",
        "description": "pythontemp.test3",
        "peekOfCode": "device = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\ncompute_type = \"float16\" if torch.cuda.is_available() else \"float32\"\n# load model on GPU if available, else cpu\nmodel = WhisperModel(\"distil-whisper/distil-large-v3-ct2\", device=device, compute_type=compute_type)\n# load toy dataset for example\nsample = \"1.mp3\"\nsegments, info = model.transcribe(sample, vad_filter=True, vad_parameters=dict(min_silence_duration_ms=500), word_timestamps=True, language=\"vi\")\nfor segment in segments:\n    print(\"[%.2fs -> %.2fs] %s\" % (segment.start, segment.end, segment.text))",
        "detail": "pythontemp.test3",
        "documentation": {}
    },
    {
        "label": "compute_type",
        "kind": 5,
        "importPath": "pythontemp.test3",
        "description": "pythontemp.test3",
        "peekOfCode": "compute_type = \"float16\" if torch.cuda.is_available() else \"float32\"\n# load model on GPU if available, else cpu\nmodel = WhisperModel(\"distil-whisper/distil-large-v3-ct2\", device=device, compute_type=compute_type)\n# load toy dataset for example\nsample = \"1.mp3\"\nsegments, info = model.transcribe(sample, vad_filter=True, vad_parameters=dict(min_silence_duration_ms=500), word_timestamps=True, language=\"vi\")\nfor segment in segments:\n    print(\"[%.2fs -> %.2fs] %s\" % (segment.start, segment.end, segment.text))",
        "detail": "pythontemp.test3",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "pythontemp.test3",
        "description": "pythontemp.test3",
        "peekOfCode": "model = WhisperModel(\"distil-whisper/distil-large-v3-ct2\", device=device, compute_type=compute_type)\n# load toy dataset for example\nsample = \"1.mp3\"\nsegments, info = model.transcribe(sample, vad_filter=True, vad_parameters=dict(min_silence_duration_ms=500), word_timestamps=True, language=\"vi\")\nfor segment in segments:\n    print(\"[%.2fs -> %.2fs] %s\" % (segment.start, segment.end, segment.text))",
        "detail": "pythontemp.test3",
        "documentation": {}
    },
    {
        "label": "sample",
        "kind": 5,
        "importPath": "pythontemp.test3",
        "description": "pythontemp.test3",
        "peekOfCode": "sample = \"1.mp3\"\nsegments, info = model.transcribe(sample, vad_filter=True, vad_parameters=dict(min_silence_duration_ms=500), word_timestamps=True, language=\"vi\")\nfor segment in segments:\n    print(\"[%.2fs -> %.2fs] %s\" % (segment.start, segment.end, segment.text))",
        "detail": "pythontemp.test3",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "pythontemp.test4",
        "description": "pythontemp.test4",
        "peekOfCode": "device = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\ntorch_dtype = torch.float16 if torch.cuda.is_available() else torch.float32\nmodel_id = \"distil-whisper/distil-large-v3\"\nmodel = AutoModelForSpeechSeq2Seq.from_pretrained(\n    model_id, torch_dtype=torch_dtype, low_cpu_mem_usage=True, use_safetensors=True\n)\nmodel.to(device)\nprocessor = AutoProcessor.from_pretrained(model_id)\npipe = pipeline(\n    \"automatic-speech-recognition\",",
        "detail": "pythontemp.test4",
        "documentation": {}
    },
    {
        "label": "torch_dtype",
        "kind": 5,
        "importPath": "pythontemp.test4",
        "description": "pythontemp.test4",
        "peekOfCode": "torch_dtype = torch.float16 if torch.cuda.is_available() else torch.float32\nmodel_id = \"distil-whisper/distil-large-v3\"\nmodel = AutoModelForSpeechSeq2Seq.from_pretrained(\n    model_id, torch_dtype=torch_dtype, low_cpu_mem_usage=True, use_safetensors=True\n)\nmodel.to(device)\nprocessor = AutoProcessor.from_pretrained(model_id)\npipe = pipeline(\n    \"automatic-speech-recognition\",\n    model=model,",
        "detail": "pythontemp.test4",
        "documentation": {}
    },
    {
        "label": "model_id",
        "kind": 5,
        "importPath": "pythontemp.test4",
        "description": "pythontemp.test4",
        "peekOfCode": "model_id = \"distil-whisper/distil-large-v3\"\nmodel = AutoModelForSpeechSeq2Seq.from_pretrained(\n    model_id, torch_dtype=torch_dtype, low_cpu_mem_usage=True, use_safetensors=True\n)\nmodel.to(device)\nprocessor = AutoProcessor.from_pretrained(model_id)\npipe = pipeline(\n    \"automatic-speech-recognition\",\n    model=model,\n    tokenizer=processor.tokenizer,",
        "detail": "pythontemp.test4",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "pythontemp.test4",
        "description": "pythontemp.test4",
        "peekOfCode": "model = AutoModelForSpeechSeq2Seq.from_pretrained(\n    model_id, torch_dtype=torch_dtype, low_cpu_mem_usage=True, use_safetensors=True\n)\nmodel.to(device)\nprocessor = AutoProcessor.from_pretrained(model_id)\npipe = pipeline(\n    \"automatic-speech-recognition\",\n    model=model,\n    tokenizer=processor.tokenizer,\n    feature_extractor=processor.feature_extractor,",
        "detail": "pythontemp.test4",
        "documentation": {}
    },
    {
        "label": "processor",
        "kind": 5,
        "importPath": "pythontemp.test4",
        "description": "pythontemp.test4",
        "peekOfCode": "processor = AutoProcessor.from_pretrained(model_id)\npipe = pipeline(\n    \"automatic-speech-recognition\",\n    model=model,\n    tokenizer=processor.tokenizer,\n    feature_extractor=processor.feature_extractor,\n    max_new_tokens=128,\n    torch_dtype=torch_dtype,\n    device=device,\n)",
        "detail": "pythontemp.test4",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 5,
        "importPath": "pythontemp.test4",
        "description": "pythontemp.test4",
        "peekOfCode": "pipe = pipeline(\n    \"automatic-speech-recognition\",\n    model=model,\n    tokenizer=processor.tokenizer,\n    feature_extractor=processor.feature_extractor,\n    max_new_tokens=128,\n    torch_dtype=torch_dtype,\n    device=device,\n)\ndataset = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")",
        "detail": "pythontemp.test4",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 5,
        "importPath": "pythontemp.test4",
        "description": "pythontemp.test4",
        "peekOfCode": "dataset = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")\nsample = dataset[0][\"audio\"]\nresult = pipe(sample, return_timestamps=True , generate_kwargs={\"language\": \"Vietnamese\"})\nprint(result[\"text\"])",
        "detail": "pythontemp.test4",
        "documentation": {}
    },
    {
        "label": "sample",
        "kind": 5,
        "importPath": "pythontemp.test4",
        "description": "pythontemp.test4",
        "peekOfCode": "sample = dataset[0][\"audio\"]\nresult = pipe(sample, return_timestamps=True , generate_kwargs={\"language\": \"Vietnamese\"})\nprint(result[\"text\"])",
        "detail": "pythontemp.test4",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "pythontemp.test4",
        "description": "pythontemp.test4",
        "peekOfCode": "result = pipe(sample, return_timestamps=True , generate_kwargs={\"language\": \"Vietnamese\"})\nprint(result[\"text\"])",
        "detail": "pythontemp.test4",
        "documentation": {}
    },
    {
        "label": "run_asr_facebook",
        "kind": 2,
        "importPath": "pythontemp.z",
        "description": "pythontemp.z",
        "peekOfCode": "def run_asr_facebook(input_audio: str, target_language: str) -> str:\n    out_texts, _ = translator.predict(\n        input=input_audio,\n        task_str=\"ASR\",\n        src_lang=target_language,\n        tgt_lang=target_language,\n    )\n    return str(out_texts[0])\ndef crop_audio(input_file, output_file, start_time_ms, end_time_ms):\n    # Load the audio file",
        "detail": "pythontemp.z",
        "documentation": {}
    },
    {
        "label": "crop_audio",
        "kind": 2,
        "importPath": "pythontemp.z",
        "description": "pythontemp.z",
        "peekOfCode": "def crop_audio(input_file, output_file, start_time_ms, end_time_ms):\n    # Load the audio file\n    audio = AudioSegment.from_file(input_file)\n    # Crop the audio\n    cropped_audio = audio[start_time_ms:end_time_ms]\n    # Export the cropped audio to a new file\n    cropped_audio.export(output_file, format=\"mp3\")  # Adjust the format as needed\nif __name__ == '__main__':\n    input = \"converted_file.wav\"\n    output = \"output.wav\"",
        "detail": "pythontemp.z",
        "documentation": {}
    },
    {
        "label": "translator",
        "kind": 5,
        "importPath": "pythontemp.z",
        "description": "pythontemp.z",
        "peekOfCode": "translator = Translator(\"seamlessM4T_v2_large\", vocoder_name_or_card=\"vocoder_v2\",device=torch.device(\"cpu\") , dtype=torch.float32 )\ndef run_asr_facebook(input_audio: str, target_language: str) -> str:\n    out_texts, _ = translator.predict(\n        input=input_audio,\n        task_str=\"ASR\",\n        src_lang=target_language,\n        tgt_lang=target_language,\n    )\n    return str(out_texts[0])\ndef crop_audio(input_file, output_file, start_time_ms, end_time_ms):",
        "detail": "pythontemp.z",
        "documentation": {}
    },
    {
        "label": "transcribe",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def transcribe(inputs , task):\n    if inputs is None:\n        raise gr.Error(\"No audio file submitted! Please upload or record an audio file before submitting your request.\")\n    text = \"\"\n    # max_length = int(MAX_INPUT_AUDIO_LENGTH * AUDIO_SAMPLE_RATE)\n    # if new_arr.shape[1] > max_length:\n    #     new_arr = new_arr[:, :max_length]\n    #     gr.Warning(f\"Input audio is too long. Only the first {MAX_INPUT_AUDIO_LENGTH} seconds is used.\")\n    # text = pipe(inputs, batch_size=BATCH_SIZE, generate_kwargs={\"task\": task}, return_timestamps=True)[\"text\"]\n    data , Resuft = Detect.ExtractText(inputs)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "demo",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "demo = gr.Blocks()\nmf_transcribe = gr.Interface(\n    fn=transcribe,\n    inputs=[\n        gr.Audio(sources=[\"microphone\"], type=\"filepath\"),\n        # gr.Radio([\"transcribe\", \"translate\"], label=\"Task\", value=\"transcribe\"),\n    ],\n    outputs=\"text\",\n    # theme=\"huggingface\",\n    title=\"Speak To Text\",",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "mf_transcribe",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "mf_transcribe = gr.Interface(\n    fn=transcribe,\n    inputs=[\n        gr.Audio(sources=[\"microphone\"], type=\"filepath\"),\n        # gr.Radio([\"transcribe\", \"translate\"], label=\"Task\", value=\"transcribe\"),\n    ],\n    outputs=\"text\",\n    # theme=\"huggingface\",\n    title=\"Speak To Text\",\n    description=(",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "file_transcribe",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "file_transcribe = gr.Interface(\n    fn=transcribe,\n    inputs=[\n        gr.Audio(sources=[\"upload\"], type=\"filepath\", label=\"Audio file\" , max_length = 360),\n        # gr.Radio([\"transcribe\", \"translate\"], label=\"Task\", value=\"transcribe\"),\n    ],\n    outputs=\"text\",\n    # theme=\"huggingface\",\n    title=\"Audio to Text\",\n    description=(",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "AudioOfficial",
        "kind": 6,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "class AudioOfficial:\n    def __init__(self, **kwargs):\n        if torch.cuda.is_available():\n            self.cuda = torch.device(\"cuda:0\")\n            self.compute_type=torch.float16\n            self.devicewhisper = \"cuda\"\n        else:\n            self.cuda = torch.device(\"cpu\")\n            self.compute_type=torch.float32\n            self.devicewhisper = \"cpu\"",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "clearFolderContent",
        "kind": 2,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "def clearFolderContent(folder_path):\n    # Function to clear contents of a folder\n    for filename in os.listdir(folder_path):\n        file_path = os.path.join(folder_path, filename)\n        try:\n            if os.path.isfile(file_path):\n                os.unlink(file_path)\n        except Exception as e:\n            print(f\"Failed to delete {file_path}. Reason: {e}\")\ndef preprocess_audio(input_audio: str, output_path: str = \"./run/uploads/\") -> str:",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "preprocess_audio",
        "kind": 2,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "def preprocess_audio(input_audio: str, output_path: str = \"./run/uploads/\") -> str:\n    arr, org_sr = torchaudio.load(input_audio)\n    num_channels = arr.shape[0]\n    if num_channels == 2:\n        a = \"Đây là stereo (dual channel) audio.\"\n    elif num_channels == 1:\n        a = \"Đây là mono channel audio.\"\n    else:\n        a= \"Không xác định được số kênh của tín hiệu âm thanh.\"\n    if arr.size(0) > 1:  # convert dual to mono channel",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "crop_audio",
        "kind": 2,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "def crop_audio(audio_tensor, start_time, end_time):\n    audio = AudioSegment.from_file(audio_tensor)\n    segment = audio[start_time:end_time]\n    temp_path = \"./run/uploads/temporary_audio.wav\"\n    segment.export(temp_path, format=\"wav\")\n    return temp_path\nlanguage_code_to_name = {\n    \"afr\": \"Afrikaans\",\n    \"amh\": \"Amharic\",\n    \"arb\": \"Modern Standard Arabic\",",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "language_code_to_name",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "language_code_to_name = {\n    \"afr\": \"Afrikaans\",\n    \"amh\": \"Amharic\",\n    \"arb\": \"Modern Standard Arabic\",\n    \"ary\": \"Moroccan Arabic\",\n    \"arz\": \"Egyptian Arabic\",\n    \"asm\": \"Assamese\",\n    \"ast\": \"Asturian\",\n    \"azj\": \"North Azerbaijani\",\n    \"bel\": \"Belarusian\",",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_NAME_TO_CODE",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "LANGUAGE_NAME_TO_CODE = {v: k for k, v in language_code_to_name.items()}\n# Source langs: S2ST / S2TT / ASR don't need source lang\n# T2TT / T2ST use this\ntext_source_language_codes = [\n    \"afr\",\n    \"amh\",\n    \"arb\",\n    \"ary\",\n    \"arz\",\n    \"asm\",",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "text_source_language_codes",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "text_source_language_codes = [\n    \"afr\",\n    \"amh\",\n    \"arb\",\n    \"ary\",\n    \"arz\",\n    \"asm\",\n    \"azj\",\n    \"bel\",\n    \"ben\",",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "TEXT_SOURCE_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "TEXT_SOURCE_LANGUAGE_NAMES = sorted([language_code_to_name[code] for code in text_source_language_codes])\n# Target langs:\n# S2ST / T2ST\ns2st_target_language_codes = [\n    \"eng\",\n    \"arb\",\n    \"ben\",\n    \"cat\",\n    \"ces\",\n    \"cmn\",",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "s2st_target_language_codes",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "s2st_target_language_codes = [\n    \"eng\",\n    \"arb\",\n    \"ben\",\n    \"cat\",\n    \"ces\",\n    \"cmn\",\n    \"cym\",\n    \"dan\",\n    \"deu\",",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "S2ST_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "S2ST_TARGET_LANGUAGE_NAMES = sorted([language_code_to_name[code] for code in s2st_target_language_codes])\nT2ST_TARGET_LANGUAGE_NAMES = S2ST_TARGET_LANGUAGE_NAMES\n# S2TT / T2TT / ASR\nS2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nT2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "T2ST_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "T2ST_TARGET_LANGUAGE_NAMES = S2ST_TARGET_LANGUAGE_NAMES\n# S2TT / T2TT / ASR\nS2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nT2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "S2TT_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "S2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nT2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "T2TT_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "T2TT_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES\nASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "ASR_TARGET_LANGUAGE_NAMES",
        "kind": 5,
        "importPath": "util",
        "description": "util",
        "peekOfCode": "ASR_TARGET_LANGUAGE_NAMES = TEXT_SOURCE_LANGUAGE_NAMES",
        "detail": "util",
        "documentation": {}
    }
]